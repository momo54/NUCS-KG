[
  {
    "title": "AI-Introduction: Fundamental Issues",
    "CS Core": "1. Overview of AI problems, Examples of successful recent AI applications\n2. Definitions of agents with examples (e.g., reactive, deliberative)\n3. What is intelligent behavior?\na. The Turing test and its flaws\nb. Multimodal input and output\nc. Simulation of intelligent behavior\nd. Rational versus non-rational reasoning\n4. Problem characteristics\na. Fully versus partially observable\nb. Single versus multi-agent\nc. Deterministic versus stochastic\nd. Static versus dynamic\ne. Discrete versus continuous\n5. Nature of agents\n67\na. Autonomous, semi-autonomous, mixed-initiative autonomy\nb. Reflexive, goal-based, and utility-based\nc. Decision making under uncertainty and with incomplete information\nd. The importance of perception and environmental interactions\ne. Learning-based agents\nf. Embodied agents\ni. sensors, dynamics, effectors\n6. Overview of AI Applications, growth, and impact (economic, societal, ethics)",
    "KA Core": "7. Practice identifying problem characteristics in example environments\n8. Additional depth on nature of agents with examples\n9. Additional depth on AI Applications, Growth, and Impact (economic, societal, ethics, security)",
    "Non-core": "10. Philosophical issues\n11. History of AI",
    "Illustrative Learning Outcomes": "1. Describe the Turing test and the “Chinese Room” thought experiment.\n2. Differentiate between optimal reasoning/behavior and human-like reasoning/behavior.\n3. Differentiate the terms: AI, machine learning, and deep learning.\n4. Enumerate the characteristics of a specific problem."
  },
  {
    "title": "AI-Search: Search",
    "CS Core": "1. State space representation of a problem\na. Specifying states, goals, and operators\nb. Factoring states into representations (hypothesis spaces)\nc. Problem solving by graph search\ni. e.g., Graphs as a space, and tree traversals as exploration of that space\nii. Dynamic construction of the graph (not given upfront)\n2. Uninformed graph search for problem solving (See also: AL-Foundational)\na. Breadth-first search\nb. Depth-first search\ni. With iterative deepening\nc. Uniform cost search\n3. Heuristic graph search for problem solving (See also: AL-Strategies)\na. Heuristic construction and admissibility\nb. Hill-climbing\nc. Local minima and the search landscape\ni. Local vs global solutions\nd. Greedy best-first search\ne. A* search\n68\n4. Space and time complexities of graph search algorithms",
    "KA Core": "5. Bidirectional search\n6. Beam search\n7. Two-player adversarial games\na. Minimax search\nb. Alpha-beta pruning\ni. Ply cutoff\n8. Implementation of A* search\n9. Constraint satisfaction",
    "Non-core": "10. Understanding the search space\na. Constructing search trees\nb. Dynamic search spaces\nc. Combinatorial explosion of search space\nd. Search space topology (e.g., ridges, saddle points, local minima)\n11. Local search\n12. Tabu search\n13. Variations on A* (IDA*, SMA*, RBFS)\n14. Two-player adversarial games\na. The horizon effect\nb. Opening playbooks/endgame solutions\nc. What it means to “solve” a game (e.g., checkers)\n15. Implementation of minimax search, beam search\n16. Expectimax search (MDP-solving) and chance nodes\n17. Stochastic search\na. Simulated annealing\nb. Genetic algorithms\nc. Monte-Carlo tree search",
    "Illustrative Learning Outcomes": "1. Design the state space representation for a puzzle (e.g., N-queens or 3-jug problem)\n2. Select and implement an appropriate uninformed search algorithm for a problem (e.g., tic-tac-toe),\nand characterize its time and space complexities.\n3. Select and implement an appropriate informed search algorithm for a problem after designing a\nhelpful heuristic function (e.g., a robot navigating a 2D gridworld).\n4. Evaluate whether a heuristic for a given problem is admissible/can guarantee an optimal solution.\n5. Apply minimax search in a two-player adversarial game (e.g., connect four), using heuristic\nevaluation at a particular depth to compute the scores to back up. [KA Core]\n6. Design and implement a genetic algorithm solution to a problem.\n7. Design and implement a simulated annealing schedule to avoid local minima in a problem.\n69\n8. Design and implement A*/beam search to solve a problem, and compare it against other search\nalgorithms in terms of the solution cost, number of nodes expanded, etc.\n9. Apply minimax search with alpha-beta pruning to prune search space in a two-player adversarial\ngame (e.g., connect four).\n10. Compare and contrast genetic algorithms with classic search techniques, explaining when it is most\nappropriate to use a genetic algorithm to learn a model versus other forms of optimization (e.g.,\ngradient descent).\n11. Compare and contrast various heuristic searches vis-a-vis applicability to a given problem.\n12. Model a logic or Sudoku puzzle as a constraint satisfaction problem, solve it with backtrack search,\nand determine how much arc consistency can reduce the search space."
  },
  {
    "title": "AI-KRR: Fundamental Knowledge Representation and Reasoning",
    "CS Core": "1. Types of representations\na. Symbolic, logical\ni. Creating a representation from a natural language problem statement\nb. Learned subsymbolic representations\nc. Graphical models (e.g., naive Bayes, Bayesian network)\n2. Review of probabilistic reasoning, Bayes theorem (See also: MSF-Probability)\n3. Bayesian reasoning\na. Bayesian inference",
    "KA Core": "4. Random variables and probability distributions\na. Axioms of probability\nb. Probabilistic inference\nc. Bayes’ Rule (derivation)\nd. Bayesian inference (more complex examples)\n5. Independence\n6. Conditional Independence\n7. Markov chains and Markov models\n8. Utility and decision making",
    "Illustrative Learning Outcomes": "1. Given a natural language problem statement, encode it as a symbolic or logical representation.\n2. Explain how we can make decisions under uncertainty, using concepts such as Bayes theorem and\nutility.\n3. Compute a probabilistic inference in a real-world problem using Bayes’ theorem to determine the\nprobability of a hypothesis given evidence.\n4. Apply Bayes’ rule to determine the probability of a hypothesis given evidence.\n5. Compute the probability of outcomes and test whether outcomes are independent.\n70"
  },
  {
    "title": "AI-ML: Machine Learning",
    "CS Core": "1. Definition and examples of a broad variety of machine learning tasks\na. Supervised learning\ni. Classification\nii. Regression\nb. Reinforcement learning\nc. Unsupervised learning\ni. Clustering\n2. Fundamental ideas:\na. No free lunch theorem: no one learner can solve all problems; representational design decisions\nhave consequences.\nb. Sources of error and undecidability in machine learning\n3. A simple statistical-based supervised learning such as linear regression or decision trees\na. Focus on how they work without going into mathematical or optimization details; enough to\nunderstand and use existing implementations correctly\n4. The overfitting problem/controlling solution complexity (regularization, pruning – intuition only)\na. The bias (underfitting) – variance (overfitting) tradeoff\n5. Working with Data\na. Data preprocessing\ni. Importance and pitfalls of preprocessing choices\nb. Handling missing values (imputing, flag-as-missing)\ni. Implications of imputing vs flag-as-missing\nc. Encoding categorical variables, encoding real-valued data\nd. Normalization/standardization\ne. Emphasis on real data, not textbook examples\n6. Representations\na. Hypothesis spaces and complexity\nb. Simple basis feature expansion, such as squaring univariate features\nc. Learned feature representations\n7. Machine learning evaluation\na. Separation of train, validation, and test sets\nb. Performance metrics for classifiers\nc. Estimation of test performance on held-out data\nd. Tuning the parameters of a machine learning model with a validation set\ne. Importance of understanding what a model is doing, where its pitfalls/shortcomings are, and the\nimplications of its decisions\n8. Basic neural networks\na. Fundamentals of understanding how neural networks work and their training process, without\ndetails of the calculations\nb. Basic introduction to generative neural networks (e.g., large language models)\n9. Ethics for Machine Learning (See also: SEP-Context)\na. Focus on real data, real scenarios, and case studies\nb. Dataset/algorithmic/evaluation bias and unintended consequences\n71",
    "KA Core": "10. Formulation of simple machine learning as an optimization problem, such as least squares linear\nregression or logistic regression\na. Objective function\nb. Gradient descent\nc. Regularization to avoid overfitting (mathematical formulation)\n11. Ensembles of models\na. Simple weighted majority combination\n12. Deep learning\na. Deep feed-forward networks (intuition only, no mathematics)\nb. Convolutional neural networks (intuition only, no mathematics)\nc. Visualization of learned feature representations from deep nets\nd. Other architectures (generative NN, recurrent NN, transformers, etc.)\n13. Performance evaluation\na. Other metrics for classification (e.g., error, precision, recall)\nb. Performance metrics for regressors\nc. Confusion matrix\nd. Cross-validation\ni. Parameter tuning (grid/random search, via cross-validation)\n14. Overview of reinforcement learning methods\n15. Two or more applications of machine learning algorithms\na. E.g., medicine and health, economics, vision, natural language, robotics, game play\n16. Ethics for Machine Learning\na. Continued focus on real data, real scenarios, and case studies (See also: SEP-Context)\nb. Privacy (See also: SEP-Privacy)\nc. Fairness (See also: SEP-Privacy)\nd. Intellectual property\ne. Explainability",
    "Non-core": "17. General statistical-based learning, parameter estimation (maximum likelihood)\n18. Supervised learning\na. Decision trees\nb. Nearest-neighbor classification and regression\nc. Learning simple neural networks / multi-layer perceptrons\nd. Linear regression\ne. Logistic regression\nf. Support vector machines (SVMs) and kernels\ng. Gaussian Processes\n19. Overfitting\na. The curse of dimensionality\nb. Regularization (mathematical computations, L and L regularization)\n2 1\n20. Experimental design\n72\na. Data preparation (e.g., standardization, representation, one-hot encoding)\nb. Hypothesis space\nc. Biases (e.g., algorithmic, search)\nd. Partitioning data: stratification, training set, validation set, test set\ne. Parameter tuning (grid/random search, via cross-validation)\nf. Performance evaluation\ni. Cross-validation\nii. Metric: error, precision, recall, confusion matrix\niii. Receiver operating characteristic (ROC) curve and area under ROC curve\n21. Bayesian learning (Cross-Reference AI/Reasoning Under Uncertainty)\na. Naive Bayes and its relationship to linear models\nb. Bayesian networks\nc. Prior/posterior\nd. Generative models\n22. Deep learning\na. Deep feed-forward networks\nb. Neural tangent kernel and understanding neural network training\nc. Convolutional neural networks\nd. Autoencoders\ne. Recurrent networks\nf. Representations and knowledge transfer\ng. Adversarial training and generative adversarial networks\nh. Attention mechanisms\n23. Representations\na. Manually crafted representations\nb. Basis expansion\nc. Learned representations (e.g., deep neural networks)\n24. Unsupervised learning and clustering\na. K-means\nb. Gaussian mixture models\nc. Expectation maximization (EM)\nd. Self-organizing maps\n25. Graph analysis (e.g., PageRank)\n26. Semi-supervised learning\n27. Graphical models (See also: AI-Probability)\n28. Ensembles\na. Weighted majority\nb. Boosting/bagging\nc. Random forest\nd. Gated ensemble\n29. Learning theory\na. General overview of learning theory / why learning works\nb. VC dimension\nc. Generalization bounds\n73\n30. Reinforcement learning\na. Exploration vs exploitation tradeoff\nb. Markov decision processes\nc. Value and policy iteration\nd. Policy gradient methods\ne. Deep reinforcement learning\nf. Learning from demonstration and inverse RL\n31. Explainable / interpretable machine learning\na. Understanding feature importance (e.g., LIME, Shapley values)\nb. Interpretable models and representations\n32. Recommender systems\n33. Hardware for machine learning\na. GPUs / TPUs\n34. Application of machine learning algorithms to:\na. Medicine and health\nb. Economics\nc. Education\nd. Vision\ne. Natural language\nf. Robotics\ng. Game play\nh. Data mining (Cross-reference DM/Data Analytics)\n35. Ethics for Machine Learning\na. Continued focus on real data, real scenarios, and case studies (See also: SEP-Context)\nb. In depth exploration of dataset/algorithmic/evaluation bias, data privacy, and fairness (See also:\nSEP-Privacy, SEP-Context)\nc. Trust / explainability",
    "Illustrative Learning Outcomes": "1. Describe the differences among the three main styles of learning (supervised, reinforcement, and\nunsupervised) and determine which is appropriate to a particular problem domain.\n2. Differentiate the terms of AI, machine learning, and deep learning.\n3. Frame an application as a classification problem, including the available input features and output\nto be predicted (e.g., identifying alphabetic characters from pixel grid input).\n4. Apply two or more simple statistical learning algorithms to a classification task and measure the\nclassifiers’ accuracy.\n5. Identify overfitting in the context of a problem and learning curves and describe solutions to\noverfitting.\n6. Explain how machine learning works as an optimization/search process.\n7. Implement a statistical learning algorithm and the corresponding optimization process to train the\nclassifier and obtain a prediction on new data.\n8. Describe the neural network training process and resulting learned representations.\n74\n9. Explain proper ML evaluation procedures, including the differences between training and testing\nperformance, and what can go wrong with the evaluation process leading to inaccurate reporting of\nML performance.\n10. Compare two machine learning algorithms on a dataset, implementing the data preprocessing and\nevaluation methodology (e.g., metrics and handling of train/test splits) from scratch.\n11. Visualize the training progress of a neural network through learning curves in a well-established\ntoolkit (e.g., TensorBoard) and visualize the learned features of the network.\n12. Compare and contrast several learning techniques (e.g., decision trees, logistic regression, naive\nBayes, neural networks, and belief networks), providing examples of when each strategy is\nsuperior.\n13. Evaluate the performance of a simple learning system on a real-world dataset.\n14. Characterize the state of the art in learning theory, including its achievements and shortcomings.\n15. Explain the problem of overfitting, along with techniques for detecting and managing the problem.\n16. Explain the triple tradeoff among the size of a hypothesis space, the size of the training set, and\nperformance accuracy.\n17. Given a real-world application of machine learning, describe ethical issues regarding the choices of\ndata, preprocessing steps, algorithm selection, and visualization/presentation of results."
  },
  {
    "title": "AI-SEP: Applications and Societal Impact",
    "CS Core": "1. At least one application of AI to a specific problem and field, such as medicine, health,\nsustainability, social media, economics, education, robotics, etc. (choose at least one for the CS\nCore).\na. Formulating and evaluating a specific application as an AI problem\ni. How to deal with underspecified or ill-posed problems\nb. Data availability/scarcity and cleanliness\ni. Basic data cleaning and preprocessing\nii. Data set bias\nc. Algorithmic bias\nd. Evaluation bias\ne. Assessment of societal implications of the application\n2. Deployed deep generative models\na. High-level overview of deep image generative models (e.g., as of 2023, DALL-E, Midjourney,\nStable Diffusion, etc.), their uses, and their shortcomings/pitfalls.\nb. High-level overview of large language models (e.g., as of 2023, ChatGPT, Bard, etc.), their\nuses, and their shortcomings/pitfalls.\n3. Overview of societal impact of AI\n75\na. Ethics (See also: SEP-Context)\nb. Fairness (See also: SEP-Privacy, SEP-DEIA)\nc. Trust/explainability (See also: SEP-Context)\nd. Privacy and usage of training data (See also: SEP-Privacy)\ne. Human autonomy and oversight/regulations/legal requirements (See also: SEP-Context)\nf. Sustainability (See also: SEP-Sustainability)",
    "KA Core": "4. One or more additional applications of AI to a broad set of problems and diverse fields, such as\nmedicine, health, sustainability, social media, economics, education, robotics, etc. (choose a\ndifferent area from that chosen for the CS Core).\na. Formulating and evaluating a specific application as an AI problem\ni. How to deal with underspecified or ill-posed problems\nb. Data availability/scarcity and cleanliness\ni. Basic data cleaning and preprocessing\nii. Data set bias\nc. Algorithmic bias\nd. Evaluation bias\ne. Assessment of societal implications of the application\n5. Additional depth on deployed deep generative models\na. Introduction to how deep image generative models work, (e.g., as of 2023, DALL-E, Midjourney,\nStable Diffusion) including discussion of attention\nb. Introduction to how large language models work, (e.g., as of 2023, ChatGPT, Bard) including\ndiscussion of attention\nc. Idea of foundational models, how to use them, and the benefits/issues with training them from\nbig data\n6. Analysis and discussion of the societal impact of AI\na. Ethics (See also: SEP-Context)\nb. Fairness (See also: SEP-Privacy, SEP-DEIA)\nc. Trust/explainability (See also: SEP-Context)\nd. Privacy and usage of training data (See also: SEP-Privacy)\ne. Human autonomy and oversight/regulations/legal requirements (See also: SEP-Context)\nf. Sustainability (See also: SEP-Sustainability)",
    "Illustrative Learning Outcomes": "1. Given a real-world application domain and problem, formulate an AI solution to it, identifying proper\ndata/input, preprocessing, representations, AI techniques, and evaluation metrics/methodology.\n2. Analyze the societal impact of one or more specific real-world AI applications, identifying issues\nregarding ethics, fairness, bias, trust, and explainability.\n3. Describe some of the failure modes of current deep generative models for language or images, and\nhow this could affect their use in an application."
  },
  {
    "title": "AI-LRR: Logical Representation and Reasoning",
    "Non-core": "76\n1. Review of propositional and predicate logic (See also: MSF-Discrete)\n2. Resolution and theorem proving (propositional logic only)\na. Forward chaining, backward chaining\n3. Knowledge representation issues\na. Description logics\nb. Ontology engineering\n4. Semantic web\n5. Non-monotonic reasoning (e.g., non-classical logics, default reasoning)\n6. Argumentation\n7. Reasoning about action and change (e.g., situation and event calculus)\n8. Temporal and spatial reasoning\n9. Logic programming\na. Prolog, Answer Set Programming\n10. Rule-based Expert Systems\n11. Semantic networks\n12. Model-based and Case-based reasoning",
    "Illustrative Learning Outcomes": "1. Translate a natural language (e.g., English) sentence into a predicate logic statement.\n2. Convert a logic statement into clausal form.\n3. Apply resolution to a set of logic statements to answer a query.\n4. Compare and contrast the most common models used for structured knowledge representation,\nhighlighting their strengths and weaknesses.\n5. Identify the components of non-monotonic reasoning and its usefulness as a representational\nmechanism for belief systems.\n6. Compare and contrast the basic techniques for representing uncertainty.\n7. Compare and contrast the basic techniques for qualitative representation.\n8. Apply situation and event calculus to problems of action and change.\n9. Explain the distinction between temporal and spatial reasoning, and how they interrelate.\n10. Explain the difference between rule-based, case-based, and model-based reasoning techniques.\n11. Define the concept of a planning system and how it differs from classical search techniques.\n12. Describe the differences between planning as search, operator-based planning, and propositional\nplanning, providing examples of domains where each is most applicable.\n13. Explain the distinction between monotonic and non-monotonic inference."
  },
  {
    "title": "AI-Probability: Probabilistic Representation and Reasoning",
    "Non-core": "1. Conditional Independence review\n2. Knowledge representations\na. Bayesian Networks\ni. Exact inference and its complexity\nii. Markov blankets and d-separation\niii. Randomized sampling (Monte Carlo) methods (e.g., Gibbs sampling)\nb. Markov Networks\n77\nc. Relational probability models\nd. Hidden Markov Models\n3. Decision Theory\na. Preferences and utility functions\nb. Maximizing expected utility\nc. Game theory",
    "Illustrative Learning Outcomes": "1. Compute the probability of a hypothesis given the evidence in a Bayesian network.\n2. Explain how conditional independence assertions allow for greater efficiency of probabilistic\nsystems.\n3. Identify examples of knowledge representations for reasoning under uncertainty.\n4. State the complexity of exact inference. Identify methods for approximate inference.\n5. Design and implement at least one knowledge representation for reasoning under uncertainty.\n6. Describe the complexities of temporal probabilistic reasoning.\n7. Design and implement an HMM as one example of a temporal probabilistic system.\n8. Describe the relationship between preferences and utility functions.\n9. Explain how utility functions and probabilistic reasoning can be combined to make rational\ndecisions."
  },
  {
    "title": "AI-Planning: Planning",
    "Non-core": "1. Review of propositional and first-order logic\n2. Planning operators and state representations\n3. Total order planning\n4. Partial-order planning\n5. Plan graphs and GraphPlan\n6. Hierarchical planning\n7. Planning languages and representations\na. PDDL\n8. Multi-agent planning\n9. MDP-based planning\n10. Interconnecting planning, execution, and dynamic replanning\na. Conditional planning\nb. Continuous planning\nc. Probabilistic planning",
    "Illustrative Learning Outcomes": "1. Construct the state representation, goal, and operators for a given planning problem.\n2. Encode a planning problem in PDDL and use a planner to solve it.\n3. Given a set of operators, initial state, and goal state, draw the partial-order planning graph and\ninclude ordering constraints to resolve all conflicts.\n4. Construct the complete planning graph for GraphPlan to solve a given problem.\n78"
  },
  {
    "title": "AI-Agents: Agents and Cognitive Systems",
    "Non-core": "1. Agent architectures (e.g., reactive, layered, cognitive)\n2. Agent theory (including mathematical formalisms)\n3. Rationality, Game Theory\na. Decision-theoretic agents\nb. Markov decision processes (MDP)\nc. Bandit algorithms\n4. Software agents, personal assistants, and information access\na. Collaborative agents\nb. Information-gathering agents\nc. Believable agents (synthetic characters, modeling emotions in agents)\n5. Learning agents\n6. Cognitive systems\na. Cognitive architectures (e.g., ACT-R, SOAR, ICARUS, FORR)\nb. Capabilities (e.g., perception, decision making, prediction, knowledge maintenance)\nc. Knowledge representation, organization, utilization, acquisition, and refinement\nd. Applications and evaluation of cognitive systems\n7. Multi-agent systems\na. Collaborating agents\nb. Agent teams\nc. Competitive agents (e.g., auctions, voting)\nd. Swarm systems and biologically inspired models\ne. Multi-agent learning\n8. Human-agent interaction (See also: HCI-User, HCI-Accessibility)\na. Communication methodologies (verbal and non-verbal)\nb. Practical issues\nc. Applications\ni. Trading agents, supply chain management\nii. Ethical issues of AI interactions with humans\niii. Regulation and legal requirements of AI systems for interacting with humans",
    "Illustrative Learning Outcomes": "1. Characterize and contrast the standard agent architectures.\n2. Describe the applications of agent theory to domains such as software agents, personal assistants,\nand believable agents, and discuss associated ethical implications.\n3. Describe the primary paradigms used by learning agents.\n4. Demonstrate using appropriate examples how multi-agent systems support agent interaction.\n5. Construct an intelligent agent using a well-established cognitive architecture (ACT-R, SOAR) for\nsolving a specific problem."
  },
  {
    "title": "AI-NLP: Natural Language Processing",
    "Non-core": "79\n1. Deterministic and stochastic grammars\n2. Parsing algorithms\na. CFGs and chart parsers (e.g., CYK)\nb. Probabilistic CFGs and weighted CYK\n3. Representing meaning/Semantics\na. Logic-based knowledge representations\nb. Semantic roles\nc. Temporal representations\nd. Beliefs, desires, and intentions\n4. Corpus-based methods\n5. N-grams and HMMs\n6. Smoothing and backoff\n7. Examples of use: POS tagging and morphology\n8. Information retrieval (See also: DM-Unstructured)\na. Vector space model\ni. TF & IDF\nb. Precision and recall\n9. Information extraction\n10. Language translation\n11. Text classification, categorization\na. Bag of words model\n12. Deep learning for NLP (See also: AI-ML)\na. RNNs\nb. Transformers\nc. Multi-modal embeddings (e.g., images + text)\nd. Generative language models",
    "Illustrative Learning Outcomes": "1. Define and contrast deterministic and stochastic grammars, providing examples to show the\nadequacy of each.\n2. Simulate, apply, or implement classic and stochastic algorithms for parsing natural language.\n3. Identify the challenges of representing meaning.\n4. List the advantages of using standard corpora. Identify examples of current corpora for a variety of\nNLP tasks.\n5. Identify techniques for information retrieval, language translation, and text classification.\n6. Implement a TF/IDF transform, use it to extract features from a corpus, and train an off-the-shelf\nmachine learning algorithm using those features to do text classification."
  },
  {
    "title": "AI-Robotics: Robotics",
    "Non-core": "1. Overview: problems and progress\na. State-of-the-art robot systems, including their sensors and an overview of their sensor\nprocessing\n80\nb. Robot control architectures, e.g., deliberative vs reactive control and Braitenberg vehicles\nc. World modeling and world models\nd. Inherent uncertainty in sensing and in control\n2. Sensors and effectors\na. Sensors: e.g., LIDAR, sonar, vision, depth, stereoscopic, event cameras, microphones, haptics,\nb. Effectors: e.g., wheels, arms, grippers\n3. Coordinate frames, translation, and rotation (2D and 3D)\n4. Configuration space and environmental maps\n5. Interpreting uncertain sensor data\n6. Localization and mapping\n7. Navigation and control\n8. Forward and inverse kinematics\n9. Motion path planning and trajectory optimization\n10. Manipulation and grasping\n11. Joint control and dynamics\n12. Vision-based control\n13. Multiple-robot coordination and collaboration\n14. Human-robot interaction (See also: HCI-User, HCI-Accessibility)\na. Shared workspaces\nb. Human-robot teaming and physical HRI\nc. Social assistive robots\nd. Motion/task/goal prediction\ne. Collaboration and communication (explicit vs implicit, verbal or symbolic vs non-verbal or visual)\nf. Trust\n15. Applications and Societal, Economic, and Ethical Issues\na. Societal, economic, right-to-work implications\nb. Ethical and privacy implications of robotic applications\nc. Liability in autonomous robotics\nd. Autonomous weapons and ethics\ne. Human oversight and control",
    "Illustrative Learning Outcomes": "(Note: Due to the expense of robot hardware, all of these could be done in simulation or\nwith low-cost educational robotic platforms.)\n1. List capabilities and limitations of today's state-of-the-art robot systems, including their sensors and\nthe crucial sensor processing that informs those systems.\n2. Integrate sensors, actuators, and software into a robot designed to undertake a specific task.\n3. Program a robot to accomplish simple tasks using deliberative, reactive, and/or hybrid control\narchitectures.\n4. Implement fundamental motion planning algorithms within a robot configuration space.\n5. Characterize the uncertainties associated with common robot sensors and actuators; articulate\nstrategies for mitigating these uncertainties.\n6. List the differences among robots' representations of their external environment, including their\nstrengths and shortcomings.\n81\n7. Compare and contrast at least three strategies for robot navigation within known and/or unknown\nenvironments, including their strengths and shortcomings.\n8. Describe at least one approach for coordinating the actions and sensing of several robots to\naccomplish a single task.\n9. Compare and contrast a multi-robot coordination and a human-robot collaboration approach and\nattribute their differences to differences between the problem settings.\n10. Analyze the societal, economic, and ethical issues of a real-world robotics application."
  },
  {
    "title": "AI-Vision: Perception and Computer Vision",
    "Non-core": "1. Computer vision\na. Image acquisition, representation, processing, and properties\nb. Shape representation, object recognition, and segmentation\nc. Motion analysis\nd. Generative models\n2. Audio and speech recognition\n3. Touch and proprioception\n4. Other modalities (e.g., olfaction)\n5. Modularity in recognition\n6. Approaches to pattern recognition (See also: AI-ML)\na. Classification algorithms and measures of classification quality\nb. Statistical techniques\nc. Deep learning techniques",
    "Illustrative Learning Outcomes": "1. Summarize the importance of image and object recognition in AI and indicate several significant\napplications of this technology.\n2. List at least three image-segmentation approaches, such as thresholding, edge-based and region-\nbased algorithms, along with their defining characteristics, strengths, and weaknesses.\n3. Implement 2d object recognition based on contour-based and/or region-based shape\nrepresentations.\n4. Distinguish the goals of sound-recognition, speech-recognition, and speaker-recognition and\nidentify how the raw audio signal will be handled differently in each of these cases.\n5. Provide at least two examples of a transformation of a data source from one sensory domain to\nanother, e.g., tactile data interpreted as single-band 2d images.\n6. Implement a feature-extraction algorithm on real data, e.g., an edge or corner detector for images\nor vectors of Fourier coefficients describing a short slice of audio signal.\n7. Implement an algorithm combining features into higher-level percepts, e.g., a contour or polygon\nfrom visual primitives or phoneme hypotheses from an audio signal.\n8. Implement a classification algorithm that segments input percepts into output categories and\nquantitatively evaluates the resulting classification.\n9. Evaluate the performance of the underlying feature-extraction, relative to at least one alternative\npossible approach (whether implemented or not) in its contribution to the classification task (8),\nabove.\n82\n10. Describe at least three classification approaches, their prerequisites for applicability, their strengths,\nand their shortcomings.\n11. Implement and evaluate a deep learning solution to problems in computer vision, such as object or\nscene recognition.\nProfessional Dispositions\n● Meticulousness: Since attention must be paid to details when implementing AI and machine\nlearning algorithms, students must be meticulous about detail.\n● Persistence: AI techniques often operate in partially observable environments and optimization\nprocesses may have cascading errors from multiple iterations. Getting AI techniques to work\npredictably takes trial and error, and repeated effort. These call for persistence on the part of the\nstudent.\n● Inventive: Applications of AI involve creative problem formulation and application of AI techniques,\nwhile balancing application requirements and societal and ethical issues.\n● Responsible: Applications of AI can have significant impacts on society, affecting both individuals\nand large populations. This calls for students to understand the implications of work in AI to society,\nand to make responsible choices for when and how to apply AI techniques.\nMathematics Requirements\nRequired:\n● Algebra\n● Precalculus\n● Discrete Math (See also: MSF-Discrete)\no sets, relations, functions, graphs\no predicate and first-order logic, logic-based proofs\n● Linear Algebra (See also: MSF-Linear)\no Matrix operations, matrix algebra\no Basis sets\n● Probability and Statistics (See also: MSF-Statistics)\no Basic probability theory, conditional probability, independence\no Bayes theorem and applications of Bayes theorem\no Expected value, basic descriptive statistics, distributions\no Basic summary statistics and significance testing\no All should be applied to real decision-making examples with real data, not “textbook”\nexamples.\nDesirable:\n● Calculus-based probability and statistics\n● Calculus: single-variable and partial derivatives\n● Other topics in probability and statistics\no Hypothesis testing, data resampling, experimental design techniques\n● Optimization\n● Linear algebra (all other topics)\n83\nCourse Packaging Suggestions\nArtificial Intelligence to include the following:\n● AI-Introduction (4 hours)\n● AI-Search (9 hours)\n● AI-KRR (4 hours)\n● AI-ML (12 hours)\n● AI-Probability (5 hours)\n● AI-SEP (4 hours –integrated throughout the course)\nPrerequisites:\n● SDF-Fundamentals\n● SDF-Data-Structures\n● SDF-Algorithms\n● MSF-Discrete\n● MSF-Probability\nCourse objective: A student who completes this course should understand the basic areas of AI and\nbe able to understand, develop, and apply techniques in each. They should be able to solve problems\nusing search techniques, basic Bayesian reasoning, and simple machine learning methods. They\nshould understand the various applications of AI and associated ethical and societal implications.\nMachine Learning to include the following:\n● AI-ML (32 hours)\n● AI-KRR (4 hours)\n● AI-NLP (4 hours – selected topics, e.g., TF-IDF, bag of words, and text classification)\n● AI-SEP (4 hours – should be integrated throughout the course)\nPrerequisites:\n● SDF-Fundamentals\n● SDF-Data-Structures\n● SDF-Algorithms\n● MSF-Discrete\n● MSF-Probability\n● MSF-Statistics\n● MSF-Linear (optional)\nCourse objective: A student who completes this course should be able to understand, develop, and\napply mechanisms for supervised, unsupervised, and reinforcement learning. They should be able to\nselect the proper machine learning algorithm for a problem, preprocess the data appropriately, apply\nproper evaluation techniques, and explain how to interpret the resulting models, including the model's\nshortcomings. They should be able to identify and compensate for biased data sets and other sources\nof error and be able to explain ethical and societal implications of their application of machine learning\nto practical problems.\nRobotics to include the following:\n● AI-Robotics (25 hours)\n84\n● SPD-Robot (4 hours – focusing on hardware, constraints/considerations, and software\narchitectures; other topics in SPD/Robot Platforms that overlap with AI/Robotics)\n● AI-Search (4 hours – selected topics well-integrated with robotics, e.g., A* and path search)\n● AI-ML (6 hours – selected topics well-integrated with robotics, e.g., neural networks for object\nrecognition)\n● AI-SEP (3 hours – integrated throughout the course; robotics is already a huge application, so\nthis really should focus on societal impact and specific robotic applications).\nPrerequisites:\n● SDF-Fundamentals\n● SDF-Data-Structures\n● SDF-Algorithms\n● MSF-Linear\nCourse objective: A student who completes this course should be able to understand and use robotic\ntechniques to perceive the world using sensors, localize the robot based on features and a map, and\nplan paths and navigate in the world in simple robot applications. They should understand and be able\nto apply simple computer vision, motion planning, and forward and inverse kinematics techniques.\nIntroduction to Data Science to include the following:\n● GIT-Visualization (6 hours) – types of visualization, libraries, foundations\n● GIT-SEP (2 hours) – ethically responsible visualization\n● DM-Core (2 hours) – Parallel and distributed processing (MapReduce, cloud frameworks, etc.)–\n● DM-Modeling (2 hours) – Graph representations, entity resolution\n● DM-Querying (4 hours) – SQL, query formation\n● DM-NoSQL (2 hours) – Graph DBs, data lakes, data consistency\n● DM-Security (2 hours) – privacy, personally identifying information and its protection\n● DM-Analytics (1 hour) – exploratory data techniques, data science lifecycle\n● DM-SEP (2 hours) – Data provenance\n● AI-ML (15 hours) – Data preprocessing, missing data imputation, supervised/semi-\nsupervised/unsupervised learning, text analysis, graph analysis and PageRank, experimental\nmethodology, evaluation, and ethics\n● AI-SEP (3 hours) – Applications specific to data science, interspersed throughout the course\n● MSF-Statistics (3 hours) – Statistical analysis, hypothesis testing, experimental design\nPrerequisites:\n● SDF-Fundamentals\nCourse objective: A student who completes this course should be able to formulate questions as data\nanalysis problems, understand and use statistical techniques to achieve that analysis from real data,\napply visualization techniques to convey the results, and analyze the ethical and societal implications of\ndata science applications. Students should also be able to understand and effectively use data\nmanagement techniques for preprocessing, storage, security, and retrieval of data in current systems.\nCommittee\nChair: Eric Eaton, University of Pennsylvania, Philadelphia, PA, USA\n85\nMembers:\n● Zachary Dodds, Harvey Mudd College, Claremont, CA, USA\n● Susan L. Epstein, Hunter College and The Graduate Center of The City University of New York,\nNew York, NY, USA\n● Laura Hiatt, US Naval Research Laboratory, Washington, DC, USA\n● Amruth N. Kumar, Ramapo College of New Jersey, Mahwah, NJ, USA\n● Peter Norvig, Google, Mountain View, CA, USA\n● Meinolf Sellmann, GE Research, Niskayuna, NY, USA\n● Reid Simmons, Carnegie Mellon University, Pittsburgh, PA, USA\nContributors:\n● Nate Derbinsky, Northeastern University, Boston, MA, USA\n● Eugene Freuder, Insight Centre for Data Analytics, University College Cork, Cork, Ireland\n● Ashok Goel, Georgia Institute of Technology, Atlanta, GA, USA\n● Claudia Schulz, Thomson Reuters, Zurich, Switzerland\n86\nAlgorithmic Foundations (AL)\nPreamble\nAlgorithms and data structures are fundamental to computer science, since every theoretical\ncomputation and applied program consists of algorithms that operate on data elements possessing\nsome underlying structure. Selecting appropriate computational solutions to real-world problems\nbenefits from understanding the theoretical and practical capabilities and limitations of available\nalgorithms and paradigms, including their impact on the environment and society. Moreover, this\nunderstanding provides insight into the intrinsic nature of computation, computational problems, and\ncomputational problem-solving as well as possible solution techniques independent of programming\nlanguage, programming paradigm, computer hardware, or other implementation aspects.\nThis knowledge area focuses on the nature of computation including the concepts and skills required to\ndesign and analyze algorithms for solving real-world computational problems. It complements the\nimplementation of algorithms and data structures found in the Software Development Foundations\n(SDF) knowledge area. As algorithms and data structures are essential in all advanced areas of\ncomputer science, this area provides the algorithmic foundations that every computer science graduate\nis expected to know. Exposure to the breadth of these foundational AL topics is designed to provide\nstudents with the basis for studying these topics in more depth, for studying additional computation and\nalgorithm topics, and for learning advanced algorithms across a variety of CS knowledge areas and\nCS+X disciplines.\nChanges since CS2013\nThis area has been renamed from Algorithms and Complexity to better reflect its foundational scope\nsince topics in this area focus on the practical and theoretical foundations of algorithms, complexity,\nand computability. These topics also provide the foundational prerequisites for advanced study in\ncomputer science. Additionally, topics focused on complexity and computability have been cleanly\nseparated into respective knowledge units. To reinforce the important impact of computation on society,\na Society, Ethics, and the Profession (AL-SEP) knowledge unit has been added with the expectation\nthat SEP implications be addressed in some manner during every lecture hour of focus in this AL\nknowledge area.\nThe increase of four CS Core hours acknowledges the importance of this foundational area in the CS\ncurriculum and returns it to the 2001 level (less than one course). Despite this increase, there is a\nsignificant overlap in hours with the Software Development Fundamentals (SDF) and Mathematical\nFoundations (MSF) areas. There is also a complementary nature of the units in this area since, for\nexample, while linear search of an array covers topics in AL-Foundational, it can be used to\nsimultaneously explain AL-Complexity O(n) and AL-Strategies Brute-Force topics.\nThe KA topics and hours primarily reflect topics studied in a stand-alone computational theory course\nand the availability of additional hours when such a course is included in the curriculum.\n87\nCore Hours\nKnowledge Unit CS Core KA Core\nFoundational Data Structures and Algorithms 11 6\nAlgorithmic Strategies 6\nComplexity Analysis 6 3\nComputational Models and Formal Languages 9 23\nSociety, Ethics, and the Profession Included in SEP hours\nTotal 32 32\nThe 11 CS Core hours in Foundational Data Structures and Algorithms are in addition to 9\nhours counted in SDF and 3 hours counted in MSF.\nKnowledge Units"
  },
  {
    "title": "AL-Foundational: Foundational Data Structures and Algorithms",
    "CS Core": "(See also: SDF-Data-Structures, SDF-Algorithms)\n1. Abstract Data Type (ADT) and operations on an ADT (See also: FPL-Types)\na. Dictionary operations (insert, delete, find)\n2. Arrays\na. Numeric vs non-numeric, character strings\nb. Single (vector) vs multidimensional (matrix)\n3. Records/Structs/Tuples and Objects (See also: FPL-OOP)\n4. Linked lists (for historical reasons)\na. Single vs Double and Linear vs Circular\n5. Stacks\n6. Queues and deques\na. Heap-based priority queue\n7. Hash tables/maps\na. Collision resolution and complexity (e.g., probing, chaining, rehash)\n8. Graphs (e.g., [un]directed, [a]cyclic, [un]connected, and [un]weighted)\n(See also: MSF-Discrete)\na. Graph representation: adjacency list vs matrix\n9. Trees (See also: MSF-Discrete)\na. Binary, n-ary, and search trees\nb. Balanced (e.g., AVL, Red-Black, Heap)\n10. Sets (See also: MSF-Discrete)\n88\n11. Search algorithms\na. O(n) complexity (e.g., linear/sequential array/list search)\nb. O(log n) complexity (e.g., binary search)\n2\nc. O(log n) complexity (e.g., uninformed depth/breadth-first tree search)\nb\n12. Sorting algorithms (e.g., stable, unstable)\na. O(n2) complexity (e.g., insertion, selection),\nb. O(n log n) complexity (e.g., quicksort, merge, timsort)\n13. Graph algorithms\na. Shortest path (e.g., Dijkstra’s, Floyd’s)\nb. Minimal spanning tree (e.g., Prim’s, Kruskal’s)",
    "KA Core": "14. Sorting algorithms\na. O(n log n) complexity heapsort\nb. Pseudo O(n) complexity (e.g., bucket, counting, radix)\n15. Graph algorithms\na. Transitive closure (e.g., Warshall’s)\nb. Topological sort\n16. Matching\na. Efficient string matching (e.g., Boyer-Moore, Knuth-Morris-Pratt)\nb. Longest common subsequence matching\nc. Regular expression matching",
    "Non-core": "17. Cryptography algorithms (e.g., SHA-256) (See also: SEC-Crypto)\n18. Parallel algorithms (See also: PDC-Algorithms, FPL-Parallel)\n19. Consensus algorithms (e.g., Blockchain) (See also: SEC-Crypto)\na. Proof of work vs proof of stake (See also: SEP-Sustainability)\n20. Quantum computing algorithms (See also: AL-Models, AR-Quantum)\na. Oracle-based (e.g., Deutsch-Jozsa, Bernstein-Vazirani, Simon)\nb. Superpolynomial speed-up via QFT (e.g., Shor’s)\nc. Polynomial speed-up via amplitude amplification (e.g., Grover’s)\n21. Fast-Fourier Transform (FFT) algorithm\n22. Differential evolution algorithm"
  },
  {
    "title": "AL-Strategies: Algorithmic Strategies",
    "CS Core": "1. Paradigms\na. Brute-Force (e.g., linear search, selection sort, traveling salesperson, knapsack)\nb. Decrease-and-Conquer\ni. By a Constant (e.g., insertion sort, topological sort),\nii. By a Constant Factor (e.g., binary search),\niii. By a Variable Size (e.g., Euclid’s)\nc. Divide-and-Conquer (e.g., binary search, quicksort, mergesort, Strassen’s)\nd. Greedy (e.g., Dijkstra’s, Kruskal’s, Knapsack)\ne. Transform-and-Conquer\ni. Instance simplification (e.g., find duplicates via list presort)\nii. Representation change (e.g., heapsort)\niii. Problem reduction (e.g., least-common-multiple, linear programming)\niv. Dynamic programming (e.g., Floyd’s, Warshall, Bellman-Ford)\nf. Space vs time tradeoffs (e.g., hashing)\n2. Handling exponential growth (e.g., heuristic A*, branch-and-bound, backtracking)\n3. Iteration vs recursion (e.g., factorial, tree search)",
    "KA Core": "4. Paradigms\na. Approximation algorithms\nb. Iterative improvement (e.g., Ford-Fulkerson, simplex)\nc. Randomized/Stochastic algorithms (e.g., max-cut, balls and bins)",
    "Non-core": "5. Quantum computing\n90"
  },
  {
    "title": "AL-Complexity: Complexity",
    "CS Core": "1. Complexity Analysis Framework\na. Best, average, and worst-case performance of an algorithm\nb. Empirical and relative (Order of Growth) measurements\nc. Input size and primitive operations\nd. Time and space efficiency\n2. Asymptotic complexity analysis (average and worst-case bounds)\na. Big-O, Big-Omega, and Big-Theta formal notations\nb. Foundational Complexity Classes and Representative Examples/Problems\ni. O(1) Constant (e.g., array access)\nii. O(log n) Logarithmic (e.g., binary search)\n2\niii. O(n) Linear (e.g., linear search)\niv. O(n log n) Log Linear (e.g., mergesort)\n2\nv. O(n2) Quadratic (e.g., selection sort)\nvi. O(nc) Polynomial (e.g., O(n3) Gaussian elimination)\nvii. O(2n) Exponential (e.g., Knapsack, Satisfiability (SAT),\nTraveling Sales-Person (TSP), all subsets)\nviii. O(n!) Factorial (e.g., Hamiltonian circuit, all permutations)\n3. Empirical measurements of performance\n4. Tractability and intractability\na. P, NP, and NP-Complete Complexity Classes\nb. NP-Complete Problems (e.g., SAT, Knapsack, TSP)\nc. Reductions\n5. Time and space tradeoffs in algorithms\n91",
    "KA Core": "6. Little-o, Little-Omega, and Little Theta notations\n7. Formal recursive analysis\n8. Amortized analysis\n9. Turing Machine-based models of complexity\na. Time complexity\ni. P, NP, NP-C, and EXP classes\nii. Cook-Levin theorem\nb. Space Complexity\ni. NSpace and PSpace\nii. Savitch’s theorem"
  },
  {
    "title": "AL-Models: Computational Models and Formal Languages",
    "CS Core": "1. Formal automata\na. Finite State\nb. Pushdown\nc. Linear Bounded\nd. Turing Machine\n2. Formal languages, grammars and Chomsky Hierarchy\n(See also: FPL-Translation, FPL-Syntax)\na. Regular (Type-3)\ni. Regular Expressions\nb. Context-Free (Type-2)\nc. Context-Sensitive (Type-1)\nd. Recursively Enumerable (Type-0)\n3. Relations among formal automata, languages, and grammars\n4. Decidability, (un)computability, and halting\n5. The Church-Turing thesis\n6. Algorithmic correctness\na. Invariants (e.g., in iteration, recursion, tree search)",
    "KA Core": "7. Deterministic and nondeterministic automata\n8. Pumping Lemma proofs\na. Proof of Finite State/Regular-Language limitation\nb. Pushdown Automata/Context-Free-Language limitation\n9. Decidability\na. Arithmetization and diagonalization\n10. Reducibility and reductions\n11. Time complexity based on Turing Machine\n12. Space complexity (e.g., Pspace, Savitch’s Theorem)\n13. Equivalent models of algorithmic computation\na. Turing Machines and Variations (e.g., multi-tape, non-deterministic)\nb. Lambda Calculus (See also: FPL-Functional)\nc. Mu-Recursive Functions",
    "Non-core": "14. Quantum computation (See also: AR-Quantum)\na. Postulates of quantum mechanics\ni. State space\n93\nii. State evolution\niii. State composition\niv. State measurement\nb. Column vector representations of qubits\nc. Matrix representations of quantum operations\nd. Simple quantum gates (e.g., XNOT, CNOT)"
  },
  {
    "title": "AL-SEP: Society, Ethics, and the Profession",
    "CS Core": "(See also: SEP-Context, SEP-Sustainability)\n1. Social, ethical, and secure algorithms\n2. Algorithmic fairness\n3. Anonymity (e.g., Differential Privacy)\n4. Accountability/Transparency\n5. Responsible algorithms\n6. Economic and other impacts of inefficient algorithms\n7. Sustainability",
    "KA Core": "8. Context aware computing"
  },
  {
    "title": "AR-Logic: Digital Logic and Digital Systems",
    "KA Core": "1. Combinational vs sequential logic/field programmable gate arrays (FPGAs) (See also: SF-\nOverview, SF-Foundations, SPD-Embedded)\na. Fundamental combinational\nb. Sequential logic building block\n2. Computer-aided design tools that process hardware and architectural representations\n3. High-level synthesis\na. Register transfer notation\nb. Hardware description language (e.g., Verilog/VHDL/Chisel)\n4. System-on-chip (SoC) design flow\n5. Physical constraints\na. Gate delays\nb. Fan-in and fan-out\nc. Energy/power\nd. Speed of light",
    "Illustrative Learning Outcomes": "102"
  },
  {
    "title": "AR-Representation: Machine-Level Data Representation",
    "CS Core": "1. Overview and history of computer architecture (See also: SPD-Game)\n2. Bits, bytes, and words\n3. Unsigned, signed and two’s complement representations\n4. Numeric data representation and number bases\na. Fixed-point\nb. Floating-point\n5. Representation of non-numeric data\n6. Representation of records, arrays and UTF data types (See also: AL-Foundational)"
  },
  {
    "title": "AR-Assembly: Assembly Level Machine Organization",
    "CS Core": "1. von Neumann machine architecture\n2. Control unit: instruction fetch, decode, and execution (See also: OS-Principles)\n3. Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs, OS-Scheduling,\nOS-Process)\n103\n4. Shared memory multiprocessors/multicore organization (See also: PDC-Programs, OS-Scheduling)",
    "KA Core": "5. Instruction set architecture (ISA) (e.g., x86, ARM and RISC-V)\na. Fixed vs variable-width instruction sets\nb. Instruction formats\nc. Data manipulation, control, I/O\nd. Addressing modes\ne. Machine language programming\nf. Assembly language programming\n6. Subroutine call and return mechanisms (See also: FPL-Translation, OS-Principles)\n7. I/O and interrupts (See also: OS-Principles)\n8. Heap, static, stack, and code segments (See also: FPL-Translation, OS-Process)"
  },
  {
    "title": "AR-Memory: Memory Hierarchy",
    "CS Core": "1. Memory hierarchy: the importance of temporal and spatial locality (See also: SF-Performance, OS-\nMemory)\n2. Main memory organization and operations (See also: OS-Memory)\n3. Persistent memory (e.g., SSD, standard disks)\n4. Latency, cycle time, bandwidth, and interleaving (See also: SF-Performance)\n5. Cache memories (See also: SF-Performance)\na. Address mapping\nb. Block size\n104\nc. Replacement and store policy\nd. Prefetching\n6. Multiprocessor cache coherence (See also: OS-Scheduling)\n7. Virtual memory (hardware support) (See also: OS-Memory)\n8. Fault handling and reliability (See also: SF-Reliability)\n9. Reliability (See also: SF-Reliability, OS-Faults)\na. Error coding\nb. Data compression\nc. Data integrity",
    "KA Core": "10. Processing In-Memory (PIM)"
  },
  {
    "title": "AR-IO: Interfacing and Communication",
    "CS Core": "1. I/O fundamentals (See also: OS-Devices, PDC-Communication)\na. Handshaking and buffering\nb. Programmed I/O\nc. Interrupt-driven I/O (See also: OS-Principles)\n2. Interrupt structures: vectored and prioritized, interrupt acknowledgment (See also: OS-Principles)\n3. I/O devices (e.g., mouse, keyboard, display, camera, sensors, actuators) (See also: GIT-\nFundamentals, GIT-Interaction, OS-Advanced-Files, PDC-Programs)\n4. External storage, physical organization, and drives\n5. Buses fundamentals (See also: OS-Devices)\na. Bus protocols\nb. Arbitration\nc. Direct-memory access (DMA)"
  },
  {
    "title": "AR-Organization: Functional Organization",
    "KA Core": "1. Implementation of simple datapaths, including instruction pipelining, hazard detection, and\nresolution (e.g., stalls, forwarding)\n2. Control unit\na. Hardwired implementation\nb. Microprogrammed realization\n3. Instruction pipelining (See also: SF-Overview)\n4. Introduction to instruction-level parallelism (ILP) (See also: PDC-Programs)"
  },
  {
    "title": "AR-Performance-Energy: Performance and Energy Efficiency",
    "KA Core": "1. Performance-energy evaluation (introduction): performance, power consumption, memory, and\ncommunication costs (See also: SF-Evaluation, OS-Scheduling, SPD-Game)\n2. Branch prediction, speculative execution, out-of-order execution, Tomasulo's algorithm\n3. Enhancements for vector processors and GPUs (See also: SPD-Game)\n4. Hardware support for multithreading (See also: OS-Concurrency, OS-Scheduling, PDC-Programs)\na. Race conditions\nb. Lock implementations\nc. Point-to-point synchronization\nd. Barrier implementation\n5. Scalability\n6. Alternative architectures including VLIW/EPIC, accelerators, and other special purpose processors\n7. Dynamic voltage and frequency scaling (DVFS)\n8. Dark Silicon"
  },
  {
    "title": "AR-Heterogeneity: Heterogeneous Architectures",
    "KA Core": "1. SIMD and MIMD architectures (e.g., General-Purpose GPUs, TPUs, and NPUs) (See also: PDC-\nPrograms, SPD-Embedded, GIT-Shading, SPD-Game)\n2. Heterogeneous memory systems (See also: OS-Process, PDC-Communication)\na. Shared memory versus distributed memory\nb. Volatile vs non-volatile memory\nc. Coherence protocols\n3. Domain-Specific Architectures (DSAs) (See also: HCI-Accountability, GIT-Shading)\na. Machine Learning Accelerator\nb. In-networking computing (See also: NC-Applications)\nc. Embedded systems for emerging applications\nd. Neuromorphic computing\ne. Edge computing devices\n4. Packaging and integration solutions such as 3DIC and chiplets\n5. Machine learning in architecture design\na. AI algorithms for workload analysis\nb. Optimization of architecture configurations for performance and power efficiency",
    "Illustrative Learning Outcomes": "KA Core\n1. Analyze a system diagram with alternative parallel architectures, e.g., SIMD and MIMD, and identify\nthe key differences.\n2. Discuss what memory-management issues are found in multiprocessors that are not present in\nuniprocessors and how these issues might be resolved.\n3. Indicate the differences between memory backplane, processor memory interconnect, and remote\nmemory via networks, their implications for access latency, and their impact on program\nperformance.\n4. Discuss how you would determine when to use a domain-specific accelerator instead of a general-\npurpose CPU.\n5. Enumerate key differences in architectural design principles between a vector and scalar-based\nprocessing unit.\n6. List the advantages and disadvantages of a PIM architecture."
  },
  {
    "title": "AR-Security: Secure Processor Architectures",
    "KA Core": "1. Discuss principles of secure hardware, exploring a framework for risk analysis and asset protection.\n2. Summarize how Physically Unclonable Functions (PUF) can be a unique device identifier in security\napplications.\n3. Distinguish a random number generator with dedicated hardware support from generators without\nhardware dedicated to generating entropy.\n4. List the advantages and disadvantages of memory protection at the ISA level.\n5. Describe key design issues of a trusted execution environment (TEE) to support virtual machines."
  },
  {
    "title": "AR-Quantum: Quantum Architectures",
    "KA Core": "1. Principles (See also: AL-Models: 8)\na. The wave-particle duality principle\nb. The uncertainty principle in the double-slit experiment\nc. What is a Qubit? Superposition, interference, and measurement. Photons as qubits\nd. Systems of two qubits, Entanglement, Bell states, The No-Signaling theorem\n2. Axioms of QM: superposition principle, measurement axiom, unitary evolution\n3. Single qubit gates for the circuit model of quantum computation: X, Z, H\n4. Two qubit gates and tensor products, working with matrices\n5. The No-Cloning Theorem. The Quantum Teleportation protocol\n6. Algorithms (See also: AL-Foundational)\na. Simple quantum algorithms: Bernstein-Vazirani, Simon’s algorithm\nb. Implementing Deutsch-Josza with Mach-Zehnder Interferometers\nc. Quantum factoring (Shor’s Algorithm)\nd. Quantum search (Grover’s Algorithm)\n7. Implementation aspects (See also: SPD-Interactive)\na. The physical implementation of qubits\nb. Classical control of a Quantum Processing Unit (QPU)\nc. Error mitigation and control, NISQ and beyond\n108\nd. Measurement approaches\n8. Emerging Applications\na. Post-quantum encryption\nb. The Quantum Internet\nc. Adiabatic quantum computation (AQC) and quantum annealing"
  },
  {
    "title": "AR-SEP: Sustainability Issues",
    "Non-core": "1. Environmental impacts of implementation decisions\na. Sustainability goals, resource consumption, and economic viability\nb. Carbon footprint, hardware electronic waste\nc. The energy footprint of data centers at various workloads (e.g., AI model training and use)\nd. Guidelines for sustainable design standards"
  },
  {
    "title": "DM-Data: The Role of Data and the Data Life Cycle",
    "CS Core": "1. The Data Life Cycle: Creation-Processing-Review/Reporting-Retention/Retrieval-Destruction (See\nalso: SEP-Context, SEP-Ethical-Analysis, SEP-Professional-Ethics, SEP-Privacy, SEP-Security,\nSEC-Foundations)"
  },
  {
    "title": "DM-Core: Core Database System Concepts",
    "CS Core": "1. Purpose and advantages of database systems\n2. Components of database systems\n115\n3. Design of core DBMS functions (e.g., query mechanisms, transaction management, buffer\nmanagement, access methods)\n4. Database architecture, data independence, and data abstraction\n5. Transaction management\n6. Normalization\n7. Approaches for managing large volumes of data (e.g., NoSQL database systems, use of\nMapReduce) (See also: PDC-Algorithms)\n8. How to support CRUD-only applications\n9. Distributed databases/cloud-based systems\n10. Structured, semi-structured, and unstructured data\n11. Use of a declarative query language",
    "KA Core": "12. Systems supporting structured and/or stream content"
  },
  {
    "title": "DM-Modeling: Data Modeling",
    "CS Core": "1. Data modeling (See also: SE-Requirements)\n2. Relational data model (See also: MSF-Discrete)",
    "KA Core": "3. Conceptual models (e.g., entity-relationship, UML diagrams)\n4. Semi-structured data models (expressed using DTD, XML, or JSON Schema, for example)",
    "Non-core": "5. Spreadsheet models\n6. Object-oriented models (See also: FPL-OOP)\na. GraphQL\n7. New features in SQL\n8. Specialized Data Modeling topics\na. Time series data (aggregation, join)\nb. Graph data (link traversal)\n116\nc. Techniques for avoiding inefficient raw data access (e.g., “avg daily price”): materialized views\nand special data structures (e.g., Hyperloglog, bitmap)\nd. Geo-Spatial data (e.g., GIS databases) (See also: SPD-Interactive)"
  },
  {
    "title": "DM-Relational: Relational Databases",
    "CS Core": "1. Entity and referential integrity: Candidate key, superkeys\n2. Relational database design",
    "KA Core": "3. Mapping conceptual schema to a relational schema\n4. Physical database design: file and storage structures (See also: OS-Files)\n5. Introduction to Functional dependency theory\n6. Normalization Theory\na. Decomposition of a schema; lossless-join, and dependency-preservation properties of a\ndecomposition\nb. Normal forms (BCNF)\nc. Denormalization (for efficiency)",
    "Non-core": "7. Functional dependency theory\na. Closure of a set of attributes\nb. Canonical Cover\n8. Normalization theory\na. Multi-valued dependency (4NF)\nb. Join dependency (PJNF, 5NF)\nc. Representation theory"
  },
  {
    "title": "DM-Querying: Query Construction",
    "CS Core": "1. SQL Query Formation\na. Interactive SQL execution\nb. Programmatic execution of an SQL query",
    "KA Core": "2. Relational Algebra\n3. SQL\na. Data definition including integrity and other constraint specifications\nb. Update sublanguage",
    "Non-core": "4. Relational Calculus\n5. QBE and 4th-generation environments\n6. Different ways to invoke non-procedural queries in conventional languages\n7. Introduction to other major query languages (e.g., XPATH, SPARQL)\n8. Stored procedures"
  },
  {
    "title": "DM-Processing: Query Processing",
    "KA Core": "1. Page structures\n2. Index structures\na. B+ trees (See also: AL-Foundational)\n118\nb. Hash indices: static and dynamic (See also: AL-Foundational, SEC-Foundations)\nc. Index creation in SQL\n3. File structures (See also: OS-Files)\na. Heap files\nb. Hash files\n4. Algorithms for query operators\na. External Sorting (See also: AL-Foundational)\nb. Selection\nc. Projection; with and without duplicate elimination\nd. Natural Joins: Nested loop, Sort-merge, Hash join\ne. Analysis of algorithm efficiency (See also: AL-Complexity)\n5. Query transformations\n6. Query optimization\na. Access paths\nb. Query plan construction\nc. Selectivity estimation\nd. Index-only plans\n7. Parallel Query Processing (e.g., parallel scan, parallel join, parallel aggregation) (See also: PDC-\nAlgorithms)\n8. Database tuning/performance\na. Index selection\nb. Impact of indices on query performance (See also: SF-Performance, SEP-Sustainability)\nc. Denormalization"
  },
  {
    "title": "DM-Internals: DBMS Internals",
    "KA Core": "1. DB Buffer Management (See also: OS-Memory, SF-Resource)\n119\n2. Transaction Management (See also: PDC-Coordination)\na. Isolation Levels\nb. ACID\nc. Serializability\nd. Distributed Transactions\n3. Concurrency Control: (See also: OS-Concurrency)\na. 2-Phase Locking\nb. Deadlocks handling strategies\nc. Quorum-based consistency models\n4. Recovery Manager\na. Relation with Buffer Manager",
    "Non-core": "5. Concurrency Control:\na. Optimistic concurrency control\nb. Timestamp concurrency control\n6. Recovery Manager\na. Write-Ahead logging\nb. ARIES recovery system (Analysis, REDO, UNDO)"
  },
  {
    "title": "DM-NoSQL: NoSQL Systems",
    "KA Core": "1. Why NoSQL? (e.g., Impedance mismatch between Application [CRUD] and RDBMS)\n2. Key-Value and Document data model",
    "Non-core": "3. Storage systems (e.g., Key-Value systems, Data Lakes)\n4. Distribution Models (Sharding and Replication) (See also: PDC-Communication)\n5. Graph Databases\n6. Consistency Models (Update and Read, Quorum consistency, CAP theorem) (See also: PDC-\nCommunication)\n7. Processing model (e.g., Map-Reduce, multi-stage map-reduce, incremental map-reduce) (See also:\nPDC-Communication)\n8. Case Studies: Cloud storage system (e.g., S3); Graph databases; “When not to use NoSQL” (See\nalso: SPD-Web)"
  },
  {
    "title": "DM-Security: Data Security and Privacy",
    "CS Core": "1. Differences between data security and data privacy (See also: SEC-Foundations)\n2. Protecting data and database systems from attacks, including injection attacks such as SQL\ninjection (See also: SEC-Foundations)\n3. Personally identifying information (PII) and its protection (See also: SEC-Foundations, SEP-\nSecurity, SEP-Privacy)\n4. Ethical considerations in ensuring the security and privacy of data (See also: SEC-SEP, SEP-\nEthical-Analysis, SEP-Security, SEP-Privacy)",
    "KA Core": "5. Need for, and different approaches to securing data at rest, in transit, and during processing (See\nalso: SEC-Foundations, SEC-Crypto)\n6. Database auditing and its role in digital forensics (See also: SEC-Forensics)\n7. Data inferencing and preventing attacks (See also: SEC-Crypto)\n8. Laws and regulations governing data security and data privacy (See also: SEP-Security, SEP-\nPrivacy, SEC-Foundations, SEC-Governance)",
    "Non-core": "9. Typical risk factors and prevention measures for ensuring data integrity (See also: SEC-\nGovernance)\n10. Ransomware and prevention of data loss and destruction (See also: SEC-Coding, SEC-Forensics)"
  },
  {
    "title": "DM-Analytics: Data Analytics",
    "KA Core": "1. Exploratory data techniques (motivation, representation, descriptive statistics, visualizations)\n2. Data science lifecycle: business understanding, data understanding, data preparation, modeling,\nevaluation, deployment, and user acceptance (See also: AI-ML)\n121\n3. Data mining and machine learning algorithms: e.g., classification, clustering, association, regression\n(See also: AI-ML)\n4. Data acquisition and governance (See also: SEC-Governance)\n5. Data security and privacy considerations (See also: SEP-Security, SEP-Privacy, SEC-Foundations)\n6. Data fairness and bias (See also: SEP-Security, AI-SEP)\n7. Data visualization techniques and their use in data analytics (See also: GIT-Visualization)\n8. Entity Resolution"
  },
  {
    "title": "DM-Distributed: Distributed Databases/Cloud Computing",
    "Non-core": "1. Distributed DBMS (See also: PDC-Communications)\na. Distributed data storage\nb. Distributed query processing\nc. Distributed transaction model\nd. Homogeneous and heterogeneous solutions\ne. Client-server distributed databases (See also: NC-Fundamentals)\n2. Parallel DBMS (See also: PDC-Algorithms)\na. Parallel DBMS architectures: shared memory, shared disk, shared nothing;\nb. Speedup and scale-up, e.g., use of the MapReduce processing model (See also: PDC-\nPrograms, SF-Foundations)\nc. Data replication and weak consistency models (See also: PDC-Coordination)"
  },
  {
    "title": "DM-Unstructured: Semi-structured and Unstructured Databases",
    "Non-core": "1. Vectorized unstructured data (text, video, audio, etc.) and vector storage\na. TF-IDF Vectorizer with ngram\nb. Word2Vec\nc. Array database or array data type handling\n2. Semi-structured databases (e.g., JSON)\na. Storage\ni. Encoding and compression of nested data types\nb. Indexing\ni. Btree, skip index, Bloom filter\n122\nii. Inverted index and bitmap compression\niii. Space filling curve indexing for semi-structured geo-data\nc. Query processing for OLTP and OLAP use cases\ni. Insert, Select, update/delete tradeoffs\nii. Case studies on Postgres/JSON, MongoDB, and Snowflake/JSON"
  },
  {
    "title": "DM-SEP: Society, Ethics, and the Profession",
    "CS Core": "1. Issues related to scale (See also: SEP-Economies)\n2. Data privacy overall (See also: SEP-Privacy, SEP-Ethical-Analysis)\na. Privacy compliance by design (See also: SEP-Privacy)\n3. Data anonymity (See also: SEP-Privacy)\n4. Data ownership/custodianship (See also: SEP-Professional-Ethics)\n5. Intended and unintended applications of stored data (See also: SEP-Professional-Ethics, SEC-\nFoundations)",
    "KA Core": "6. Reliability of data (See also: SEP-Security)\n7. Provenance, data lineage, and metadata management (See also: SEP-Professional-Ethics)\n8. Data security (See also: DM-Security, SEP-Security)"
  },
  {
    "title": "FPL-OOP: Object-Oriented Programming",
    "CS Core": "1. Imperative programming as a subset of object-oriented programming.\n2. Object-oriented design:\na. Decomposition into objects carrying state and having behavior.\nb. Class-hierarchy design for modeling.\n3. Definition of classes: fields, methods, and constructors. (See also: SDF-Fundamentals)\n4. Subclasses, inheritance (including multiple inheritance), and method overriding.\n5. Dynamic dispatch: definition of method-call.\n6. Exception handling. (See also: SDF-Fundamentals, PDC-Coordination, SE-Construction)\n7. Object-oriented idioms for encapsulation:\na. Privacy, data hiding, and visibility of class members.\nb. Interfaces revealing only method signatures.\nc. Abstract base classes, traits and mixins.\n130\n8. Dynamic vs static properties.\n9. Composition vs inheritance.\n10. Subtyping:\na. Subtype polymorphism; implicit upcasts in typed languages.\nb. Notion of behavioral replacement: subtypes acting like supertype.\nc. Relationship between subtyping and inheritance.",
    "KA Core": "11. Collection classes, iterators, and other common library components.\n12. Metaprogramming and reflection."
  },
  {
    "title": "FPL-Functional: Functional Programming",
    "CS Core": "1. Lambda expressions and evaluation: (See also: AL-Models, FPL-Formalism)\na. Variable binding and scope rules. (See also: SDF-Fundamentals)\nb. Parameter-passing. (See also: SDF-Fundamentals)\nc. Nested lambda expressions and reduction order.\n2. Effect-free programming:\na. Function calls have no side effects, facilitating compositional reasoning.\nb. Immutable variables and data copying vs reduction.\nc. Use of recursion vs loops vs pipelining (map/reduce).\n131\n3. Processing structured data (e.g., trees) via functions with cases for each data variant:\na. Functions defined over compound data in terms of functions applied to the constituent pieces.\nb. Persistent data structures.\n4. Using higher-order functions (taking, returning, and storing functions).",
    "KA Core": "5. Metaprogramming and reflection.\n6. Function closures (functions using variables in the enclosing lexical environment).\na. Basic meaning and definition – creating closures at run-time by capturing the environment.\nb. Canonical idioms: call-backs, arguments to iterators, reusable code via function arguments.\nc. Using a closure to encapsulate data in its environment.\nd. Delayed versus eager evaluation.",
    "Non-core": "7. Graph reduction machine and call-by-need.\n8. Implementing delayed evaluation.\n9. Integration with logic programming paradigm using concepts such as equational logic, narrowing,\nresiduation and semantic unification. (See also: FPL-Logic)\n10. Integration with other programming paradigms such as imperative and object-oriented.\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Logic: Logic Programming",
    "KA Core": "1. Universal vs existential quantifiers. (See also: AI-LRR, MSF-Discrete)\n2. First order predicate logic vs higher order logic. (See also: AI-LRR, MSF-Discrete)\n3. Expressing complex relations using logical connectives and simpler relations.\n4. Definitions of Horn clause, facts, goals and subgoals.\n5. Unification and unification algorithm; unification vs assertion vs expression evaluation.\n6. Mixing relations with functions. (See also: MSF-Discrete)\n7. Cuts, backtracking, and non-determinism.\n8. Closed-world vs open-world assumptions.",
    "Non-core": "9. Memory overhead of variable copying in handling iterative programs.\n10. Programming constructs to store partial computation and pruning search trees.\n11. Mixing functional programming and logic programming using concepts such as equational logic,\nnarrowing, residuation, and semantic unification. (See also: FPL-Functional)\n12. Higher-order, constraint, and inductive logic programming. (See also: AI-LRR)\n13. Integration with other programming paradigms such as object-oriented programming.\n14. Advance programming constructs such as difference-lists, creating user defined data structures, set\nof, etc.\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Scripting: Shell Scripting",
    "CS Core": "133\n1. Error/exception handling\n2. Piping (See also: AR-Organization, SF-Overview, OS-Process)\n3. System commands (See also: SF-Overview)\na. Interface with operating systems (See also: SF-Overview, OS-Principles)\n4. Environment variables (See also: SF-Overview)\n5. File abstraction and operators (See also: SDF-Fundamentals, OS-Files, SF-Resource)\n6. Data structures, such as arrays and lists. (See also: AL-Foundational, SDF-Fundamentals, SDF-\nData-Structures)\n7. Regular expressions (See also: AL-Models)\n8. Programs and processes (See also: OS-Process)\n9. Workflow\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Event-Driven: Event-Driven and Reactive Programming",
    "CS Core": "1. Procedural programming vs reactive programming: advantages of reactive programming in\ncapturing events.\n2. Components of reactive programming: event-source, event signals, listeners and dispatchers, event\nobjects, adapters, event-handlers. (See also: GIT-Interaction, SPD-Web, SPD-Mobile, SPD-Robot,\nSPD-Embedded, SPD-Game, SPD-Interactive)\n3. Stateless and state-transition models of event-based programming.\n4. Canonical uses such as GUIs, mobile devices, robots, servers. (See also: GIT-Interaction, GIT-\nImage, SPD-Web, SPD-Mobile, SPD-Robot, SPD-Embedded, SPD-Game, SPD-Interactive)",
    "KA Core": "5. Using a reactive framework:\na. Defining event handlers/listeners\nb. Parameterization of event senders and event arguments\nc. Externally generated events and program-generated events\n6. Separation of model, view, and controller\n7. Event-driven and reactive programs as state-transition systems\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Parallel: Parallel and Distributed Computing",
    "CS Core": "1. Safety and liveness (See also: PDC-Evaluation)\na. Race conditions (See also: OS-Concurrency)\nb. Dependencies/preconditions\nc. Fault models (See also: OS-Faults)\nd. Termination (See also: PDC-Coordination)\n2. Programming models (See also: PDC-Programs)\nOne or more of the following:\na. Actor models\nb. Procedural and reactive models\nc. Synchronous/asynchronous programming models\nd. Data parallelism\n3. Properties (See also: PDC-Programs, PDC-Coordination)\na. Order-based properties\ni. Commutativity\nii. Independence\nb. Consistency-based properties\ni. Atomicity\nii. Consensus\n4. Execution control: (See also: PDC-Coordination, SF-Foundations)\na. Async await\nb. Promises\nc. Threads\n5. Communication and coordination (See also: OS-Process, PDC-Communication, PDC-Coordination)\na. Mutexes\nb. Message-passing\nc. Shared memory\nd. Cobegin-coend\ne. Monitors\nf. Channels\ng. Threads\nh. Guards",
    "KA Core": "6. Futures\n7. Language support for data parallelism such as forall, loop unrolling, map/reduce\n8. Effect of memory-consistency models on language semantics and correct code generation\n9. Representational State Transfer Application Programming Interfaces (REST APIs)\n10. Technologies and approaches: cloud computing, high performance computing, quantum computing,\nubiquitous computing\n11. Overheads of message-passing\n135\n12. Granularity of program for efficient exploitation of concurrency\n13. Concurrency and other programming paradigms (e.g., functional)\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Aspect: Aspect-Oriented Programming",
    "Non-core": "1. Aspects\n2. Join points\n3. Advice\na. Before\nb. After (as finally, returning or throwing)\nc. Around\n4. Point cuts\na. Designators\n5. Weaving – static and dynamic\n6. Alternatives including annotations and IDEs"
  },
  {
    "title": "FPL-Types: Type Systems",
    "CS Core": "1. A type as a set of values together with a set of operations\na. Primitive types (e.g., numbers, Booleans) (See also: SDF-Fundamentals)\nb. Compound types built from other types (e.g., records/structs, unions, arrays, lists, functions,\nreferences using set operations) (See also: SDF-Data-Structures)\n2. Association of types to variables, arguments, results, and fields\n3. Type safety as an aspect of program correctness (See also: FPL-Formalism)\n4. Type safety and errors caused by using values inconsistently given their intended types\n5. Goals and limitations of static and dynamic typing: detecting and eliminating errors as early as\npossible.\n136\n6. Generic types (parametric polymorphism)\na. Definition and advantages of polymorphism: parametric, subtyping, overloading, and coercion\nb. Comparison of monomorphic and polymorphic types\nc. Comparison with ad-hoc polymorphism (overloading) and subtype polymorphism\nd. Generic parameters and typing\ne. Use of generic libraries such as collections\nf. Comparison with ad hoc polymorphism (overloading) and subtype polymorphism\ng. Prescriptive vs descriptive polymorphism\nh. Implementation models of polymorphic types\ni. Subtyping",
    "KA Core": "7. Type equivalence: structural vs name equivalence\n8. Complementary benefits of static and dynamic typing:\na. Errors early vs errors late/avoided\nb. Enforce invariants during code development and code maintenance vs postpone typing\ndecisions while prototyping and conveniently allow flexible coding patterns such as\nheterogeneous collections.\nc. Typing rules for function, product, and sum types\nd. Avoiding misuse of code vs allowing more code reuse\ne. Detect incomplete programs vs allow incomplete programs to run\nf. Relationship to static analysis\ng. Decidability",
    "Non-core": "9. Compositional type constructors, such as product types (for aggregates), sum types (for unions),\nfunction types, quantified types, and recursive types\n10. Type checking\n11. Subtyping: (See also: FPL-OOP)\na. Subtype polymorphism; implicit upcasts in typed languages\nb. Notion of behavioral replacement: subtypes acting like supertype\nc. Relationship between subtyping and inheritance\n12. Type safety as preservation plus progress\n13. Type inference\n14. Static overloading\n15. Propositions as types (implication as a function, conjunction as a product, disjunction as a sum)\n(See also: FPL-Formalism)\n16. Dependent types (universal quantification as dependent function, existential quantification as\ndependent product). (See also: FPL-Formalism)\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Systems: Systems Execution and Memory Model",
    "CS Core": "1. Data structures for translation, execution, translation, and code mobility such as stack, heap,\naliasing (sharing using pointers), indexed sequence and string\n2. Direct, indirect, and indexed access to memory location\n3. Run-time representation of data abstractions such as variables, arrays, vectors, records, pointer-\nbased data elements such as linked-lists and trees, and objects\n4. Abstract low-level machine with simple instruction, stack, and heap to explain translation and\nexecution\n5. Run-time layout of memory: activation record (with various pointers), static data, call-stack, heap\n(See also: AR-Memory, OS-Memory)\na. Translating selection and iterative constructs to control-flow diagrams\nb. Translating control-flow diagrams to low level abstract code\nc. Implementing loops, recursion, and tail calls\n138\nd. Translating function/procedure calls and return from calls, including different parameter-passing\nmechanisms using an abstract machine\n6. Memory management: (See also: AR-Memory, OS-Memory)\na. Low level allocation and accessing of high-level data structures such as basic data types, n-\ndimensional array, vector, record, and objects\nb. Return from procedure as automatic deallocation mechanism for local data elements in the\nstack\nc. Manual memory management: allocating, de-allocating, and reusing heap memory\nd. Automated memory management: garbage collection as an automated technique using the\nnotion of reachability\n7. Green computing. (See also: SEP-Sustainability)\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Translation: Language Translation and Execution",
    "CS Core": "1. Execution models for JIT (Just-In-Time), compiler, interpreter\n2. Use of intermediate code, e.g., bytecode\n3. Limitations and benefits of JIT, compiler, and interpreter\n4. Cross compilers/transpilers\n5. BNF and extended BNF representation of context-free grammar\n6. Parse tree using a simple sentence such as arithmetic expression or if-then-else statement\n7. Execution as native code or within a virtual machine\n8. Language translation pipeline: syntax analysis, parsing, optional type-checking, translation/code\ngeneration and optimization, linking, loading, execution",
    "KA Core": "9. Run-time representation of core language constructs such as objects (method tables) and functions\nthat can be passed as parameters to and returned from functions (closures)\n10. Secure compiler development (See also: SEC-Foundations, SEC-Coding)\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Abstraction: Program Abstraction and Representation",
    "KA Core": "1. BNF and regular expressions\n2. Programs that take (other) programs as input such as interpreters, compilers, type-checkers,\ndocumentation generators\n3. Components of a language:\na. Definitions of alphabets, delimiters, sentences, syntax, and semantics\nb. Syntax vs semantics\n4. Program as a set of non-ambiguous meaningful sentences\n5. Basic programming abstractions: constants, variables, declarations (including nested declarations),\ncommand, expression, assignment, selection, definite and indefinite iteration, iterators, function,\nprocedure, modules, exception handling (See also: SDF-Fundamentals)\n6. Mutable vs immutable variables: advantages and disadvantages of reusing existing memory\nlocation vs advantages of copying and keeping old values; storing partial computation vs\nrecomputation\n7. Types of variables: static, local, nonlocal, global; need and issues with nonlocal and global\nvariables.\n8. Scope rules: static vs dynamic; visibility of variables; side-effects.\n9. Side-effects induced by nonlocal variables, global variables and aliased variables.",
    "Non-core": "10. L-values and R-values: mapping mutable variable-name to L-values; mapping immutable variable-\nnames to R-values\n11. Environment vs store and their properties\n12. Data and control abstraction\n13. Mechanisms for information exchange between program units such as procedures, functions, and\nmodules: nonlocal variables, global variables, parameter-passing, import-export between modules\n14. Data structures to represent code for execution, translation, or transmission.\n15. Low level instruction representation such as virtual machine instructions, assembly language, and\nbinary representation (See also: AR-Representation, AR-Assembly)\n16. Lambda calculus, variable binding, and variable renaming. (See also: AL-Models, FPL-Formalism)\n17. Types of semantics: operational, axiomatic, denotational, behavioral; define and use abstract\nsyntax trees; contrast with concrete syntax.\n140\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Syntax: Syntax Analysis",
    "Non-core": "1. Regular grammars vs context-free grammars (See also: AL-Models)\n2. Scanning and parsing based on language specifications\n3. Lexical analysis using regular expressions\n4. Tokens and their use\n5. Parsing strategies including top-down (e.g., recursive descent, or LL) and bottom-up (e.g., LR or\nGLR) techniques\na. Lookahead tables and their application to parsing\n6. Language theory:\na. Chomsky hierarchy (See also: AL-Models)\nb. Left-most/right-most derivation and ambiguity\nc. Grammar transformation\n7. Parser error recovery mechanisms\n8. Generating scanners and parsers from declarative specifications\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Semantics: Compiler Semantic Analysis",
    "Non-core": "1. Abstract syntax trees; contrast with concrete syntax\n2. Defining, traversing, and modifying high-level program representations\n3. Scope and binding resolution\n4. Static semantics\na. Type checking.\nb. Define before use\n141\nc. Annotation and extended static checking frameworks.\n5. L-values/R-values (See also: SDF-Fundamentals)\n6. Call semantics\n7. Types of parameter-passing with simple illustrations and comparison: call by value, call by\nreference, call by value-result, call by name, call by need and their variations\n8. Declarative specifications such as attribute grammars and their applications in handling limited\ncontext-base grammar\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Analysis: Program Analysis and Analyzers",
    "Non-core": "4. Relevant program representations, such as basic blocks, control-flow graphs, def-use chains, and\nstatic single assignment\n5. Undecidability and consequences for program analysis\n6. Flow-insensitive analysis, such as type-checking and scalable pointer and alias analysis\n7. Flow-sensitive analysis, such as forward and backward dataflow analyses\n8. Path-sensitive analysis, such as software model checking and software verification\n9. Tools and frameworks for implementing analyzers\n10. Role of static analysis in program optimization and data dependency analysis during exploitation of\nconcurrency (See also: FPL-Code)\n11. Role of program analysis in (partial) verification and bug-finding (See also: FPL-Code)\n12. Parallelization:\na. Analysis for auto-parallelization\nb. Analysis for detecting concurrency bugs\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Code: Code Generation",
    "Non-core": "1. Instruction sets (See also: AR-Assembly)\n2. Control flow\n142\n3. Memory management (See also: AR-Memory, OS-Memory)\n4. Procedure calls and method dispatching\n5. Separate compilation; linking\n6. Instruction selection\n7. Instruction scheduling (e.g., pipelining)\n8. Register allocation\n9. Code optimization as a form of program analysis (See also: FPL-Analysis)\n10. Program generation through generative AI\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Run-Time: Run-time Behavior and Systems",
    "Non-core": "1. Process models using stacks and heaps to allocate and deallocate activation records and\nrecovering environments using frame pointers and return addresses during a procedure call\nincluding parameter-passing examples\n2. Schematics of code lookup using hash tables for methods in implementations of object-oriented\nprograms\n3. Data layout for objects and activation records\n4. Object allocation in heap\n5. Implementing virtual entities and virtual methods; virtual method tables and their application\n6. Run-time behavior of object-oriented programs\n7. Compare and contrast allocation of memory during information exchange using parameter-passing\nand non-local variables (using chain of static links).\n8. Dynamic memory management approaches and techniques: malloc/free, garbage collection (mark-\nsweep, copying, reference counting), regions (also known as arenas or zones)\n9. Just-in-time compilation and dynamic recompilation\n10. Interface to operating system (e.g., for program initialization)\n11. Interoperability between programming languages including parameter-passing mechanisms and\ndata representation (See also: AR-Representation)\na. Big endian, little endian\nb. Data layout of composite data types such as arrays\n12. Other common features of virtual machines, such as class loading, threads, and security checking\n13. Sandboxing\n143\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Constructs: Advanced Programming Constructs",
    "Non-core": "1. Encapsulation mechanisms\n2. Delayed evaluation and infinite streams\n3. Compare and contrast delayed evaluation vs eager evaluation\n4. Unification vs assertion vs expression evaluation\n5. Control abstractions: exception handling, continuations, monads.\n6. Object-oriented abstractions: multiple inheritance, mixins, traits, multimethods\n7. Metaprogramming: macros, generative programming, model-based development\n8. String manipulation via pattern-matching (regular expressions)\n9. Dynamic code evaluation (\"eval\")\n10. Language support for checking assertions, invariants, and pre/post-conditions\n11. Domain specific languages, such as database languages, data science languages, embedded\ncomputing languages, synchronous languages, hardware interface languages\n12. Massive parallel high performance computing models and languages\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Pragmatics: Language Pragmatics",
    "Non-core": "1. Effect of technology needs and software requirements on programming language development and\nevolution\n2. Problem domains and programming paradigm\n3. Criteria for good programming language design\n144\na. Principles of language design such as orthogonality\nb. Defining control and iteration constructs\nc. Modularization of large software\n4. Evaluation order, precedence, and associativity\n5. Eager vs delayed evaluation\n6. Defining control and iteration constructs\n7. External calls and system libraries\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Formalism: Formal Semantics",
    "Non-core": "1. Syntax vs semantics\n2. Approaches to semantics: axiomatic, operational, denotational, type-based\n3. Axiomatic semantics of abstract constructs such as assignment, selection, iteration using pre-\ncondition, post-conditions, and loop invariant\n4. Operational semantics analysis of abstract constructs and sequence of such as assignment,\nexpression evaluation, selection, iteration using environment and store\na. Symbolic execution\nb. Constraint checkers\n5. Denotational semantics\na. Lambda Calculus. (See also: AL-Models, FPL-Functional)\n6. Proofs by induction over language semantics\n7. Formal definitions and proofs for type systems (See also: FPL-Types)\na. Propositions as types (implication as a function, conjunction as a product, disjunction as a sum)\nb. Dependent types (universal quantification as dependent function, existential quantification as\ndependent product)\nc. Parametricity\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Methodologies: Formal Development Methodologies",
    "Non-core": "1. Use formal modeling techniques to develop and validate architectures.\n2. Use proof assisted programming languages to develop fully specified and verified software artifacts.\n3. Use verifier and specification support in programming languages to formally validate system\nproperties.\n4. Integrate symbolic validation tooling into a programming workflow.\n5. Discuss when and how formal methods can be effectively used in the development process."
  },
  {
    "title": "FPL-Design: Design Principles of Programming Languages",
    "Non-core": "1. Language design principles\na. Simplicity\nb. Security (See also: SEC-Coding)\nc. Fast translation\nd. Efficient object code\ne. Orthogonality\nf. Readability\ng. Completeness\nh. Implementation strategies\n2. Designing a language to fit a specific domain or problem\n3. Interoperability between programming languages\n4. Language portability\n5. Formal description of a programming language\n6. Green computing principles (See also: SEP-Sustainability)\n146"
  },
  {
    "title": "FPL-SEP: Society, Ethics, and the Profession",
    "Non-core": "1. Impact of English-centric programming languages\n2. Enhancing accessibility and inclusivity for people with disabilities – Supporting assistive\ntechnologies\n3. Human factors related to programming languages and usability\na. Impact of syntax on accessibility\nb. Supporting cultural differences (e.g., currency, decimals, dates)\nc. Neurodiversity\n4. Etymology of terms such as “class,” “master,” and “slave” in programming languages\n5. Increasing accessibility by supporting multiple languages within applications (UTF)\nIllustrative learning outcomes:"
  },
  {
    "title": "GIT-Fundamentals: Fundamental Concepts",
    "CS Core": "1. Uses of computer graphics and interactive techniques and their potential risks and abuses.\na. Entertainment, business, and scientific applications: e.g., visual effects, generative imagery,\ncomputer vision, machine learning, user interfaces, video editing, games and game engines,\ncomputer-aided design and manufacturing, data visualization, and virtual/augmented/mixed\nreality\nb. Intellectual property, deep fakes, facial recognition, privacy (See also: SEP-DEIA, SEP-Privacy,\nSEP-IP, SEP-Professional-Ethics)\n2. Graphic output\na. Displays (e.g., LCD)\nb. Printers\nc. Analog film\nd. Concepts\ni. Resolution (e.g., pixels, dots)\nii. Aspect ratio\niii. Frame rate\n3. Human vision system\na. Tristimulus reception (RGB)\nb. Eye as a camera (projection)\nc. Persistence of vision (frame rate, motion blur)\nd. Contrast (detection, Mach banding, dithering/aliasing)\ne. Non-linear response (dynamic range, tone mapping)\nf. Binocular vision (stereo)\ng. Accessibility (color deficiency, strobing, monocular vision, etc.) (See also: SEP-DEIA, HCI-User)\n4. Standard image formats\na. Raster\ni. Lossless (e.g., TIF)\nii. Lossy (e.g., JPG, GIF, etc.)\nb. Vector (e.g., SVG, Adobe Illustrator)\n5. Digitization of analog data\na. Rasterization\nb. Resolution\nc. Sampling and quantization\n6. Color models: additive (RGB), subtractive (CMYK), and color perception (HSV)\n7. Tradeoffs between storing image data and re-computing image data\n8. Spatialization: coordinate systems, absolute and relative positioning\n9. Animation as a sequence of still images\n155",
    "KA Core": "10. Applied interactive graphics (e.g., processing, python)\n11. Display characteristics (protocols and ports)"
  },
  {
    "title": "GIT-Visualization: Visualization",
    "KA Core": "1. Scientific Data Visualization and Information Visualization\n2. Visualization techniques\na. Statistical visualization (e.g., scatterplots, bar graphs, histograms, line graphs, pie charts, trees,\nand graphs)\nb. Text visualization\nc. Geospatial visualization\nd. 2D/3D scalar fields\ne. Vector fields\nf. Direct volume rendering\n3. Visualization pipeline\na. Structuring data\nb. Mapping data to visual representations (e.g., scales, grammar of graphics)\nc. View transformations (e.g., pan, zoom, filter, select)\n156\n4. Common data formats (e.g., HDF, netCDF, geotiff, GeoJSON, shape files, raw binary, JSON, CSV,\nplain text)\n5. High-dimensional data handling techniques\na. Statistical (e.g., averaging, clustering, filtering)\nb. Perceptual (e.g., multi-dimensional vis, parallel coordinates, trellis plots)\n6. Perceptual and cognitive foundations that drive visual abstractions.\na. Human optical system\nb. Color theory\nc. Gestalt theories\n7. Design and evaluation of visualizations\na. Purpose (e.g., analysis, communication, aesthetics)\nb. Accessibility\nc. Appropriateness of encodings\nd. Misleading visualizations"
  },
  {
    "title": "GIT-Rendering: Applied Rendering and Techniques",
    "KA Core": "(See also: SPD-Game)\n1. Object and scene modeling\na. Object representations: polygonal, parametric, etc.\nb. Modeling transformations: affine and coordinate-system transformations\nc. Scene representations: scene graphs\n2. Camera and projection modeling\na. Pinhole cameras, similar triangles, and projection model\nb. Camera models\nc. Projective geometry\n3. Radiometry and light models\na. Radiometry\nb. Rendering equation\nc. Rendering in nature – emission and scattering, etc.\n4. Rendering\na. Simple triangle rasterization\nb. Rendering with a shader-based API\n157\nc. Visibility and occlusion, including solutions to this problem (e.g., depth buffering, Painter’s\nalgorithm, and ray tracing)\nd. Texture mapping, including minification and magnification (e.g., trilinear MIP mapping)\ne. Application of spatial data structures to rendering.\nf. Ray tracing\ng. Sampling and anti-aliasing"
  },
  {
    "title": "GIT-Modeling: Geometric Modeling",
    "KA Core": "1. Basic geometric operations such as intersection calculation and proximity tests on 2D objects\n2. Surface representation/model\na. Tessellation\nb. Mesh representation, mesh fairing, and mesh generation techniques such as Delaunay\ntriangulation, and marching cubes/tetrahedrons\nc. Parametric polynomial curves and surfaces\nd. Implicit representation of curves and surfaces\ne. Spatial subdivision techniques\n3. Volumetric representation/model\na. Volumes, voxels, and point-based representations.\nb. Signed Distance Fields\nc. Sparse Volumes, i.e., VDB\nd. Constructive Solid Geometry (CSG) representation\n4. Procedural representation/model\n158\na. Fractals\nb. L-Systems\n5. Multi-resolution modeling (See also: SPD-Game)\n6. Reconstruction, e.g., 3D scanning, photogrammetry"
  },
  {
    "title": "GIT-Shading: Shading and Advanced Rendering",
    "KA Core": "1. Solutions and approximations to the rendering equation, for example\na. Distribution ray tracing and path tracing\nb. Photon mapping\nc. Bidirectional path tracing\nd. Metropolis light transport\n2. Time (motion blur), lens position (focus), and continuous frequency (color) and their impact on\nrendering\n3. Shadow mapping\n4. Occlusion culling\n5. Bidirectional Scattering Distribution function (BSDF) theory and microfacets\n6. Subsurface scattering\n7. Area light sources\n8. Hierarchical depth buffering\n9. Image-based rendering\n10. Non-photorealistic rendering\n11. Realtime rendering\n12. GPU architecture (See also: AR-Heterogeneity)\n13. Human visual systems including adaptation to light, sensitivity to noise, and flicker fusion (See also:\nHCI-Accessibility, SEP-DEIA)"
  },
  {
    "title": "GIT-Animation: Computer Animation",
    "KA Core": "1. Principles of Animation: Squash and Stretch, Timing, Anticipation, Staging, Follow Through and\nOverlapping Action, Straight Ahead Action, and Pose-to-Pose Action, Slow In and Out, Arcs,\nExaggeration, and Appeal\n2. Types of animation\na. 2- and 3-dimensional animation\nb. Motion graphics\nc. Motion capture\nd. Motion graphics\ne. Stop animation\n3. Key-frame animation\na. Keyframe Interpolation Methods: Lerp/Slerp/Spline\n4. Forward and inverse kinematics (See also: SPD-Robot, AI-Robotics)\n5. Skinning algorithms\na. Capturing\nb. Linear blend, dual quaternion\nc. Rigging\nd. Blend shapes\ne. Pose space deformation\n6. Motion capture\na. Set up and fundamentals\nb. Blending motion capture clips\nc. Blending motion capture and keyframe animation\nd. Ethical considerations (See also: SEP-DEIA, SEP-Privacy)\ni. Avoidance of “default” captures - there is no typical human walk cycle.\nii. Accessibility"
  },
  {
    "title": "GIT-Simulation: Simulation",
    "KA Core": "1. Collision detection and response\na. Signed Distance Fields\nb. Sphere/sphere\nc. Triangle/point\nd. Edge/edge\n2. Procedural animation using noise\n3. Particle systems\na. Integration methods (e.g., forward Euler, midpoint, leapfrog)\nb. Mass/spring networks\nc. Position-based dynamics\nd. Rules (e.g., boids, crowds)\ne. Rigid bodies\n4. Grid-based fluids\na. Semi-Lagrangian advection\nb. Pressure projection\n5. Heightfields\na. Terrain: transport, erosion\nb. Water: ripple, shallow water.\n6. Rule-based systems (e.g., L-systems, space-colonizing systems, Game of Life)"
  },
  {
    "title": "GIT-Immersion: Immersion",
    "KA Core": "(See also: SPD-Game, SPD-Mobile, HCI-Design)\n1. Immersion levels (i.e., Virtual Reality (VR), Augmented Reality (AR), and Mixed Reality (MR))\n2. Definitions of and distinctions between immersion and presence\n3. 360 Video\n4. Stereoscopic display\na. Head-mounted displays\nb. Stereo glasses\n161\n5. Viewer tracking\na. Inside out and outside In\nb. Head/Body/Hand/tracking\n6. Time-critical rendering to achieve optimal Motion To Photon (MTP) latency\na. Multiple Levels Of Details (LOD)\nb. Image-based VR\nc. Branching movies\n7. Distributed VR, collaboration over computer network\n8. Presence and factors that impact level of immersion\n9. 3D interaction\n10. Applications in medicine, simulation, training, and visualization\n11. Safety in immersive applications\na. Motion sickness\nb. VR obscures the real world, which increases the potential for falls and physical accidents"
  },
  {
    "title": "GIT-Interaction: Interaction",
    "KA Core": "1. Event Driven Programming (See also: FPL-Event-Driven)\na. Mouse or touch events\nb. Keyboard events\nc. Voice input\nd. Sensors\ne. Message passing communication\nf. Network events\n2. Graphical User Interface (Single Channel)\na. Window\nb. Icons\nc. Menus\nd. Pointing Devices\n3. Accessibility (See also: SEP-DEIA)\n162",
    "Non-core": "4. Gestural Interfaces (See also: SPD-Game)\na. Touch screen gestures\nb. Hand and body gestures\n5. Haptic Interfaces\na. External actuators\nb. Gloves\nc. Exoskeletons\n6. Multimodal Interfaces\n7. Head-worn Interfaces\na. Brain-computer interfaces, e.g., Electroencephalography (EEG) electrodes and Multi-Electrode\nArrays (MEAs)\nb. Headsets with embedded eye tracking\nc. AR glasses\n8. Natural Language Interfaces (See also: AI-NLP)"
  },
  {
    "title": "GIT-Image: Image Processing",
    "KA Core": "(See also: AI-Vision)\n1. Morphological operations\na. Connected components\nb. Dilation\nc. Erosion\nd. Computing region properties (area, perimeter, centroid, etc.)\n2. Color histograms\na. Representation\nb. Contrast enhancement through normalization\n3. Image enhancement\na. Convolution\nb. Blur (e.g., Gaussian)\nc. Sharpen (e.g., Laplacian)\nd. Frequency filtering (e.g., low-pass, high-pass)\n4. Image restoration\n163\na. Noise, degradation\nb. Inpainting and other completion algorithms\nc. Wiener filter\n5. Image coding\na. Redundancy\nb. Compression (e.g., Huffman coding)\nc. Discrete Cosine Transform (DCT), wavelet transform, Fourier transforms (See also: SPD-\nInteractive)\nd. Nyquist Theorem\ne. Watermarks\n6. Connections to deep learning (e.g., Convolutional Neural Networks) (See also: AI-ML)"
  },
  {
    "title": "GIT-Physical: Tangible/Physical Computing",
    "KA Core": "1. Interaction with the physical world (See also: SPD-Embedded)\na. Acquisition of data from sensors\nb. Driving external actuators\n2. Connection to physical artifacts\na. Computer-Aided Design (CAD)\nb. Computer-Aided Manufacturing (CAM)\nc. Fabrication (See also: HCI-Design)\ni. Prototyping\nii. Additive (3D printing)\niii. Subtractive (Computer Numerical Control (CNC) milling)\niv. Forming (vacuum forming)\n3. Internet of Things (See also: SPD-Interactive)\na. Network connectivity\nb. Wireless communication"
  },
  {
    "title": "GIT-SEP: Society, Ethics, and the Profession",
    "KA Core": "1. Accessibility in immersive, interactive, and physical computing applications (See also: SEP-DEIA)\na. Accessible to people with mobility impairments\nb. Accessible to people with vision and/or hearing impairments\n2. Ethics/privacy in graphics applications. (See also: SEP-Privacy, SEP-Professional-Ethics, and\nSEP-Security)\na. Acquisition of private data (room scans, body proportions, active cameras, etc.)\nb. Can’t look away from immersive applications easily\nc. Danger to self/surroundings while immersed\nd. Ethical pitfalls of facial recognition\ne. Misleading visualizations\ni. Due to incorrect data because of exaggeration, hole filling, smoothing, data cleanup, etc.\nii. Even correct data can mislead (e.g., aliasing can cause back moving or stopped fan\nblades)\nf. Privacy regarding health and other personal information\ng. Bias in image processing\ni. Deep fakes\nii. Applications that misidentify people based on skin color or hairstyle\n3. Intellectual Property law as it relates to computer graphics and interactive techniques (See also:\nSEP-IP)\na. images used to train generative AI\nb. images produced by generative AI\n4. Current and past contributors to the field (See also: SEP-DEIA)"
  },
  {
    "title": "HCI-User: Understanding the User: Individual goals and interactions with others",
    "CS Core": "1. User-centered design and evaluation methods. (See also: SEP-Context, SEP-Ethical-Analysis,\nSEP-Professional-Ethics)\na. “You are not the users”\nb. User needs-finding\nc. Formative studies\nd. Interviews\ne. Surveys\nf. Usability tests",
    "KA Core": "2. User-centered design methodology. (See also: SE-Tools)\na. Personas/persona spectrum\nb. User stories/storytelling and techniques for gathering stories\nc. Empathy maps\nd. Needs assessment (techniques for uncovering needs and gathering requirements - e.g.,\ninterviews, surveys, ethnographic and contextual enquiry) (See also: SE-Requirements)\ne. Journey maps\nf. Evaluating the design (See also: HCI-Evaluation)\ng. Interfacing with stakeholders, as a team\nh. Risks associated with physical, distributed, hybrid and virtual teams\n3. Physical and cognitive characteristics of the user\na. Physical capabilities that inform interaction design (e.g., color perception, ergonomics)\n174\nb. Cognitive models that inform interaction design (e.g., attention, perception and recognition,\nmovement, memory)\nc. Topics in social/behavioral psychology (e.g., cognitive biases, change blindness)\n4. Designing for diverse user populations. (See also: SEP-DEIA, HCI-Accessibility)\na. How differences (e.g., in race, ability, age, gender, culture, experience, and education)\nimpact user experiences and needs\nb. Internationalization\nc. Designing for users from other cultures\nd. Cross-cultural design\ne. Challenges to effective design evaluation. (e.g., sampling, generalization; disability and\ndisabled experiences)\nf. Universal design\n5. Collaboration and communication (See also: AI-SEP, SE-Teamwork, SEP-Communication, SPD-\nGame)\na. Understanding the user in a multi-user context\nb. Synchronous group communication (e.g., chat rooms, conferencing, online games)\nc. Asynchronous group communication (e.g., email, forums, social networks)\nd. Social media, social computing, and social network analysis\ne. Online collaboration\nf. Social coordination and online communities\ng. Avatars, characters, and virtual worlds",
    "Non-core": "6. Multi-user systems"
  },
  {
    "title": "HCI-Accountability: Accountability and Responsibility in Design",
    "CS Core": "(See also: SEP-Context)\n1. Design impact\na. Sustainability (See also: SEP-Sustainability)\nb. Inclusivity (See also: SEP-DEIA)\nc. Safety, security and privacy (See also: SEP-Security, SEC-Foundations)\nd. Harm and disparate impact (See also: SEP-DEIA)\n2. Ethics in design methods and solutions (See also: SEP-Ethical-Analysis, SEP-Context, SEP-\nIntellectual Property)\na. The role of artificial intelligence (See also: AI-SEP)\nb. Responsibilities for considering stakeholder impact and human factors (See also: SEP-\nProfessional-Ethics)\nc. Role of design to meet user needs\n3. Requirements in design (See also: SEP-Professional-Ethics)\na. Ownership responsibility\nb. Legal frameworks, compliance requirements\nc. Consideration beyond immediate user needs, including via iterative reconstruction of\nproblem analysis and “digital well-being” features",
    "KA Core": "4. Value-sensitive design (See also: SEP-Ethical-Analysis, SEP-Context, SEP-Communication)\na. Identify direct and indirect stakeholders\nb. Determine and include diverse stakeholder values and value systems.\n5. Persuasion through design (See also: SEP-Communication)\na. Assess the persuasive content of a design\nb. Employ persuasion as a design goal\nc. Distinguish persuasive interfaces from manipulative interfaces"
  },
  {
    "title": "HCI-Accessibility: Accessibility and Inclusive Design",
    "CS Core": "1. Background (See also: SEP-DEIA, SEP-Security)\na. Societal and legal support for and obligations to people with disabilities\nb. Accessible design benefits everyone\n2. Techniques\na. Accessibility standards (e.g., Web Content Accessibility Guidelines) (See also: SPD-Web)\n3. Technologies (See also: SE-Tools)\na. Features and products that enable accessibility and support inclusive development by\ndesigners and engineers\n4. IDFs (Inclusive Design Frameworks) (See also: SEP-DEIA)\na. Recognizing differences\n5. Universal design",
    "KA Core": "6. Background\na. Demographics and populations (permanent, temporary, and situational disability)\nb. International perspectives on disability (See also: SEP-DEIA)\nc. Attitudes towards people with disabilities (See also: SEP-DEIA)\n7. Techniques\na. UX (user experience) design and research\nb. Software engineering practices that enable inclusion and accessibility. (See also: SEP-DEIA)\n8. Technologies\na. Examples of accessibility-enabling features, such as conformance to screen readers\n9. Inclusive Design Frameworks\na. Creating inclusive processes such as participatory design\nb. Designing for larger impact",
    "Non-core": "10. Background (See also: SEP-DEIA)\na. Unlearning and questioning\nb. Disability studies\n11. Technologies: the Return On Investment (ROI) of inclusion\n12. Inclusive Design Frameworks: user-sensitive inclusive design (See also: SEP-DEIA)\n13. Critical approaches to HCI (e.g., inclusivity) (See also: SEP-DEIA)"
  },
  {
    "title": "HCI-Evaluation: Evaluating the Design",
    "CS Core": "1. Methods for evaluation with users\na. Formative (e.g., needs-finding, exploratory analysis) and summative assessment (e.g.,\nfunctionality and usability testing)\nb. Elements to evaluate (e.g., utility, efficiency, learnability, user satisfaction, affective elements\nsuch as pleasure and engagement)\nc. Understanding ethical approval requirements before engaging in user research (See also: SE-\nTools, SEP-Ethical-Analysis, SEP-Security, SEP-Privacy, SEP-Professional-Ethics)",
    "KA Core": "2. Methods for evaluation with users (See also: SE-Validation)\na. Qualitative methods (qualitative coding and thematic analysis)\nb. Quantitative methods (statistical tests)\nc. Mixed methods (e.g., observation, think-aloud, interview, survey, experiment)\nd. Presentation requirements (e.g., reports, personas)\ne. User-centered testing\nf. Heuristic evaluation\ng. Challenges and shortcomings to effective evaluation (e.g., sampling, generalization)\n3. Study planning\na. How to set study goals\nb. Hypothesis design\nc. Approvals from Institutional Research Boards and ethics committees (See also: SEP-Ethical-\nAnalysis, SEP-Security, SEP-Privacy)\nd. How to pre-register a study\ne. Within-subjects vs between-subjects design\n4. Implications and impacts of design with respect to the environment, material, society, security,\nprivacy, ethics, and broader impacts. (See also: SEC-Foundations)\n178\na. The environment\nb. Material\nc. Society\nd. Security\ne. Privacy\nf. Ethics\ng. Broader impacts",
    "Non-core": "5. Techniques and tools for quantitative analysis\na. Statistical packages\nb. Visualization tools\nc. Statistical tests (e.g., ANOVA, t-tests, post-hoc analysis, parametric vs non-parametric tests)\nd. Data exploration and visual analytics; how to calculate effect size.\n6. Data management\na. Data storage and data sharing (open science)\nb. Sensitivity and identifiability."
  },
  {
    "title": "HCI-Design: System Design",
    "CS Core": "1. Prototyping techniques and tools\na. Low-fidelity prototyping\nb. Rapid prototyping\nc. Throw-away prototyping\n179\nd. Granularity of prototyping\n2. Design patterns\na. Iterative design\nb. Universal design (See also: SEP-DEIA)\nc. Interaction design (e.g., data-driven design, event-driven design)\n3. Design constraints\na. Platforms (See also: SPD-Game)\nb. Devices\nc. Resources\nd. Balance among usability, security and privacy (See also: SEC-Foundations)",
    "KA Core": "4. Design patterns and guidelines\na. Software architecture patterns\nb. Cross-platform design\nc. Synchronization considerations\n5. Design processes (See also: SEP-Communication)\na. Participatory design\nb. Co-design\nc. Double-diamond\nd. Convergence and divergence\n6. Interaction techniques (See also: GIT-Interaction)\na. Input and output vectors (e.g., gesture, pose, touch, voice, force)\nb. Graphical user interfaces\nc. Controllers\nd. Haptics\ne. Hardware design\nf. Error handling\n7. Visual UI design (See also: GIT-Visualization)\na. Color\nb. Layout\nc. Gestalt principles",
    "Non-core": "8. Immersive environments (See also: GIT-Immersion)\na. XR (encompasses virtual reality, augmented reality, and mixed reality)\nb. Spatial audio\n9. 3D printing and fabrication\n10. Asynchronous interaction models\n11. Creativity support tools\n12. Voice UI designs"
  },
  {
    "title": "HCI-SEP: Society, Ethics, and the Profession",
    "CS Core": "1. Universal and user-centered design (See also: HCI-User, SEP-DEIA)\n2. Accountability (See also: HCI-Accountability)\n3. Accessibility and inclusive design (See also: SEP-DEIA, SEP-Security)\n4. Evaluating the design (See also: HCI-Evaluation)\n5. System design (See also: HCI-Design)",
    "KA Core": "6. Participatory and inclusive design processes\n7. Evaluating the design: Implications and impacts of design: with respect to the environment,\nmaterial, society, security, privacy, ethics, and broader impacts (See also: SEC-Foundations, SEP-\nPrivacy)",
    "Non-core": "8. VR/AR/MR scenarios"
  },
  {
    "title": "MSF-Discrete: Discrete Mathematics",
    "CS Core": "1. Sets, relations, functions, cardinality\n2. Recursive mathematical definitions\n3. Proof techniques (induction, proof by contradiction)\n4. Permutations, combinations, counting, pigeonhole principle\n5. Modular arithmetic\n6. Logic: truth tables, connectives (operators), inference rules, formulas, normal forms, simple\npredicate logic\n7. Graphs: basic definitions\n8. Order notation",
    "KA Core": "The recommended topics are the same between CS core and KA-core, but with far more hours, the\nKA-core can cover these topics in depth and might include more computing-related applications."
  },
  {
    "title": "MSF-Probability: Probability",
    "CS Core": "188\n1. Basic notions: sample spaces, events, probability, conditional probability, Bayes’ rule\n2. Discrete random variables and distributions\n3. Continuous random variables and distributions\n4. Expectation, variance, law of large numbers, central limit theorem\n5. Conditional distributions and expectation\n6. Applications to computing, the difference between probability and statistics (as subjects)",
    "KA Core": "The recommended topics are the same between CS core and KA-core, but with far more hours, the\nKA-core can cover these topics in depth and might include more computing-related applications."
  },
  {
    "title": "MSF-Statistics: Statistics",
    "CS Core": "1. Basic definitions and concepts: populations, samples, measures of central tendency, variance\n2. Univariate data: point estimation, confidence intervals",
    "KA Core": "3. Multivariate data: estimation, correlation, regression\n4. Data transformation: dimension reduction, smoothing\n5. Statistical models and algorithms\n6. Hypothesis testing"
  },
  {
    "title": "MSF-Linear: Linear Algebra",
    "CS Core": "1. Vectors: definitions, vector operations, geometric interpretation, angles: Matrices: definition, matrix\noperations, meaning of Ax=b.",
    "KA Core": "2. Matrices, matrix-vector equation, geometric interpretation, geometric transformations with matrices\n3. Solving equations, row-reduction\n4. Linear independence, span, basis\n5. Orthogonality, projection, least-squares, orthogonal bases\n6. Linear combinations of polynomials, Bezier curves\n7. Eigenvectors and eigenvalues\n8. Applications to computer science: Principal Components Analysis (PCA), Singular Value\nDecomposition (SVD), page-rank, graphics"
  },
  {
    "title": "MSF-Calculus",
    "KA Core": "1. Sequences, series, limits\n192\n2. Single-variable derivatives: definition, computation rules (chain rule etc.), derivatives of important\nfunctions, applications\n3. Single-variable integration: definition, computation rules, integrals of important functions,\nfundamental theorem of calculus, definite vs indefinite, applications (including in probability)\n4. Parametric and polar representations\n5. Taylor series\n6. Multivariate calculus: partial derivatives, gradient, chain-rule, vector valued functions,\n7. Optimization: convexity, global vs local minima, gradient descent, constrained optimization, and\nLagrange multipliers.\n8. Ordinary Differential Equations (ODEs): definition, Euler method, applications to simulation, Monte\nCarlo integration\n9. CS applications: gradient descent for machine learning, forward and inverse kinematics,\napplications of calculus to probability\nNote: the calculus topics listed above are aligned with computer science goals rather than with\ntraditional calculus courses. For example, multivariate calculus is often a course by itself, but computer\nscience undergraduates only need parts of it for machine learning."
  },
  {
    "title": "NC-Fundamentals: Fundamentals",
    "CS Core": "1. Importance of networking in contemporary computing, and associated challenges. (See also: SEP-\nContext, SEP-Privacy)\n2. Organization of the internet (e.g., users, Internet Service Providers, autonomous systems, content\nproviders, content delivery networks)\n3. Switching techniques (e.g., circuit and packet)\n4. Layers and their roles (application, transport, network, datalink, and physical)\n5. Layering principles (e.g., encapsulation and hourglass model) (See also: SF-Foundations)\n6. Network elements (e.g., routers, switches, hubs, access points, and hosts)\n7. Basic queueing concepts (e.g., relationship with latency, congestion, service levels, etc.)"
  },
  {
    "title": "NC-Applications: Networked Applications",
    "CS Core": "1. Naming and address schemes (e.g., DNS, and Uniform Resource Identifiers)\n2. Distributed application paradigms (e.g., client/server, peer-to-peer, cloud, edge, and fog) (See also:\nPDC-Communication, PDC-Coordination)\n3. Diversity of networked application demands (e.g., latency, bandwidth, and loss tolerance) (See\nalso: PDC-Communication, SEP-Sustainability, SEP-Context)\n4. Coverage of application-layer protocols (e.g., HTTP)\n5. Interactions with TCP, UDP, and Socket APIs (See also: PDC-Programs)"
  },
  {
    "title": "NC-Reliability: Reliability Support",
    "KA Core": "1. Unreliable delivery (e.g., UDP)\n2. Principles of reliability (e.g., delivery without loss, duplication, or out of order) (See also: SF-\nReliability)\n3. Error control (e.g., retransmission, error correction)\n4. Flow control (e.g., stop and wait, window based)\n5. Congestion control (e.g., implicit and explicit congestion notification)\n6. TCP and performance issues (e.g., Tahoe, Reno, Vegas, Cubic)"
  },
  {
    "title": "NC-Routing: Routing and Forwarding",
    "KA Core": "1. Routing paradigms and hierarchy (e.g., intra/inter domain, centralized and decentralized, source\nrouting, virtual circuits, QoS)\n2. Forwarding methods (e.g., forwarding tables and matching algorithms)\n3. IP and Scalability issues (e.g., NAT, CIDR, BGP, different versions of IP)\n199"
  },
  {
    "title": "NC-SingleHop: Single Hop Communication",
    "KA Core": "1. Introduction to modulation, bandwidth, and communication media\n2. Encoding and Framing\n3. Medium Access Control (MAC) (e.g., random access and scheduled access)\n4. Ethernet and WiFi\n5. Switching (e.g., spanning trees, VLANS).\n6. Local Area Network Topologies (e.g., data center, campus networks)."
  },
  {
    "title": "NC-Security: Network Security",
    "KA Core": "1. General intro about security (Threats, vulnerabilities, and countermeasures) (See also: SEP-\nSecurity, SEC-Foundations, SEC-Engineering)\n2. Network specific threats and attack types (e.g., denial of service, spoofing, sniffing and traffic\nredirection, attacker-in-the-middle, message integrity attacks, routing attacks, ransomware, and\ntraffic analysis) (See also: SEC-Foundations, SEC-Engineering)\n3. Countermeasures (: SEC-Foundations, SEC-Crypto, SEC-Engineering)\na. Cryptography (e.g. SSL, TLS, symmetric/asymmetric)\nb. Architectures for secure networks (e.g., secure channels, secure routing protocols, secure\nDNS, VPNs, DMZ, Zero Trust Network Access, hyper network security, anonymous\ncommunication protocols, isolation)\nc. Network monitoring, intrusion detection, firewalls, spoofing and DoS protection, honeypots,\ntracebacks, BGP Sec, RPKI"
  },
  {
    "title": "NC-Mobility: Mobility",
    "KA Core": "1. Principles of cellular communication (e.g., 4G, 5G)\n2. Principles of Wireless LANs (mainly 802.11)\n3. Device to device communication (e.g., IoT communication)\n4. Multi-hop wireless networks (e.g., ad hoc networks, opportunistic, delay tolerant)"
  },
  {
    "title": "NC-Emerging: Emerging Topics",
    "KA Core": "1. Middleboxes (e.g., advances in usage of AI, intent-based networking, filtering, deep packet\ninspection, load balancing, NAT, CDN)\n2. Network Virtualization (e.g., SDN, Data Center Networks)\n3. Quantum Networking (e.g., Intro to the domain, teleportation, security, Quantum Internet)\n4. Satellite, mmWave, Visible Light"
  },
  {
    "title": "OS-Purpose: Role and Purpose of Operating Systems",
    "CS Core": "1. Operating systems mediate between general purpose hardware and application-specific software.\n2. Universal operating system functions (e.g., process, user and device interfaces, persistence of\ndata)\n3. Extended and/or specialized operating system functions (e.g., embedded systems, server types\nsuch as file, web, multimedia, boot loaders and boot security)\n4. Design issues (e.g., efficiency, robustness, flexibility, portability, security, compatibility, power,\nsafety, tradeoffs between error checking and performance, flexibility and performance, and security\nand performance) (See also: SEC-Engineering)\n5. Influences of security, networking, multimedia, parallel and distributed computing\n6. Overarching concern of security/protection: Neglecting to consider security at every layer creates\nan opportunity to inappropriately access resources.\nExample concepts:\na. Unauthorized access to files on an unencrypted drive can be achieved by moving the media to\nanother computer.\nb. Operating systems enforced security can be defeated by infiltrating the boot layer before the\noperating system is loaded.\nc. Process isolation can be subverted by inadequate authorization checking at API boundaries.\nd. Vulnerabilities in system firmware can provide attack vectors that bypass the operating system\nentirely.\ne. Improper isolation of virtual machine memory, computing, and hardware can expose the host\nsystem to attacks from guest systems.\nf. The operating system may need to mitigate exploitation of hardware and firmware\nvulnerabilities, leading to potential performance reductions (e.g., Spectre and Meltdown\nmitigations).\n7. Exposure of operating systems functions in shells and systems programming. (See also: FPL-\nScripting)\n206"
  },
  {
    "title": "OS-Principles: Principles of Operating System",
    "CS Core": "1. Operating system software design and approaches (e.g., monolithic, layered, modular, micro-\nkernel, unikernel)\n2. Abstractions, processes, and resources\n3. Concept of system calls and links to application program interfaces (e.g., Win32, Java, Posix). (See\nalso: AR-Assembly)\n4. The evolution of the link between hardware architecture and the operating system functions\n5. Protection of resources means protecting some machine instructions/functions (See also: AR-\nAssembly)\nExample concepts:\na. Applications cannot arbitrarily access memory locations or file storage device addresses.\nb. Protection of coprocessors and network devices\n6. Leveraging interrupts from hardware level: service routines and implementations. (See also: AR-\nAssembly)\nExample concepts:\na. Timer interrupts for implementing time slices\nb. I/O interrupts for putting blocking threads to sleep without polling\n7. Concept of user/system state and protection, transition to kernel mode using system calls (See\nalso: AR-Assembly)\n8. Mechanism for invoking system calls, the corresponding mode and context switch and return from\ninterrupt (See also: AR-Assembly)\n9. Performance costs of context switches and associated cache flushes when performing process\nswitches in Spectre-mitigated environments."
  },
  {
    "title": "OS-Concurrency: Concurrency",
    "CS Core": "1. Thread abstraction relative to concurrency\n2. Race conditions, critical regions (role of interrupts, if needed) (See also: PDC-Programs)\n3. Deadlocks and starvation (See also: PDC-Coordination)\n4. Multiprocessor issues (spin-locks, reentrancy).\n5. Multiprocess concurrency vs multithreading",
    "KA Core": "6. Thread creation, states, structures (See also: SF-Foundations)\n7. Thread APIs\n8. Deadlocks and starvation (necessary conditions/mitigations) (See also: PDC-Coordination)\n9. Implementing thread safe code (semaphores, mutex locks, condition variables). (See also: AR-\nPerformance-Energy, SF-Evaluation, PDC-Evaluation)\n10. Race conditions in shared memory (See also: PDC-Coordination)\nNon-Core:\n11. Managing atomic access to OS objects (e.g., big kernel lock vs many small locks vs lockless data\nstructures like lists)"
  },
  {
    "title": "OS-Protection: Protection and Safety",
    "CS Core": "1. Overview of operating system security mechanisms (See also: SEC-Foundations)\n2. Attacks and antagonism (scheduling, etc.) (See also: SEC-Foundations)\n3. Review of major vulnerabilities in real operating systems (See also: SEC-Foundations)\n4. Operating systems mitigation strategies such as backups (See also: SF-Reliability)",
    "KA Core": "5. Policy/mechanism separation (See also: SEC-Governance)\n6. Security methods and devices (See also: SEC-Foundations)\nExample concepts:\na. Rings of protection (history from Multics to virtualized x86)\nb. x86_64 rings -1 and -2 (hypervisor and ME/PSP)\n7. Protection, access control, and authentication (See also: SEC-Foundations, SEC-Crypto)"
  },
  {
    "title": "OS-Scheduling: Scheduling",
    "KA Core": "1. Preemptive and non-preemptive scheduling\n2. Schedulers and policies (e.g., first come, first serve, shortest job first, priority, round robin,\nmultilevel) (See also: SF-Resource)\n3. Concepts of Symmetric Multi-Processor (SMP) scheduling and cache coherence (See also: AR-\nMemory)\n4. Timers (e.g., building many timers out of finite hardware timers) (See also: AR-Assembly)\n5. Fairness and starvation\nNon-Core:\n6. Subtopics of operating systems such as energy-aware scheduling and real-time scheduling (See\nalso: AR-Performance-Energy, SPD-Embedded, SPD-Mobile)\n7. Cooperative scheduling, such as Linux futexes and userland scheduling."
  },
  {
    "title": "OS-Process: Process Model",
    "KA Core": "1. Processes and threads relative to virtualization protected memory, process state, memory\nisolation, etc.\n2. Memory footprint/segmentation (e.g., stack, heap, etc.) (See also: AR-Assembly)\n3. Creating and loading executables, shared libraries, and dynamic linking (See also: FPL-Translation)\n4. Dispatching and context switching (See also: AR-Assembly)\n5. Interprocess communication (e.g., shared memory, message passing, signals, environment\nvariables) (See also: PDC-Communication)"
  },
  {
    "title": "OS-Memory: Memory Management",
    "KA Core": "1. Review of physical memory, address translation and memory management hardware (See also:\nAR-Memory, MSF-Discrete)\n2. Impact of memory hierarchy including cache concept, cache lookup, and per-CPU caching on\noperating system mechanisms and policy (See also: AR-Memory, SF-Performance)\n210\n3. Logical and physical addressing, address space virtualization (See also: AR-Memory, MSF-\nDiscrete)\n4. Concepts of paging, page replacement, thrashing and allocation of pages and frames\n5. Allocation/deallocation/storage techniques (algorithms and data structure) performance and\nflexibility\nExample concept: Arenas, slab allocators, free lists, size classes, heterogeneously sized pages\n(huge pages)\n6. Memory caching and cache coherence and the effect of flushing the cache to avoid speculative\nexecution vulnerabilities (See also: AR-Organization, AR-Memory, SF-Performance)\n7. Security mechanisms and concepts in memory management including sandboxing, protection,\nisolation, and relevant vectors of attack (See also: SEC-Foundations)\nNon-Core:\n8. Virtual memory: leveraging virtual memory hardware for OS services and efficiency"
  },
  {
    "title": "OS-Devices: Device management",
    "KA Core": "1. Buffering strategies (See also: AR-IO)\n2. Direct Memory Access (DMA) and polled I/O, Memory-mapped I/O (See also: AR-IO)\nExample concept: DMA communication protocols (e.g., ring buffers etc.)\n3. Historical and contextual - Persistent storage device management (e.g., magnetic, Solid State\nDevice (SSD)) (See also: SEP-History)\nNon-Core:\n4. Device interface abstractions, hardware abstraction layer\n5. Device driver purpose, abstraction, implementation, and testing challenges\n6. High-level fault tolerance in device communication"
  },
  {
    "title": "OS-Files: File Systems API and Implementation",
    "KA Core": "1. Concept of a file including data, metadata, operations, and access-mode\n2. File system mounting\n3. File access control\n4. File sharing\n5. Basic file allocation methods, including linked allocation table\n6. File system structures comprising file allocation including various directory structures and methods\nfor uniquely identifying files (e.g., name, identified or metadata storage location)\n7. Allocation/deallocation/storage techniques (algorithms and data structure) impact on performance\nand flexibility (i.e., internal and external fragmentation and compaction)\n8. Free space management such as using bit tables vs linking\n9. Implementation of directories to segment and track file location"
  },
  {
    "title": "OS-Advanced-Files: Advanced File systems",
    "KA Core": "1. File systems: partitioning, mount/unmount, virtual file systems\n2. In-depth implementation techniques\n3. Memory-mapped files (See also: AR-IO )\n4. Special-purpose file systems\n5. Naming, searching, access, backups\n6. Journaling and log-structured file systems (See also: SF-Reliability)\n212\nNon-Core: (including emerging topics)\n1. Distributed file systems\n2. Encrypted file systems\n3. Fault tolerance"
  },
  {
    "title": "OS-Virtualization: Virtualization",
    "KA Core": "1. Using virtualization and isolation to achieve protection and predictable performance. (See also: SF-\nPerformance)\n2. Advanced paging and virtual memory. (See also: SF-Performance)\n3. Virtual file systems and virtual devices.\n4. Containers and their comparison to virtual machines.\n5. Thrashing (e.g., Popek and Goldberg requirements for recursively virtualizable systems).",
    "Non-core": "6. Types of virtualizations (including hardware/software, OS, server, service, network). (See also: SF-\nPerformance)\n7. Portable virtualization; emulation vs isolation. (See also: SF-Performance)\n8. Cost of virtualization. (See also: SF-Performance)\n9. Virtual machines and container escapes, dangers from a security perspective. (See also: SEC-\nEngineering)\n10. Hypervisors- hardware virtual machine extensions, hosts with kernel support, QEMU KVM"
  },
  {
    "title": "OS-Real-time: Real-time and Embedded Systems",
    "KA Core": "1. Process and task scheduling.\n2. Deadlines and real-time issues. (See also: SPD-Embedded)\n3. Low-latency vs ”soft real-time\" vs \"hard real time.\" (See also: SPD-Embedded, FPL-Event-Driven)\nNon-Core:\n4. Memory/disk management requirements in a real-time environment.\n5. Failures, risks, and recovery.\n6. Special concerns in real-time systems (safety)."
  },
  {
    "title": "OS-Faults: Fault tolerance",
    "KA Core": "1. Reliable and available systems. (See also: SF-Reliability)\n2. Software and hardware approaches to address tolerance (RAID). (See also: SF-Reliability)\nNon-Core:\n3. Spatial and temporal redundancy. (See also: SF-Reliability)\n4. Methods used to implement fault tolerance. (See also: SF-Reliability)\n5. Error identification and correction mechanisms, checksums of volatile memory in RAM. (See also:\nAR-Memory)\n6. File system consistency check and recovery.\n7. Journaling and log-structured file systems. (See also: SF-Reliability)\n8. Use-cases for fault-tolerance (databases, safety-critical). (See also: SF-Reliability)\n9. Examples of OS mechanisms for detection, recovery, restart to implement fault tolerance, use of\nthese techniques for the OS’s own services. (See also: SF-Reliability)"
  },
  {
    "title": "OS-SEP: Society, Ethics, and the Profession",
    "KA Core": "1. Open source in operating systems. (See also: SEP-IP)\nExample concepts:\na. Identification of vulnerabilities in open-source kernels,\nb. Open-source guest operating systems,\nc. Open-source host operating systems, and\nd. Changes in monetization (paid vs free upgrades).\n2. End-of-life issues with sunsetting operating systems.\nExample concept: Privacy implications of using proprietary operating systems/operating\nenvironments, including telemetry, automated scanning of personal data, built-in advertising, and\nautomatic cloud integration."
  },
  {
    "title": "PDC-Programs: Programs",
    "CS Core": "1. Parallelism\na. Declarative parallelism: Determining which actions may, or must not, be performed in\nparallel, at the level of instructions, functions, closures, composite actions, sessions, tasks,\nand services is the main idea underlying PDC algorithms; failing to do so is the main source\nof errors. (See also: PDC-Algorithms)\nb. Defining order: for example, using happens-before relations or series/parallel directed\nacyclic graphs representing programs.\nc. Independence: determining when ordering does not matter, in terms of commutativity,\ndependencies, preconditions.\nd. Ensuring ordering among otherwise parallel actions when necessary, including locking, safe\npublication; and imposing communication – sending a message happens before receiving it;\nconversely relaxing when unnecessary.\n2. Distribution\na. Defining places, as devices executing actions, including hardware components, remote\nhosts, may also include external, uncontrolled devices, hosts, and users. (See also: AR-IO)\nb. One device may time-slice or otherwise emulate multiple parallel actions by fewer\nprocessors by scheduling and virtualization. (See also: OS-Scheduling)\nc. Naming or identifying places (e.g., device IDs) and actions as parties (e.g., thread IDs).\nd. Activities across places may communicate across media. (See also: PDC-Communication)\n3. Starting activities\na. Options that enable actions to be performed (eventually) at places range from hardwiring to\nconfiguration scripts; also establishing communication and resource management; these are\nexpressed differently across languages and contexts, usually relying on automated\nprovisioning and management by platforms (See also: SF-Resources)\nb. Procedural: Enabling multiple actions to start at a given program point; for example, starting\nnew threads, possibly scoping, or otherwise organizing them in hierarchical groups\nc. Reactive: Enabling upon an event by installing an event handler, with less control of when\nactions begin or end, and may apply even on uniprocessors\nd. Dependent: Enabling upon completion of others; for example, sequencing sets of parallel\nactions (See also: PDC-Coordination)\ne. Granularity: Execution cost of action bodies should outweigh the overhead of arranging\nthem\n219\n4. Execution Properties\na. Nondeterministic execution of unordered actions\nb. Consistency: Ensuring agreement among parties about values and predicates when\nnecessary to avoid races, maintain safety and atomicity, or arrive at consensus\nc. Fault tolerance: Handling failures in parties or communication, including (Byzantine)\nmisbehavior due to untrusted parties and protocols, when necessary to maintain progress or\navailability (See also: SF-Reliability)\nd. Tradeoffs are one focus of evaluation (See also: PDC-Evaluation)",
    "KA Core": "5. One or more of the following mappings and mechanisms across layered systems:\na. CPU data- and instruction-level-parallelism (See also: AR-Organization)\nb. SIMD and heterogeneous data parallelism (See also: AR-Heterogeneity)\nc. Multicore scheduled concurrency, tasks, actors (See also: OS-Scheduling)\nd. Clusters, clouds; elastic provisioning. (See also: SPD-Common)\ne. Networked distributed systems (See also: NC-Applications)\nf. Emerging technologies such as quantum computing and molecular computing\nIllustrative Learning Outcomes;"
  },
  {
    "title": "PDC-Communication: Communication",
    "CS Core": "1. Media\na. Varieties: channels (message passing or I/O), shared memory, heterogeneous, data stores\nb. Reliance on the availability and nature of underlying hardware, connectivity, and protocols;\nlanguage support, emulation (See also: AR-IO)\n2. Channels\na. Explicit (usually named) party-to-party communication media\nb. APIs: Sockets, architectural, language-based, and toolkit constructs, such as Message\nPassing Interface (MPI), and layered constructs such as Remote Procedure Call (RPC) (See\nalso: NC-Fundamentals)\nc. I/O channel APIs\n3. Memory\n220\na. Shared memory architectures in which parties directly communicate only with memory at\ngiven addresses, with extensions to heterogeneous memory supporting multiple memory\nstores with explicit data transfer across them; for example, GPU local and shared memory,\nDirect Memory Access (DMA)\nb. Memory hierarchies: Multiple layers of sharing domains, scopes, and caches; locality:\nlatency, false-sharing\nc. Consistency properties: Bitwise atomicity limits, coherence, local ordering\n4. Data Stores\na. Cooperatively maintained data structures implementing maps and related ADTs\nb. Varieties: Owned, shared, sharded, replicated, immutable, versioned",
    "KA Core": "5. One or more of the following properties and extensions\na. Topologies: Unicast, Multicast, Mailboxes, Switches; Routing via hardware and software\ninterconnection networks\nb. Media concurrency properties: Ordering, consistency, idempotency, overlapping\ncommunication with computation\nc. Media performance: Latency, bandwidth (throughput) contention (congestion),\nresponsiveness (liveness), reliability (error and drop rates), protocol-based progress (acks,\ntimeouts, mediation)\nd. Media security properties: integrity, privacy, authentication, authorization (See also: SEC-\nSecure Coding)\ne. Data formats: Marshaling, validation, encryption, compression\nf. Channel policies: Endpoints, sessions, buffering, saturation response (waiting vs dropping),\nrate control\ng. Multiplexing and demultiplexing many relatively slow I/O devices or parties; completion-\nbased and scheduler-based techniques; async-await, select and polling APIs\nh. Formalization and analysis of channel communication; for example, CSP\ni. Applications of queuing theory to model and predict performance.\nj. Memory models: sequential and release/acquire consistency\nk. Memory management; including reclamation of shared data; reference counts and\nalternatives\nl. Bulk data placement and transfer; reducing message traffic and improving locality;\noverlapping data transfer and computation; impact of data layout such as array-of-structs vs\nstruct-of-arrays\nm. Emulating shared memory: distributed shared memory, Remote Direct Memory Access\n(RDMA)\nn. Data store consistency: Atomicity, linearizability, transactionality, coherence, causal\nordering, conflict resolution, eventual consistency, blockchains\no. Faults, partitioning, and partial failures; voting; protocols such as Paxos and Raft.\np. Design tradeoffs among consistency, availability, partition (fault) tolerance; impossibility of\nmeeting all at once\nq. Security and trust: Byzantine failures, proof of work and alternatives\n221"
  },
  {
    "title": "PDC-Coordination: Coordination",
    "CS Core": "1. Dependencies\na. Initiation or progress of one activity may be dependent on other activities, so as to avoid\nrace conditions, ensure termination, or meet other requirements\nb. Ensuring progress by avoiding dependency cycles, using monotonic conditions, removing\ninessential dependencies\n2. Control constructs and design patterns\na. Completion-based: Barriers, joins, including termination control\nb. Data-enabled: Queues, producer-consumer designs\nc. Condition-based: Polling, retrying, backoffs, helping, suspension, signaling, timeouts\nd. Reactive: Enabling and triggering continuations\n3. Atomicity\na. Atomic instructions, enforced local access orderings\nb. Locks and mutual exclusion; lock granularity\nc. Using locks in a specific language; maintaining liveness without introducing races\n222\nd. Deadlock avoidance: Ordering, coarsening, randomized retries; backoffs, encapsulation via\nlock managers\ne. Common errors: Failing to lock or unlock when necessary, holding locks while invoking\nunknown operations\nf. Avoiding locks: replication, read-only, ownership, and non-blocking constructions",
    "KA Core": "4. One or more of the following properties and extensions\na. Progress properties including lock-free, wait-free, fairness, priority scheduling, interactions\nwith consistency, reliability\nb. Performance with respect to contention, granularity, convoying, scaling\nc. Non-blocking data structures and algorithms\nd. Ownership and resource control\ne. Lock variants and alternatives: sequence locks, read-write locks; Read-Copy-Update (RCU),\nreentrancy; tickets; controlling spinning versus blocking\nf. Transaction-based control: Optimistic and conservative\ng. Distributed locking: reliability\nh. Alternatives to barriers: Clocks; counters, virtual clocks; dataflow and continuations; futures\nand RPC; consensus-based, gathering results with reducers and collectors\ni. Speculation, selection, cancellation; observability and security consequences\nj. Resource control using semaphores and condition variables\nk. Control flow: Scheduling computations, series-parallel loops with (possibly elected) leaders,\npipelines and streams, nested parallelism\nl. Exceptions and failures. Handlers, detection, timeouts, fault tolerance, voting"
  },
  {
    "title": "PDC-Evaluation: Evaluation",
    "CS Core": "1. Safety and liveness requirements in terms of temporal logic constructs to express “always” and\n“eventually” (See also: FPL-Parallel)\n2. Identifying, testing for, and repairing violations, including common forms of errors such as failure to\nensure necessary ordering (race errors), atomicity (including check-then-act errors), and\ntermination (livelock)\n3. Performance requirements metrics for throughput, responsiveness, latency, availability, energy\nconsumption, scalability, resource usage, communication costs, waiting and rate control, fairness;\nservice level agreements (See also: SF-Performance)\n4. Performance impact of design and implementation choices, including granularity, overhead,\nconsensus costs, and energy consumption (See also: SEP-Sustainability)\n5. Estimating scalability limitations, for example using Amdahl’s Law or Universal Scalability Law (See\nalso: SF-Evaluation)",
    "KA Core": "6. One or more of the following methods and tools:\na. Extensions to formal sequential requirements such as linearizability\nb. Protocol, session, and transactional specifications\nc. Use of tools such as Unified Modelling Language (UML), Temporal Logic of Actions (TLA),\nprogram logics\nd. Security analysis: safety and liveness in the presence of hostile or buggy behaviors by other\nparties; required properties of communication mechanisms (for example lack of cross-layer\nleakage), input screening, rate limiting (See also: SEC-Foundations)\ne. Static analysis applied to correctness, throughput, latency, resources, energy (See also:\nSEP-Sustainability)\nf. Directed Acyclic Graph (DAG) model analysis of algorithmic efficiency (work, span, critical\npaths)\ng. Testing and debugging; tools such as race detectors, fuzzers, lock dependency checkers,\nunit/stress/torture tests, visualizations, continuous integration, continuous deployment, and\ntest generators\nh. Measuring and comparing throughput, overhead, waiting, contention, communication, data\nmovement, locality, resource usage, behavior in the presence of excessive numbers of\nevents, clients, or threads (See also: SF-Evaluation)\ni. Application domain specific analyses and evaluation techniques"
  },
  {
    "title": "PDC-Algorithms: Algorithms",
    "CS Core": "1. Expressing and implementing algorithms in given languages and frameworks, to initiate activities\n(for example threads), use shared memory constructs, and channel, socket, and/or remote\nprocedure call APIs. (See also: FPL-Parallel).\na. Data parallel examples including map/reduce.\nb. Using channel, socket, and/or RPC APIs in a given language, with program control for\nsending (usually procedural) vs receiving. (usually reactive or RPC-based).\nc. Using locks, barriers, and/or synchronizers to maintain liveness without introducing races.\n2. Survey of common application domains across multicore, reactive, data parallel, cluster, cloud,\nopen distributed systems, and frameworks (with reference to the following table).\nCategory Typical Typical Typical Typical\nExecution agents Communication Algorithmic Engineering\nmechanisms domains goals\nMulticore Threads Shared memory, Resource Throughput,\nAtomics, locks management, latency,\ndata processing energy\nReactive Handlers, threads I/O Channels Services, real- Latency\ntime\nData parallel GPU, SIMD, Heterogeneous Linear algebra, Throughput,\n225\naccelerators, memory graphics, data energy\nhybrid analysis\nCluster Managed hosts Sockets, channels Simulation, data Throughput\nanalysis\nCloud Provisioned hosts Service APIs Web Scalability\napplications\nOpen Autonomous hosts Sockets, Data Fault tolerant Reliability\ndistributed stores data stores and\nservices",
    "KA Core": "3. One of more of the following algorithmic domains. (See also: AL-Strategies):\na. Linear algebra: Vector and matrix operations, numerical precision/stability, applications in\ndata analytics and machine learning.\nb. Data processing: sorting, searching and retrieval, concurrent data structures.\nc. Graphs, search, and combinatorics: Marking, edge-parallelization, bounding, speculation,\nnetwork-based analytics.\nd. Modeling and simulation: differential equations; randomization, N-body problems, genetic\nalgorithms.\ne. Computational logic: satisfiability (SAT), concurrent logic programming.\nf. Graphics and computational geometry: Transforms, rendering, ray-tracing.\ng. Resource management: Allocating, placing, recycling and scheduling processors, memory,\nchannels, and hosts; exclusive vs shared resources; static, dynamic and elastic algorithms;\nReal-time constraints; Batching, prioritization, partitioning; decentralization via work-stealing\nand related techniques.\nh. Services: Implementing web APIs, electronic currency, transaction systems, multiplayer\ngames."
  },
  {
    "title": "SDF-Fundamentals: Fundamental Programming Concepts and Practices",
    "CS Core": "1. Basic concepts such as variables, primitive data types, expressions, and their evaluation\n230\n2. How imperative programs work: state and state transitions on execution of statements, flow of\ncontrol\n3. Basic constructs such as assignment statements, conditional and iterative statements, basic I/O\n4. Key modularity constructs such as functions (and methods and classes, if supported in the\nlanguage) and related concepts like parameter passing, scope, abstraction, data encapsulation\n(See also: FPL-OOP)\n5. Input and output using files and APIs\n6. Structured data types available in the chosen programming language like sequences (e.g., arrays,\nlists), associative containers (e.g., dictionaries, maps), others (e.g., sets, tuples) and when and how\nto use them (See also: AL-Foundational)\n7. Libraries and frameworks provided by the language (when/where applicable)\n8. Recursion\n9. Dealing with runtime errors in programs (e.g., exception handling).\n10. Basic concepts of programming errors, testing, and debugging (See also: SE-Construction, SEC-\nCoding)\n11. Documenting/commenting code at the program and module level.(See also: SE-Construction)\n12. Develop a security mindset. (See also: SEC-Foundations)"
  },
  {
    "title": "SDF-Data-Structures: Fundamental Data Structures",
    "CS Core": "(See also: AL-Foundational)\n1. Standard abstract data types such as lists, stacks, queues, sets, and maps/dictionaries, including\noperations on them.\n231\n2. Selecting and using appropriate data structures.\n3. Performance implications of choice of data structure(s).\n4. Strings and string processing."
  },
  {
    "title": "SDF-Algorithms: Algorithms",
    "CS Core": "(See also: AL-Foundational, AL-Complexity)\n1. Concept of algorithm and notion of algorithm efficiency\n2. Some common algorithms (e.g., sorting, searching, tree traversal, graph traversal)\n3. Impact of algorithms on time-space efficiency of programs"
  },
  {
    "title": "SDF-Practices: Software Development Practices",
    "CS Core": "(See also: SE-Construction)\n1. Basic testing, including test case design\n2. Use of a general-purpose IDE, including its debugger\n3. Programming style that improves readability\n4. Specifying functionality of a module in a natural language."
  },
  {
    "title": "SDF-SEP: Society, Ethics, and the Profession",
    "CS Core": "1. Intellectual property rights of programmers for programs they develop.\n2. Plagiarism and academic integrity.\n3. Responsibility and liability of programmers regarding code they develop for solutions. (See also:\nSEC-Foundations)\n4. Basic professional work ethics of programmers."
  },
  {
    "title": "SE-Teamwork: Teamwork",
    "CS Core": "1. Effective communication, including oral and written, as well as formal (email, docs, comments,\npresentations) and informal (team chat, meetings). (See also: SEP-Communication)\n2. Common causes of team conflict, and approaches for conflict resolution.\n3. Cooperative programming:\na. Pair programming or Swarming\nb. Code review\nc. Collaboration through version control\n4. Roles and responsibilities in a software team: (See also: SEP-Professional-Ethics)\na. Advantages of teamwork\nb. Risks and complexity of such collaboration\n5. Team processes – responsibilities for tasks, effort estimation, meeting structure, work schedule\n6. Importance of team diversity and inclusivity. (See also: SEP-Communication)",
    "KA Core": "7. Interfacing with stakeholders, as a team:\na. Management & other non-technical teams\nb. Customers\nc. Users\n8. Risks associated with physical, distributed, hybrid, and virtual teams – including communication,\nperception, structure, points of failure, mitigation, and recovery, etc."
  },
  {
    "title": "SE-Tools: Tools and Environments",
    "CS Core": "1. Software configuration management and version control: (See also: SDF-Practices)\na. Configuration in version control, reproducible builds/configuration.\nb. Version control branching strategies. Development branches vs release branches. Trunk-based\ndevelopment.\nc. Merging/rebasing strategies, when relevant.",
    "KA Core": "2. Release management.\n3. Testing tools including static and dynamic analysis tools. (See also: SDF-Practices, SEC-Coding)\n4. Software process automation:\na. Build systems – the value of fast, hermetic, reproducible builds, compare/contrast approaches\nto building a project.\nb. Continuous Integration (CI) – the use of automation and automated tests to do preliminary\nvalidation that the current head/trunk revision builds and passes (basic) tests.\nc. Dependency management – updating external/upstream dependencies, package management,\nSemVer.\n5. Design and communication tools (docs, diagrams, common forms of design diagrams like UML).\n6. Tool integration concepts and mechanisms. (See also: SDF-Practices)\n7. Use of modern IDE facilities – debugging, refactoring, searching/indexing, ML-powered code\nassistants, etc. (See also: SDF-Practices)"
  },
  {
    "title": "SE-Requirements: Product Requirements",
    "KA Core": "1. Describe functional requirements using, for example, use cases or user stories.\na. Using at least one method of documenting and structuring functional requirements.\nb. Understanding how the method supports design and implementation.\nc. Strengths and weaknesses of using a specific approach.\n2. Properties of requirements including consistency, validity, completeness, and feasibility.\n3. Requirements elicitation.\na. Sources of requirements, for example, users, administrators, or support personnel.\nb. Methods of requirement gathering, for example, surveys, interviews, or behavioral analysis.\n4. Non-functional requirements, for example, security, usability, or performance, also called as Quality\nAttributes. (See also: SEP-Sustainability)\n5. Risk identification and management, including ethical considerations surrounding the proposed\nproduct. (See also: SEP-Professional-Ethics)\n6. Communicating and/or formalizing requirement specifications.",
    "Non-core": "7. Prototyping a tool for both eliciting and validating/confirming requirements.\n8. Product evolution: when requirements change, how to understand what effect that has and what\nchanges need to be made.\n9. Effort estimation:\na. Learning techniques for better estimating the effort required to complete a task;\nb. Practicing estimation and comparing it to how long tasks take;\nc. Effort estimation is quite difficult, so students are likely to be way off in many cases, but seeing\nthe process play out with their own work is valuable."
  },
  {
    "title": "SE-Design: Software Design",
    "CS Core": "1. System design principles. (See also: SF-Reliability)\na. Levels of abstraction (e.g., architectural design and detailed design)\nb. Separation of concerns\nc. Information hiding\nd. Coupling and cohesion\n2. Software architecture. (See also: SF-Reliability)\na. Design paradigms\ni. Top-down functional decomposition/layered design\nii. Data-oriented architecture\niii. Object-oriented analysis and design\niv. Event-driven design\nb. Standard architectures (e.g., client-server and microservice architectures including REST\ndiscussions, n-layer, pipes-and-filters, Model View Controller)\nc. Identifying component boundaries and dependencies\n3. Programming in the large vs programming in the small. (See also: SF-Reliability)\n4. Code smells and other indications of code quality, distinct from correctness. (See also: SEC-\nEngineering)",
    "KA Core": "5. API design principles\na. Consistency\ni. Consistent APIs are easier to learn and less error-prone\nii. Consistency is both internal (between different portions of the API) and external (following\ncommon API patterns)\nb. Composability\nc. Documenting contracts\ni. API operations should describe their effect on the system, but not generally their\nimplementation\nii. Preconditions, postconditions, and invariants\n243\nd. Expandability\ne. Error reporting\ni. Errors should be clear, predictable, and actionable\nii. Input that does not match the contract should produce an error\niii. Errors that can be reliably managed without reporting should be managed\n6. Identifying and codifying data invariants and time invariants\n7. Structural and behavioral models of software designs\n8. Data design (See also: DM-Modeling)\na. Data structures\nb. Storage systems\n9. Requirement traceability\na. Understanding which requirements are satisfied by a design\nNon-Core:\n10. Design modeling, for instance with class diagrams, entity relationship diagrams, or sequence\ndiagrams\n11. Measurement and analysis of design quality\n12. Principles of secure design and coding (See also: SEC-Engineering)\na. Principle of least privilege\nb. Principle of fail-safe defaults\nc. Principle of psychological acceptability\n13. Evaluating design tradeoffs (e.g., efficiency vs reliability, security vs usability)"
  },
  {
    "title": "SE-Construction: Software Construction",
    "CS Core": "1. Practical small-scale testing (See also: SDF-Practices)\na. Unit testing\nb. Test-driven development – This is particularly valuable for students psychologically, as it is far\neasier to engage constructively with the challenge of identifying challenging inputs for a given\nAPI (edge cases, corner cases) a priori. If they implement first, the instinct is often to avoid\ntrying to crash their new creation, while a test-first approach gives them the intellectual\nsatisfaction of spotting the problem cases and then watching as more tests pass during the\ndevelopment process.\n2. Documentation (See also: SDF-Practices)\na. Interface documentation – describe interface requirements, potentially including (formal or\ninformal) contracts, pre and post conditions, invariants.\nb. Implementation documentation should focus on tricky and non-obvious pieces of code, whether\nbecause the code is using advanced language features, or the behavior of the code is complex.\n(Do not add comments that re-state common/obvious operations and simple language features.)\ni. Clarify dataflow, computation, etc., focusing on what the code is.\nii. Identify subtle/tricky pieces of code and refactor to be self-explanatory if possible or provide\nappropriate comments to clarify.",
    "KA Core": "3. Coding style (See also: SDF-Practices)\na. Style guides\nb. Commenting\nc. Naming\n4. “Best Practices” for coding: techniques, idioms/patterns, mechanisms for building quality programs\n(See also: SEC-Coding, SDF-Practices)\na. Defensive coding practices\nb. Secure coding practices and principles\nc. Using exception handling mechanisms to make programs more robust, fault-tolerant\n5. Debugging (See also: SDF-Practices)\n6. Logging\n7. Use of libraries and frameworks developed by others (See also: SDF-Practices)\nNon-Core:\n8. Larger-scale testing\na. Test doubles (stubs, mocks, fakes)\nb. Dependency injection\n9. Work sequencing, including dependency identification, milestones, and risk retirement\na. Dependency identification: Identifying the dependencies between different tasks\nb. Milestones: A collection of tasks that serve as a marker of progress when completed. Ideally,\nthe milestone encompasses a useful unit of functionality.\nc. Risk retirement: Identifying what elements of a project are risky and prioritizing completing tasks\nthat address those risks.\n10. Potential security problems in programs (See also: SEC-Coding)\n245\na. Buffer and other types of overflows\nb. Race conditions\nc. Improper initialization, including choice of privileges\nd. Input validation\n11. Documentation (autogenerated)\n12. Development context: “green field” vs existing code base\na. Change impact analysis\nb. Change actualization\n13. Release management\n14. DevOps practices"
  },
  {
    "title": "SE-Validation: Software Verification and Validation",
    "CS Core": "1. Verification and validation concepts\na. Verification: Are we building the thing right?\nb. Validation: Did we build the right thing?\n2. Why testing matters: Does the component remain functional as the code evolves?\n3. Testing objectives\na. Usability\nb. Reliability\nc. Conformance to specification\n246\nd. Performance\ne. Security\n4. Test kinds\na. Unit\nb. Integration\nc. Validation\nd. System\n5. Stylistic differences between tests and production code: DAMP vs DRY – more duplication is\nwarranted in test code.",
    "KA Core": "6. Test planning and generation\na. Test case generation, from formal models, specifications, etc.\nb. Test coverage\ni. Test matrices\nii. Code coverage – how much of the code is tested?\niii. Environment coverage – how many hardware architectures, operating systems, browsers,\netc. are tested?\nc. Test data and inputs\n7. Test development\na. Test-driven development\nb. Object oriented testing, mocking, and dependency injection\nc. Opaque-box (previously, black-box) and transparent-box (previously, white-box) testing\ntechniques\nd. Test tooling, including code coverage, static analysis, and fuzzing\n8. Verification and validation in the development cycle\na. Code reviews\nb. Test automation, including automation of tooling\nc. Pre-commit and post-commit testing\nd. Tradeoffs between test coverage and throughput/latency of testing\ne. Defect tracking and prioritization: reproducibility of reported defects\n9. Domain specific verification and validation challenges\na. Performance testing and benchmarking\nb. Asynchrony, parallelism, and concurrency\nc. Safety-critical\nd. Numeric\nNon-Core:\n10. Verification and validation tooling and automation\na. Static analysis\nb. Code coverage\nc. Fuzzing\nd. Dynamic analysis and fault containment (sanitizers, etc.)\ne. Fault logging and fault tracking\n11. Test planning and generation\n247\na. Fault estimation and testing termination including defect seeding\nb. Use of random and pseudo random numbers in testing\n12. Performance testing and benchmarking\na. Throughput and latency\nb. Degradation under load (stress testing, FIFO vs LIFO handling of requests)\nc. Speedup and scaling\ni. Amdahl’s law\nii. Gustafson's law\niii. Soft and weak scaling\nd. Identifying and measuring figures of merits\ne. Common performance bottlenecks\ni. Compute-bound\nii. Memory-bandwidth bound\niii. Latency-bound\nf. Statistical methods and best practices for benchmarking\ni. Estimation of uncertainty\nii. Confidence intervals\ng. Analysis and presentation (graphs, etc.)\nh. Timing techniques\n13. Testing asynchronous, parallel, and concurrent systems\n14. Verification and validation of non-code artifacts (documentation, training materials)"
  },
  {
    "title": "SE-Refactoring: Refactoring and Code Evolution",
    "KA Core": "1. Hyrum’s Law/The Law of Implicit Interfaces\n2. Backward compatibility\na. Compatibility is not a property of a single entity, it’s a property of a relationship.\nb. Backward compatibility needs to be evaluated in terms of provider + consumer(s) or with a well-\nspecified model of what forms of compatibility a provider aspires to/promises.\n3. Refactoring\na. Standard refactoring patterns (rename, inline, outline, etc.)\nb. Use of refactoring tools in IDE\nc. Application of static-analysis tools (to identify code in need of refactoring, generate changes,\netc.)\nd. Value of refactoring as a remedy for technical debt\n4. Versioning\na. Semantic Versioning (SemVer)\nb. Trunk-based development\nNon-Core:\n5. “Large Scale” Refactoring – techniques when a refactoring change is too large to commit safely\n(large projects), or when it is impossible to synchronize change between provider + all consumers\n(multiple repositories, consumers with private code).\na. Express both old and new APIs so that they can co-exist.\nb. Minimize the size of behavior changes.\n249\nc. Why these techniques are required, (e.g., “API consumers I can see” vs “consumers I can’t\nsee”).",
    "Illustrative Learning Outcomes": "KA-Core:\n1. Identify both explicit and implicit behavior of an interface and identify potential risks from Hyrum’s\nLaw.\n2. Consider inputs from static analysis tools and/or Software Design principles to identify code in need\nof refactoring.\n3. Identify changes that can be broadly considered “backward compatible,” potentially with explicit\nstatements about what usage is or is not supported.\n4. Refactor the implementation of an interface to improve design, clarity, etc. with minimal/zero impact\non existing users.\n5. Evaluate whether a proposed change is sufficiently safe given the versioning methodology in use\nfor a given project.\nNon-Core:\n6. Plan a complex multi-step refactoring to change default behavior of an API safely."
  },
  {
    "title": "SE-Reliability: Software Reliability",
    "KA Core": "1. Concept of reliability as probability of failure or mean time between failures, and faults as cause of\nfailures\n2. Identifying reliability requirements for different kinds of software\n3. Software failures caused by defects/bugs, and so for high reliability the goal is to have minimum\ndefects – by injecting fewer defects (better training, education, planning), and by removing most of\nthe injected defects (testing, code review, etc.)\n4. Software reliability, system reliability and failure behavior\n5. Defect injection and removal cycle, and different approaches for defect removal\n6. Compare the “error budget” approach to reliability with the “error-free” approach and identify\ndomains where each is relevant.\nNon-Core:\n7. Software reliability models\n8. Software fault tolerance techniques and models\na. Contextual differences in fault tolerance (e.g., crashing a flight critical system is strongly\navoided, crashing a data processing system before corrupt data is written to storage is highly\nvaluable)\n9. Software reliability engineering practices – including reviews, testing, practical model checking\n10. Identification of dependent and independent failure domains, and their impact on system reliability\n11. Measurement-based analysis of software reliability – telemetry, monitoring and alerting,\ndashboards, release qualification metrics, etc.\n250"
  },
  {
    "title": "SE-Formal: Formal Methods",
    "Illustrative Learning Outcomes": "1. Describe the role formal specification and analysis techniques can play in the development of\ncomplex software and compare their use as validation and verification techniques with testing.\n2. Apply formal specification and analysis techniques to software designs and programs with low\ncomplexity.\n3. Explain the potential benefits and drawbacks of using formal specification languages.\nProfessional Dispositions\n● Collaborative: Software engineering is increasingly described as a “team sport” – successful\nsoftware engineers are able to work with others effectively. Humility, respect, and trust underpin\nthe collaborative relationships that are essential to success in this field.\n251\n● Professional: Software engineering produces technology that has the chance to influence\nliterally billions of people. Awareness of our role in society, strong ethical behavior, and\ncommitment to respectful day-to-day behavior outside of one’s team are essential.\n● Communicative: No single software engineer on a project is likely to know all the project\ndetails. Successful software projects depend on engineers communicating clearly and regularly\nto coordinate effectively.\n● Meticulous: Software engineering requires attention to detail and consistent behavior from\neveryone on the team. Success in this field is clearly influenced by a meticulous approach -\ncomprehensive understanding, proper procedures, and a solid avoidance of cutting corners.\n● Responsible: The collaborative aspects of software engineering also highlight the value of\nbeing responsible. Failing to take responsibility, failing to follow through, and failing to keep\nothers informed are all classic causes of team friction and bad project outcomes.\nMathematics Requirements\nDesirable:\n● Introductory statistics (performance comparisons, evaluating experiments, interpreting survey\nresults, etc.). (See also CS-Core requirements for MSF-Statistics)\nCourse Packaging Suggestions\nAdvanced Course to include at least the following:\n● SE-Teamwork (4 hours)\n● SE-Tools (4 hours)\n● SE-Requirements (2 hours)\n● SE-Design (5 hours)\n● SE-Construction (4 hours)\n● SE-Validation (4 hours)\n● SE-Refactoring (2 hours)\n● SE-Reliability (2 hours)\n● SEP-Professional-Ethics (7 hours)\nPrerequisites:\n● SDF-Fundamentals\nCourse objectives: Students should be able to perform good quality code review for colleagues\n(especially focusing on professional communication and teamwork needs), read and write unit tests,\nuse basic software tools (IDEs, version control, static analysis tools) and perform basic activities\nexpected of a new hire on a software team.\nCommittee\nChair: Titus Winters, Google, New York City, NY, USA\n252\nMembers:\n● Brett A. Becker, University College Dublin, Dublin, Ireland\n● Adam Vartanian, Cord, London, UK\n● Bryce Adelstein Lelbach, NVIDIA, New York City, NY, USA\n● Patrick Servello, CIWRO, Norman, OK, USA\n● Pankaj Jalote, IIIT-Delhi, Delhi, India\n● Christian Servin, El Paso Community College, El Paso, TX, USA\nContributors:\n● Hyrum Wright, Google, Pittsburgh, PA, USA\n● Olivier Giroux, Apple, Cupertino, CA, USA\n● Gennadiy Civil, Google, New York City, NY, USA\n253\n254\nSecurity (SEC)\nPreamble\nComputing supports nearly every facet of modern critical infrastructure: transportation, communication,\nhealthcare, education, energy generation and distribution, to name a few. With rampant attacks on and\nbreaches of this infrastructure, computer science graduates have an important role in designing,\nimplementing, and operating software systems that are robust, safe, and secure.\nThe Security (SEC) knowledge area focuses on developing a security mindset into the overall ethos of\ncomputer science graduates so that security is embedded in all their work products. Computer science\nstudents need to learn about system vulnerabilities and understand threats against computer systems.\nThe Security title choice was intentional to serve as a one-word umbrella term for this knowledge area,\nwhich also includes concepts to support privacy, cryptography, secure systems, secure data, and\nsecure code.\nThe SEC knowledge area relies on shared concepts pervasive in all the other areas of CS2023. It\nidentifies seven crosscutting concepts of cybersecurity: confidentiality, integrity, availability, risk\nassessment, systems thinking, adversarial thinking, and human-centered thinking. The seventh\nconcept, human-centered thinking, is additional to the six crosscutting concepts originally defined in the\nCybersecurity Curricula 2017 (CSEC2017) [1]. This addition reinforces to students that humans are\nalso a link in the overall chain of security, a theme that is also covered in knowledge areas such as\nHCI. Principles of protecting systems (also in the DM, OS, SDF, SE and SF knowledge areas) include\nsecurity-by-design, privacy-by-design, defense-in-depth, and zero-trust.\nAnother concept is the notion of assurance, which is an attestation that security mechanisms need to\ncomply with the security policies that have been defined for data, processes, and systems. Assurance\nis tied in with the concepts of verification and validation in the SE knowledge area. Considerations of\ndata privacy and security are shared with the DM (technical aspects) and SEP knowledge areas.\nThe SEC knowledge area thus sits atop several of the other CS2023 knowledge areas, while including\nadditional concepts that are not present in those knowledge areas. The specific dependence on other\nknowledge areas is stated below, starting with the Core Hours table. CS2023 treats security as a\ncrucial component of the skillset of any CS graduate, and the hours needed for security preparation\ncome from all the other 16 CS2023 knowledge areas.\nChanges since CS2013\nThe Security knowledge area is an updated name for CS2013’s Information Assurance and Security\n(IAS) knowledge area. Since 2013, Information Assurance and Security has been rebranded as\nCybersecurity, which has become a new computing discipline, with its own curricular guidelines (CSEC\n2017) developed by a Joint Task Force of the ACM, IEEE Computer Society, AIS and IFIP in 2017.\nMoreover, since 2013, other curricular recommendations for cybersecurity beyond CS2013 and CSEC\n2017 have been made. In the US, the National Security Agency recognizes institutions as Centers of\n255\nAcademic Excellence (CAE) in Cyber Defense and/or Cyber Operations if their cybersecurity programs\nmeet the respective CAE curriculum requirements. Additionally, the National Initiative for Cybersecurity\nEducation (NICE) of the US National Institute for Standards and Technologies (NIST) has developed\nand revised the Workforce Framework for Cybersecurity (NICE Workforce Framework), which identifies\ncompetencies (knowledge and skills) needed to perform tasks relevant to cybersecurity work roles. The\nEuropean Cybersecurity Skills Framework (ECSF) includes a standard ontology to describe\ncybersecurity tasks and roles, as well as addressing the cybersecurity personnel shortage in EU\nmember countries. Similarities and differences of these cybersecurity guidelines, viewed from the CS\nperspective, also informed the SEC knowledge area.\nBuilding on CS2013’s recognition of the pervasiveness of security in computer science, the CS2023\nSEC knowledge area focuses on ensuring that students develop a security mindset so that they are\nprepared for the continual changes occurring in computing. One useful addition is the knowledge unit\nfor security analysis, design, and engineering to support the concepts of security-by-design and\nprivacy-by-design.\nThe importance of computer science in ensuring the protection of future computing systems and\nsocietal critical infrastructure will continue to grow. Consequently, it is imperative that faculty teaching\ncomputer science incorporate the latest advances in security and privacy approaches to keep their\ncurriculum current.\nDifferences between CS2023 Security knowledge area and Cybersecurity\nCS2023’s SEC knowledge area focuses on those aspects of security, privacy, and related concepts\nimportant for computer science students. In comparison, CSEC 2017 characterizes similarities and\ndifferences in the cybersecurity book of knowledge using the disciplinary lenses of computer science,\ncomputer engineering, software engineering, information systems, information technology, and other\ndisciplines. In short, the major goal of the SEC knowledge area is to ensure that computer science\ngraduates can design and develop more secure code, ensure data security and privacy, and apply a\nsecurity mindset to their daily activities.\nProtecting what happens within the perimeter of a networked computer system is a core competency of\ncomputer science graduates. Although the computer science and cybersecurity knowledge units\noverlap, the demands upon cybersecurity graduates typically are to protect the perimeter. CSEC 2017\ndefines cybersecurity as a highly interdisciplinary field of study that covers eight areas (data, software,\ncomponent, connection, system, human, organizational, and societal security) and prepares its\nstudents for both technical and managerial roles in cybersecurity.\nThe first five CSEC 2017 areas are technical and have overlaps with the CS2023 SEC knowledge area,\nbut the intent of coverage is substantively different as computer science students bring to bear the core\ncompetencies described in all the 17 CS2023 knowledge areas. For instance, consider the SEC\nknowledge area’s Secure Coding knowledge unit. The computer science student will need to view this\nknowledge unit from a computer science lens, as an extension of the material covered in the SDF, SE,\nand PDC knowledge areas, while the Cybersecurity student will need to view software security in the\noverall context of diverse cybersecurity goals. These viewpoints are not totally distinct and have\n256\noverlaps, but thFFe lenses used to examine and present the content are different. There are similar\ncommonalities aii nd differences among CS2023 SEC knowledge units and corresponding CSEC 2017\ngg\nknowledge units.\nuu\nrr\nCore Hours\nee\n..\nDD\nKnowledgaae Unit CS Core KA Core\ntt\nFoundatioaan al Security 1 + 7 (DM, FPL, PDC, SDF, 7\nSS\nSE, OS)\nee\ncc\nSociety, Ethics, and the Profession 1 + 4 (SEP) 2\nuu\nrr\nSecure Coding 2 + 6 (FPL, SDF, SE) 5\nii\ntt\nCryptograyyp hy 1 + 8 (MSF) 4\n––\nSecurity ACCnalysis, Design, and Engineering 1 + 4 (MSF, SE) 8\nyy\nDigital Fobbrensics 0 6\nee\nSecurity Grrovernance 0 3\nss\nee\nTotal hours 6 35\ncc\nuu\nrr\nii\nThe SEC knowledge area requires approximately 28 hours of CS Core hours from the other knowledge\ntt\nareas, either to yyp rovide the basis or to complement its content. Of these, MSF-Discrete, MSF-\nProbability, andvv MSF-Statistics are likely to be relied upon extensively in all the SEC knowledge units,\nas are SDF-Funeedamentals, SDF-Algorithms, and SDF-Practices. The others are mentioned within each\nrr\nof the SEC knowledge units described below.\nss\nuu\nKnowledgess Units\nCC\nSS"
  },
  {
    "title": "SEC-Foundations: Foundational Security",
    "CS Core": "22\n1. Developing a security mindset incorporating crosscutting concepts: confidentiality, integrity,\n33\navailability, SSrisk assessment, systems thinking, adversarial thinking, human-centered thinking\n2. Basic conceEEpts of authentication and authorization/access control\nCC\n3. Vulnerabilities, threats, attack surfaces, and attack vectors (See also: OS-Protection)\n..\n4. Denial of Service (DoS) and Distributed Denial of Service (DDoS) (See also: OS-Protection)\n((\n5. Principles aOOnd practices of protection, e.g., least privilege, open design, fail-safe defaults, defense\nin depth, anttd zero trust; and how they can be implemented (See also: OS-Principles, OS-\nhh\nProtection, SE-Construction, SEP-Security)\nee\nrr\nkk 257\nnn\noo\nww\nll\nee\n6. Optimization considerations between security, privacy, performance, and other design goals (See\nalso: SDF-Practices, SE-Validation, HCI-Design)\n7. Impact of AI on security and privacy: using AI to bolster defenses as well as address increased\nadversarial capabilities due to AI (See also: AI-SEP, HCI-Design, HCI-SEP)",
    "KA Core": "8. Access control models (e.g., discretionary, mandatory, role-based, and attribute-based)\n9. Security controls\n10. Concepts of trust and trustworthiness\n11. Applications of a security mindset: web, cloud, and mobile devices (See also: SF-System Design,\nSPD-Common)\n12. Protecting embedded and cyber-physical systems (See also: SPD-Embedded)\n13. Principles of usable security and human-centered computing (See also: HCI-Design, SEP-Security)\n14. Security and trust in AI/machine learning systems, e.g., fit for purpose, ethical operating\nboundaries, authoritative knowledge sources, verified training data, repeatable system evaluation\ntests, system attestation, independent validation/certification; unintended consequences from:\nadverse effect (See also: AI-Introduction, AI-ML, AI-SEP, SEP-Security)\n15. Security risks in building and operating AI/machine learning systems (e.g., algorithm bias,\nknowledge corpus bias, training corpus bias, copyright violation) (See also: AI-Introduction, AI-ML,\nAI-SEP)\n16. Hardware considerations in security, e.g., principles of secure hardware, secure processor\narchitectures, cryptographic acceleration, compartmentalization, software-hardware interaction (See\nalso: AR-Assembly, AR-Representation, OS-Purpose)"
  },
  {
    "title": "SEC-SEP: Society, Ethics, and the Profession",
    "CS Core": "1. Principles and practices of privacy (See also: SEP-Security)\n2. Societal impacts on breakdowns in security and privacy (See also: SEP-Context, SEP-Privacy,\nSEP-Security)\n3. Applicability of laws and regulations on security and privacy (See also: SEP-Security)\n4. Professional ethical considerations when designing secure systems and maintaining privacy; ethical\nhacking (See also: SEP-Professional-Ethics, SEP-Privacy, SEP-Security)\nKA-Core:\n258\n5. Security by design (See also: SF-Security, SF-Design)\n6. Privacy by design and privacy engineering (See also: SEP-Privacy, SEP-Security)\n7. Security and privacy implications of malicious AI/machine learning actors, e.g., identifying deep\nfakes (See also: AI-Introduction, AI-ML, SEP-Privacy, SEP-Security)\n8. Societal impacts of Internet of Things (IoT) devices and other emerging technologies on security\nand privacy (See also: SEP-Privacy, SEP-Security)",
    "KA Core": "4. Evaluate the legal ramifications of a system not corresponding to applicable laws and regulations.\n5. Construct a system that is designed to avoid harm to user privacy."
  },
  {
    "title": "SEC-Coding: Secure Coding",
    "CS Core": "1. Common vulnerabilities and weaknesses\n2. SQL injection and other injection attacks\n3. Cross-site scripting techniques and mitigations\n4. Input validation and data sanitization (See also: OS-Protection, SDF-Fundamentals, SE-Validation)\n5. Type safety and type-safe languages (See also: FPL-Types, FPL-Systems, OS-Protection, SDF-\nFundamentals, SE-Validation)\n6. Buffer overflows, stack smashing, and integer overflows (See also: AR-Assembly, FPL-Systems,\nOS-Protection)\n7. Security issues due to race conditions (See also: FPL-Parallel, PDC-Evaluation)",
    "KA Core": "8. Principles of noninterference and nondeducibility\n9. Preventing information flow attacks\n10. Offensive security techniques as a defense\n11. AI-assisted malware detection techniques\n12. Ransomware: creation, prevention, and mitigation\n13. Secure use of third-party components (See also: SE-Construction, SE-Validation)\n14. Malware: varieties, creation, reverse engineering, and defense against them (See also: FPL-\nSystems, FPL-Translation)\n15. Assurance: testing (including fuzzing and penetration testing), verification, and validation (See also:\nOS-Protection, SDF-Fundamentals, SE-Construction, SE-Validation)\n16. Static and dynamic analyses (See also: FPL-Analysis, MSF-Protection, PDC-Evaluation, SE-\nValidation)\n17. Secure compilers and secure code generation (See also: FPL-Runtime, FPL-Translation)",
    "Illustrative Learning Outcomes": "259"
  },
  {
    "title": "SEC-Crypto: Cryptography",
    "CS Core": "1. Differences between algorithmic, applied, and mathematical views of cryptography\n2. Mathematical preliminaries: modular arithmetic, Euclidean algorithm, probabilistic independence,\nlinear algebra basics, number theory, finite fields, complexity, asymptotic analysis (See also: MSF-\nDiscrete, MSF-Linear)\n3. Basic cryptography: symmetric key and public key cryptography (See also: AL-Foundational, MSF-\nDiscrete)\n4. Basic cryptographic building blocks, including symmetric encryption, asymmetric encryption,\nhashing, and message authentication (See also: MSF-Discrete)\n5. Classical cryptosystems, such as shift, substitution, transposition ciphers, code books, and\nmachines (See also: MSF-Discrete)\n6. Kerckhoff’s principle and use of vetted libraries (See also: SE-Construction)\n7. Usage of cryptography in real-world applications, e.g., electronic cash, secure channels between\nclients and servers, secure electronic mail, entity authentication, device pairing, steganography, and\nvoting systems (See also: NC-Security, GIT-Image)",
    "KA Core": "8. Additional mathematics: primality, factoring, and elliptic curve cryptography (See also: MSF-\nDiscrete)\n260\n9. Private-key cryptosystems: substitution-permutation networks, linear cryptanalysis, differential\ncryptanalysis, DES, and AES (See also: MSF-Discrete, NC-Security)\n10. Public-key cryptosystems: Diffie-Hellman and RSA (See also: MSF-Discrete)\n11. Data integrity and authentication: hashing, and digital signatures (See also: MSF-Discrete, DM-\nSecurity)\n12. Cryptographic protocols: challenge-response authentication, zero-knowledge protocols,\ncommitment, oblivious transfer, secure two- or multi-party computation, hash functions, secret\nsharing, and applications (See also: MSF-Discrete)\n13. Attacker capabilities: chosen-message attack (for signatures), birthday attacks, side channel\nattacks, and fault injection attacks (See also: NC-Security)\n14. Quantum cryptography; Post Quantum/Quantum resistant cryptography (See also: AL-\nFoundational, MSF-Discrete)\n15. Blockchain and cryptocurrencies (See also: MSF-Discrete, PDF-Communication)"
  },
  {
    "title": "SEC-Engineering: Security Analysis, Design, and Engineering",
    "CS Core": "1. Security engineering goals: building systems that remain dependable despite errors, accidents, or\nmalicious adversaries (See also: SE-Construction, SE-Validation, SEP-Security)\n2. Privacy engineering goals: building systems that design, implement, and deploy privacy features\nand controls (See also: SEP-Privacy)\n3. Problem analysis and situational analysis to address system security (See also: SE-Validation)\n4. Engineering tradeoff analysis based on time, cost, risk tolerance, risk acceptance, return on\ninvestment, and so on (See also: PDC-Evaluation, SE-Validation)",
    "KA Core": "261\n5. Security design and engineering, including functional requirements, security subsystems,\ninformation protection, security testing, security assessment, and evaluation (See also: PDC-\nEvaluation, SE-Requirements, SE-Validation)\n6. Security analysis, covering security requirements analysis; security controls analysis; threat\nanalysis; and vulnerability analysis (See also: FPL-Analysis, PDC-Evaluation)\n7. Security attack domains and attack surfaces, e.g., communications and networking, hardware,\nphysical, social engineering, software, and supply chain (See also: NC-Security)\n8. Security attack modes, techniques, and tactics, e.g., authentication abuse; brute force; buffer\nmanipulation; code injection; content insertion; denial of service; eavesdropping; function bypass;\nimpersonation; integrity attack; interception; phishing; protocol analysis; privilege abuse; spoofing;\nand traffic injection (See also: NC-Security, OS-Protection, SE-Validation)\n9. Attestation of software products with respect to their specification and adaptiveness (See also: SE-\nRequirements, SE-Validation)\n10. Design and development of cyber-physical systems\n11. Considerations for trustworthy computing, e.g., tamper resistant packaging, trusted boot, trusted\nkernel, hardware root of trust, software signing and verification, hardware-based cryptography,\nvirtualization, and containers (See also: SE-Construction, SE-Validation)"
  },
  {
    "title": "SEC-Forensics: Digital Forensics",
    "KA Core": "1. Basic principles and methodologies for digital forensics\n2. System design for forensics\n3. Forensics in different situations: operating systems, file systems, application forensics, web\nforensics, network forensics, mobile device forensics, use of database auditing (See also: NC-\nSecurity)\n4. Attacks on forensics and preventing such attacks\n5. Incident handling processes\n6. Rules of evidence – general concepts and differences between jurisdictions (See also: SEP-\nSecurity)\n7. Legal issues: digital evidence protection and management, chains of custody, reporting, serving as\nan expert witness (See also: SEP-Security)\n262"
  },
  {
    "title": "SEC-Governance: Security Governance",
    "KA Core": "1. Protecting critical assets from threats\n2. Security governance: organizational objectives and general risk assessment\n3. Security management: achieve and maintain appropriate levels of confidentiality, integrity,\navailability, accountability, authenticity, and reliability (See also: SE-Validation)\n4. Security policy: organizational policies, issue-specific policies, system-specific policies\n5. Approaches to identifying and mitigating risks to computing infrastructure\n6. Data lifecycle management policies: data collection, backups, and retention; cloud storage and\nservices; breach disclosure (See also: DM-Security)"
  },
  {
    "title": "SEP-Context: Social Context",
    "CS Core": "1. Social implications (e.g., political and cultural ideologies) in a hyper-networked world where the\ncapabilities and impact of social media, artificial intelligence, and computing in general are rapidly\nevolving.\n2. Impact of computing applications (e.g., social media, artificial intelligence applications) on individual\nwell-being, and safety of all kinds (e.g., physical, emotional, economic).\n3. Consequences of involving computing technologies, particularly artificial intelligence, biometric\ntechnologies, and algorithmic decision-making systems, in civic life (e.g., facial recognition\ntechnology, biometric tags, resource distribution algorithms, policing software) and how human\nagency and oversight is crucial.\n273\n4. How deficits in diversity and accessibility in computing affect society and what steps can be taken to\nimprove equity in computing.",
    "KA Core": "5. Growth and control of the internet, data, computing, and artificial intelligence\n6. Often referred to as the digital divide, differences in access to digital technology resources and its\nresulting ramifications for gender, class, ethnicity, geography, and/or developing countries,\nincluding consideration of responsibility to those who might be less wealthy, under threat, or who\nwould struggle to have their voices heard.\n7. Accessibility issues, including legal requirements such as Web Content Accessibility Guidelines\n(www.w3.org/TR/WCAG21)\n8. Context-aware computing"
  },
  {
    "title": "SEP-Ethical-Analysis: Methods for Ethical Analysis",
    "CS Core": "1. Avoiding fallacies and misrepresentation in argumentation\n2. Ethical theories and decision-making (philosophical and social frameworks, e.g. [1])\n3. Recognition of the role culture plays in our understanding, adoption, design, and use of computing\ntechnology\n4. Why ethics is important in computing, and how ethics is similar to, and different from, laws and\nsocial norms",
    "KA Core": "5. Professional checklists\n6. Evaluation rubrics\n7. Stakeholder analysis\n8. Standpoint theory\n9. Introduction to ethical frameworks (e.g., consequentialism such as utilitarianism, non-\nconsequentialism such as duty, rights, or justice, agent-centered such as virtue or feminism,\ncontractarianism, ethics of care) and their use for analyzing an ethical dilemma"
  },
  {
    "title": "SEP-Professional-Ethics: Professional Ethics",
    "CS Core": "1. Community values and the laws by which we live\n2. The nature of being a professional including care, attention, discipline, fiduciary responsibility, and\nmentoring\n3. Keeping up to date as a computing professional in terms of familiarity, tools, skills, legal and\nprofessional frameworks as well as the ability and responsibility to self-assess and progress in the\ncomputing field\n4. Professional certification, codes of ethics, conduct, and practice, such as the ACM, IEEE, AAAI,\nand other international societies\n5. Accountability, responsibility, and liability (e.g., software correctness, reliability and safety,\nwarranty, negligence, strict liability, ethical approaches to security vulnerability disclosures)\nincluding whether a product/service should be built, not just doing so because it is technically\npossible.\n6. Introduction to theories describing the human creation and use of technology including\ninstrumentalism, sociology of technological systems, disability justice, neutrality thesis,\npragmatism, and decolonial models, including developing and using technology to right wrongs and\ndo good\n7. Strategies for recognizing and reporting designs, systems, software, and professional conduct (or\ntheir outcomes) that may violate law or professional codes of ethics",
    "KA Core": "8. The role of the computing professional and professional societies in public policy\n9. Maintaining awareness of consequences\n10. Ethical dissent and whistleblowing\n11. The relationship between regional culture and ethical dilemmas\n12. Dealing with harassment and discrimination\n13. Forms of professional credentialing\n14. Ergonomics and healthy computing environments\n15. Time-to-market and cost considerations versus quality professional standards"
  },
  {
    "title": "SEP-IP: Intellectual Property",
    "CS Core": "1. Intellectual property rights\n2. Intangible digital intellectual property (IDIP)\n3. Legal foundations for intellectual property protection\n4. Common software licenses (e.g., MIT, GPL and its variants, Apache, Mozilla, Creative Commons)\n5. Plagiarism and authorship",
    "KA Core": "6. Philosophical foundations of intellectual property\n277\n7. Forms of intellectual property (e.g., copyrights, patents, trade secrets, trademarks) and the rights\nthey protect\n8. Limitations on copyright protections, including fair use and the first sale doctrine\n9. Intellectual property laws and treaties that impact the enforcement of copyrights\n10. Software piracy and technical methods for enforcing intellectual property rights, such as digital\nrights management and closed source software as a trade secret\n11. Moral and legal foundations of the open-source movement\n12. Systems that use others’ data (e.g., large language models)"
  },
  {
    "title": "SEP-Privacy: Privacy and Civil Liberties",
    "CS Core": "1. Privacy implications of widespread data collection including but not limited to transactional\ndatabases, data warehouses, surveillance systems, cloud computing, and artificial intelligence\n2. Conceptions of anonymity, pseudonymity, and identity\n3. Technology-based solutions for privacy protection (e.g., end-to-end encryption and differential\nprivacy)\n4. Civil liberties, privacy rights, and cultural differences",
    "KA Core": "5. Philosophical and legal conceptions of the nature of privacy including the right to privacy\n6. Legal foundations of privacy protection in relevant jurisdictions (e.g., GDPR in the EU)\n7. Privacy legislation in areas of practice (e.g., HIPAA in the US, AI Act in the EU)\n8. Basic Principles of human-subjects research and principles beyond what the law requires (e.g.,\nBelmont Report, UN Universal Declaration on Human Rights and how this relates to technology)\n9. Freedom of expression and its limitations\n10. User-generated content, content moderation, and liability"
  },
  {
    "title": "SEP-Communication: Communication",
    "CS Core": "1. Oral, written, and electronic team and group communication\n2. Technical communication materials (e.g., source code, and documentation, tutorials, reference\nmaterials, API documentation)\n3. Communicating with different stakeholders such as customers, leadership, or the public\n4. Team collaboration (including tools) and conflict resolution\n5. Accessibility and inclusivity requirements for addressing professional audiences\n6. Cultural competence in communication including considering the impact of difference in natural\nlanguage",
    "KA Core": "7. Tradeoffs in competing factors that affect communication channels and choices\n8. Communicating to solve problems or make recommendations in the workplace, such as raising\nethical concerns or addressing accessibility issues"
  },
  {
    "title": "SEP-Sustainability: Sustainability",
    "CS Core": "1. Environmental, social, and cultural impacts of implementation decisions (e.g., sustainability goals,\nalgorithmic bias/outcomes, economic viability, and resource consumption)\n2. Local/regional/global social and environmental impacts of computing systems and their use (e.g.,\ncarbon footprints, resource usage, e-waste) due to hardware (e.g., e-waste, data centers, rare\nelement and resource utilization, recycling) and software (e.g., cloud-based services, blockchain,\nAI model training and use). This includes everyday use of hardware (cheap hardware replaced\nfrequently) and software (web-browsing, email, and other services with hidden/remote\ncomputational demands).\n3. Guidelines for sustainable design standards.",
    "KA Core": "4. Systemic effects of complex computing technologies and phenomena (e.g., generative AI, data\ncenters, social media, offshoring, remote work).\n5. Pervasive computing: Information processing that has been integrated into everyday objects and\nactivities, such as smart energy systems, social networking, and feedback systems to promote\nsustainable behavior, transportation, environmental monitoring, citizen science and activism.\n6. How the sustainability of software systems is interdependent with social systems, including the\nknowledge and skills of its users, organizational processes and policies, and its societal context\n(e.g., market forces, government policies)."
  },
  {
    "title": "SEP-History: Computing History",
    "CS Core": "1. The history of computing: hardware, software, and human/organizational.\n2. The role of history in the present including within different social contexts, and the relevance of this\nhistory on the future.",
    "KA Core": "3. Age I (Pre-digital): Ancient analog computing (Stonehenge, Antikythera mechanism, Salisbury\nCathedral clock, etc.), human-calculated number tables, Euclid, Lovelace, Babbage, Gödel,\nChurch, Turing, pre-electronic (electro-mechanical and mechanical) hardware\n4. Age II (Early modern computing): ENIAC, UNIVAC, Bombes (Bletchley Park and codebreakers),\ncomputer companies (e.g., IBM), mainframes, etc.\n5. Age III (PC era): PCs, modern computer hardware and software, Moore’s Law\n6. Age IV (Internet): Networking, internet architecture, browsers and their evolution, standards, born-\non-the-internet companies, and services (e.g., Google, Amazon, Microsoft, etc.), distributed\ncomputing\n7. Age V (Mobile & Cloud): Mobile computing and smartphones, cloud computing and models thereof\n(e.g., SaaS), remote servers, security and privacy, social media\n8. Age VI (AI): Decision making systems, recommender systems, generative AI and other machine\nlearning driven tools and technologies"
  },
  {
    "title": "SEP-Economies: Economies of Computing",
    "KA Core": "1. Economic models: regulated and unregulated, monopolies, network effects, and open market;\nknowledge and attention economies\n2. Pricing and deployment strategies: planned obsolescence, subscriptions, freemium, software\nlicensing, open-source, free software, adware\n3. Impacts of differences in access to computing resources, and the effect of skilled labor supply and\ndemand on the quality of computing products\n4. Automation, AI, and their effects on job markets, developers, and users\n5. Ethical concerns surrounding the attention economy and other economies of computing (e.g.\ninformed consent, data collection, use of verbose legalese in user agreements)"
  },
  {
    "title": "SEP-Security: Security Policies, Laws and Computer Crimes",
    "CS Core": "1. Computer crimes, legal redress for computer criminals and impact on victims and society\n2. Social engineering, computing-enabled fraud, identity theft and recovery from these\n3. Cyber terrorism, criminal hacking, and hacktivism\n4. Malware, viruses, worms\n5. Attacks on critical infrastructure such as electrical grids and pipelines\n6. Non-technical fundamentals of security (e.g., human engineering, policy, confidentiality)",
    "KA Core": "7. Benefits and challenges of existing and proposed computer crime laws\n8. Security policies and the challenges of change and compliance\n9. Responsibility for security throughout the computing life cycle\n10. International and local laws and how they intersect"
  },
  {
    "title": "SEP-DEIA: Diversity, Equity, Inclusion, and Accessibility",
    "CS Core": "1. How identity impacts and is impacted by computing technologies and environments (academic and\nprofessional)\n2. The benefits of diverse development teams and the impacts of teams that are not diverse\n3. Inclusive language and charged terminology, and why their use matters\n4. Inclusive behaviors and why they matter\n5. Designing and developing technology with accessibility in mind\n6. How computing professionals can influence and impact diversity, equity, inclusion and accessibility,\nincluding but not only through the software they create",
    "KA Core": "7. Experts and their practices that reflect the identities of the classroom and the world through\npractical DEIA principles\n8. Historic marginalization due to systemic social mechanisms, technological supremacy and global\ninfrastructure challenges to diversity, equity, inclusion, and accessibility\n9. Cross-cultural differences in, and needs for, diversity, equity, inclusion, and accessibility\n285"
  },
  {
    "title": "SF-Overview: Overview of Computer Systems",
    "CS Core": "1. Basic building blocks and components of a computer (gates, flip-flops, registers, interconnections;\ndatapath + control + memory)\n2. Hardware as a computational paradigm: Fundamental logic building blocks; Logic expressions,\nminimization, sum of product forms (See also: AR-Logic)\n3. Programming abstractions, interfaces, use of libraries (See also: PDC-Programs)\n4. Distinction and interaction between application and OS services, remote procedure call (See also:\nOS-Purpose)\n5. Basic concept of pipelining, overlapped processing stages (See also: AR-Organization)\n6. Basic concept of scaling: performance vs problem size"
  },
  {
    "title": "SF-Foundations: Basic Concepts",
    "CS Core": "1. Digital vs Analog/Discrete vs Continuous Systems\n2. Simple logic gates, logical expressions, Boolean logic simplification\n3. Clocks, State, Sequencing\n4. State and state transition (e.g., starting state, final state, life cycle of states) (See also: AL-Models)\n5. Finite state machines (e.g., NFA, DFA) (See also: AL-Models)\n6. Combinational Logic, Sequential Logic, Registers, Memories (See also: AR-Logic)\n7. Computers and Network Protocols as examples of State Machines (See also: NC-Fundamentals)\n8. Sequential vs parallel processing. (See also: PDC-Programs, OS-Concurrency)\n9. Application-level sequential processing: single thread (See also: PDC-Programs, OS-Concurrency)\n10. Simple application-level parallel processing: request level (web services/client-server/distributed),\nsingle thread per server, multiple threads with multiple servers, pipelining (See also: PDC-\nPrograms, OS-Concurrency)"
  },
  {
    "title": "SF-Resource: Resource Management",
    "CS Core": "1. Different types of resources (e.g., processor share, memory, disk, net bandwidth) (See also: OS-\nScheduling, OS-Memory, OS-Files, NC-Fundamentals)\n2. Common resource allocation/scheduling algorithms (e.g., first-come-first-serve, priority-based\nscheduling, fair scheduling, and preemptive scheduling) (See also: OS-Scheduling)",
    "KA Core": "3. Advantages and disadvantages of common scheduling algorithms (See also: OS-Scheduling)"
  },
  {
    "title": "SF-Performance: System Performance",
    "CS Core": "1. Latencies in computer systems\na. Speed of light and computers (one foot per nanosecond vs one GHz clocks) (See also: AR-\nOrganization)\nb. Memory vs disk latencies vs across-the-network memory (See also: AR-Memory, AR-\nPerformance-Energy)\n2. Caches and the effects of spatial and temporal locality on performance in processors and systems\n(See also: AR-Memory, AR-Performance-Energy, OS-Memory)\n3. Caches and cache coherency in databases, operating systems, distributed systems, and computer\narchitecture (See also: OS-Memory, AR-Memory, DM-Internals)\n4. Introduction to the processor memory hierarchy (See also: AR-Memory, AR-Performance-Energy)\n294",
    "KA Core": "5. The formula for average memory access time (See also: AR-Memory)\n6. Rationale of virtualization and isolation: protection and predictable performance (See also: OS-\nVirtualization)\n7. Levels of indirection, illustrated by virtual memory for managing physical memory resources (See\nalso: OS-Virtualization)\n8. Methods for implementing virtual memory and virtual machines (See also: OS-Virtualization)"
  },
  {
    "title": "SF-Evaluation: Performance Evaluation",
    "CS Core": "1. Performance figures of merit (See also: AR-Performance-Energy, PDC-Evaluation)\n2. Workloads and representative benchmarks, and methods of collecting and analyzing performance\nfigures of merit (See also: AR-Performance-Energy, PDC-Evaluation)\n3. CPI (Cycles per Instruction) equation as a tool for understanding tradeoffs in the design of\ninstruction sets, processor pipelines, and memory system organizations (See also: AR-\nPerformance-Energy, PDC-Evaluation)\n4. Amdahl’s Law: the part of the computation that cannot be sped up limits the effect of the parts that\ncan (See also: AR-Performance-Energy, PDC-Evaluation)\n5. Order of magnitude analysis (Big O notation) (See also: AL-Complexity)\n6. Analysis of slow and fast paths of a system (See also: AR-Organization)\n7. Events on their effect on performance (e.g., instruction stalls, cache misses, page faults) (See also:\nOS-Memory, AR-Organization)",
    "KA Core": "7. Analytical tools to guide quantitative evaluation\n8. Understanding layered systems, workloads, and platforms, their implications for performance, and\nthe challenges they represent for evaluation\n9. Microbenchmark pitfalls\n295"
  },
  {
    "title": "SF-Reliability: System Reliability",
    "CS Core": "1. Distinction between bugs, faults, and failures (See also: PDC-Coordination, SE-Reliability)\n2. Reliability vs availability\n3. Reliability through redundancy\na. check and retry (See also: OS-Faults, NC-Reliability)\nb. redundant encoding (error correction codes, CRC, FEC, RAID) (See also: AR-Memory, NC-\nReliability, DM-Distributed)\nc. duplication/mirroring/replicas (See also: DM-Distributed)",
    "KA Core": "4. Other approaches to reliability (e.g., journaling) (See also: OS-Faults, NC-Reliability, SE-Reliability)"
  },
  {
    "title": "SF-Security: System Security",
    "CS Core": "1. Common system security issues (e.g., viruses, denial-of-service attacks, and eavesdropping) (See\nalso: OS-Protection, NC-Security, SEC-Foundations, SEC-Engineering)\n2. Countermeasures (See also: OS-Principles, OS-Protection, NC-Security)\na. Cryptography (See also: SEC-Crypto)\nb. Security architecture (See also: SEC-Engineering)",
    "KA Core": "3. Representative countermeasure systems\na. Intrusion detection systems, firewalls (See also: NC-Security)\nb. Antivirus systems"
  },
  {
    "title": "SF-Design: System Design",
    "CS Core": "1. Common criteria of system design (e.g., liveness, safety, robustness, scalability, and security) (See\nalso: PDC-Evaluation)",
    "KA Core": "2. Designs of representative systems (e.g., Apache web server, Spark, and Linux)"
  },
  {
    "title": "SF-SEP: Society, Ethics, and the Profession",
    "KA Core": "1. Intellectual property rights of computer systems (See also: SEP-IP)\n2. Common software licenses (See also: SEP-IP)\n3. Computer crimes (See also: SEP-Security)\n297"
  },
  {
    "title": "SPD-Common: Common Aspects/Shared Concerns",
    "CS Core": "1. Overview of development platforms (i.e., web, mobile, game, robotics, embedded, and interactive).\na. Input/sensors/control devices/haptic devices\nb. Resource constraints\ni. Computational\nii. Data storage\niii. Memory\niv. Communication\nc. Requirements – security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-\nEngineering)\nd. Output/actuators/haptic devices\n2. Programming via platform-specific Application Programming Interface (API) vs traditional\napplication construction\n3. Overview of platform Languages (e.g., Python, Swift, Lua, Kotlin)\n4. Programming under platform constraints and requirements (e.g., available development tools,\ndevelopment, security considerations) (See also: SEC-Foundations)\n5. Techniques for learning and mastering a platform-specific programming language"
  },
  {
    "title": "SPD-Web: Web Platforms",
    "KA Core": "1. Web programming languages (e.g., HTML5, JavaScript, PHP, CSS)\n2. Web platforms, frameworks, or meta-frameworks\na. Cloud services\nb. API, Web Components\n3. Software as a Service (SaaS)\n4. Web standards such as document object model, accessibility (See also: HCI-Accessibility)\n5. Security and Privacy Considerations (See also: SEP-Security)",
    "Non-core": "6. Analyzing requirements for web applications\n7. Computing services (See also: DM-NoSQL)\na. Cloud Hosting\nb. Scalability (e.g., Autoscaling, Clusters)\nc. Cost estimation for services\n8. Data management (See also: DM-Core)\na. Data residency: where the data is located and what paths can be taken to access it\nb. Data integrity: guaranteeing data is accessible and that data is deleted when required\n9. Architecture\na. Monoliths vs Microservices\nb. Micro-frontends\nc. Event-Driven vs RESTful architectures: advantages and disadvantages\nd. Serverless, cloud computing on demand\n10. Storage solutions (See also: DM-Relational, DM-NoSQL)\na. Relational Databases\nb. NoSQL databases"
  },
  {
    "title": "SPD-Mobile: Mobile Platforms",
    "KA Core": "1. Development with\na. Mobile programming languages\n303\nb. Mobile programming environments\n2. Mobile platform constraints\na. User interface design (See also: HCI-User)\nb. Security\n3. Access\na. Accessing data through APIs (See also: DM-Querying)\nb. Designing API endpoints for mobile apps: pitfalls and design considerations\nc. Network and web interfaces (See also: NC-Fundamentals, DM-Modeling)",
    "Non-core": "4. Development\na. Native versus cross-platform development\nb. Software design/architecture patterns for mobile applications (See also: SE-Design)\n5. Mobile platform constraints\na. Responsive user interface design (See also: HCI-Accessibility)\nb. Heterogeneity and mobility of devices\nc. Differences in user experiences (e.g., between mobile and web-based applications)\nd. Power and performance tradeoff\n6. Mobile computing affordances\na. Location-aware applications\nb. Sensor-driven computing (e.g., gyroscope, accelerometer, health data from a watch)\nc. Telephony and instant messaging\nd. Augmented reality (See also: GIT-Immersion)\n7. Specification and testing (See also: SDF-Practices, SE-Validation)\n8. Asynchronous computing (See also: PDC-Algorithms)\na. Difference from traditional synchronous programming\nb. Handling success via callbacks\nc. Handling errors asynchronously\nd. Testing asynchronous code and typical problems in testing"
  },
  {
    "title": "SPD-Robot: Robot Platforms",
    "KA Core": "1. Types of robotic platforms and devices (See also: AI-Robotics)\n2. Sensors, embedded computation, and effectors (actuators) (See also: GIT-Physical)\n3. Robot-specific languages and libraries (See also: AI-Robotics)\n4. Robotic software architecture (e.g., using the Robot Operating System (ROS))\n304\n5. Robotic platform constraints and design considerations (See also: AI-Robotics)\n6. Interconnections with physical or simulated systems (See also: GIT-Physical, GIT-Simulation)\n7. Robotic Algorithms (See also: AI-Robotics, GIT-Animation)\na. Forward kinematics\nb. Inverse kinematics\nc. Dynamics\nd. Navigation and path planning\ne. Grasping and manipulation\n8. Safety and interaction considerations (See also: SEP-Professional-Ethics, SEP-Context)"
  },
  {
    "title": "SPD-Embedded: Embedded Platforms",
    "KA Core": "1. Introduction to the unique characteristics of embedded systems\na. Real-time vs soft real-time and non-real-time systems\nb. Resource constraints, such as memory profiles and deadlines (See also: AR-Memory)\n2. API for custom architectures\na. GPU technology (See also: AR-Heterogeneity, GIT-Shading)\nb. Field Programmable Gate Arrays (FPGA) (See also: AR-Logic)\nc. Cross-platform systems\n3. Embedded Systems\na. Microcontrollers\nb. Interrupts and feedback\nc. Interrupt handlers in high-level languages (See also: SF-Overview)\nd. Hard and soft interrupts and trap-exits (See also: OS-Principles)\ne. Interacting with hardware, actuators, and sensors\nf. Energy efficiency\ng. Loosely timed coding and synchronization\nh. Software adapters\n4. Embedded programming\n5. Hard real-time systems vs soft real-time systems (See also: OS-Real-time)\na. Timeliness\nb. Time synchronization/scheduling\n305\nc. Prioritization\nd. Latency\ne. Compute jitter\n6. Real-time resource management\n7. Memory management\na. Mapping programming construct (variable) to a memory location (See also: AR-Memory)\nb. Shared memory (See also: OS-Memory)\nc. Manual memory management.\nd. Garbage collection (See also: FPL-Translation)\n8. Safety considerations and safety analysis (See also: SEP-Context, SEP-Professional-Ethics)\n9. Sensors and actuators\n10. Analysis and verification\n11. Application design"
  },
  {
    "title": "SPD-Game: Game Platforms",
    "KA Core": "1. Historical and contemporary platforms for games (See also: AR-Logic)\na. Evolution of Game Platforms (e.g., Brown Box to Metaverse and beyond; Improvement in\nComputing Architectures (CPU and GPU); Platform Convergence and Mobility)\nb. Typical Game Platforms (e.g., Personal Computer; Home Console; Handheld Console;\nArcade Machine; Interactive Television; Mobile Phone; Tablet; Integrated Head-Mounted\nDisplay; Immersive Installations and Simulators; Internet of Things enabled Devices; CAVE\nSystems; Web Browsers; Cloud-based Streaming Systems)\nc. Characteristics and Constraints of Different Game Platforms (e.g., Features (local storage,\ninternetworking, peripherals); Run-time performance (GPU/CPU frequency, number of\ncores); Chipsets (physics processing units, vector co-processors); Expansion Bandwidth\n(PCIe); Network throughput (Ethernet); Memory types and capacities (DDR/GDDR);\nMaximum stack depth; Power consumption; Thermal design; Endian)\nd. Typical Sensors, Controllers, and Actuators (e.g., distinctive control system designs –\nperipherals (mouse, keypad, joystick), game controllers, wearables, interactive surfaces;\n306\nelectronics and bespoke hardware; computer vision, inside-out tracking, and outside-in\ntracking; IoT-enabled electronics and I/O (See also: GIT-Interaction)\ne. eSports Ecosystems (e.g., evolution of gameplay across platforms; games and eSports;\ngame events such as LAN/arcade tournaments and international events such as the\nOlympic eSports Series; streamed media and spectatorship; multimedia technologies and\nbroadcast management; professional play; data and machine learning for coaching and\ntraining)\n2. Real-time Simulation and Rendering Systems\na. CPU and GPU architectures (e.g., Flynn’s taxonomy; parallelization; instruction sets;\nstandard components – graphics compute array, graphics memory controller, video graphics\narray basic input/output system; bus interface; power management unit; video processing\nunit; display interface) (See also: AR-Heterogeneity)\nb. Pipelines for physical simulations and graphical rendering: (e.g., tile-based, immediate-\nmode). (See also: GIT-Rendering)\nc. Common Contexts for Algorithms, Data Structures, and Mathematical Functions (e.g., game\nloops; spatial partitioning, viewport culling, and level of detail; collision detection and\nresolution; physical simulation; behavior for intelligent agents; procedural content\ngeneration) (See also: MSF-Discrete, AL-Foundational)\nd. Media representations (e.g., I/O, and computation techniques for virtual worlds: audio;\nmusic; sprites; models and textures; text; dialogue; multimedia (e.g., olfaction, tactile) (See\nalso: GIT-Fundamentals)\n3. Game Development Tools and Techniques\na. Programming Languages (e.g., C++; C#; Lua; Python; JavaScript)\nb. Shader Languages (e.g., HLSL, GLSL; Shader Graph)\nc. Graphics Libraries and APIs (e.g., DirectX; SDL; OpenGL; Metal; Vulkan; WebGL). (See\nalso: GIT-Rendering, HCI-Design)\nd. Common Development Tools and Environments (e.g., IDEs; Debuggers; Profilers; Version\nControl Systems including those handling binary assets; Development Kits and\nProduction/Consumer Kits; Emulators) (See also: SDF-Practices, SE-Tools)\n4. Game Engines\na. Open Game Engines (e.g., Unreal; Unity; Godot; CryEngine; Phyre; Source 2; Pygame and\nRen’Py; Phaser; Twine; Spring RTS)\nb. Techniques (e.g., Ideation, Prototyping, Iterative Design and Implementation, Compiling\nExecutable Builds, Development Operations and Quality Assurance – Play Testing and\nTechnical Testing, Profiling; Optimization, Porting; Internationalization and Localization,\nNetworking) (See also: AR-Performance-Energy, SE-Requirements)\n5. Game Design\na. Vocabulary (e.g., game definitions; mechanics-dynamics-aesthetics model; industry\nterminology; experience design; models of experience and emotion)\nb. Design Thinking and User-Centered Experience Design (e.g., methods of designing games;\niteration, incrementing, and the double-diamond; phases of pre- and post-production; quality\nassurance, including alpha and beta testing; stakeholder and customer involvement;\ncommunity management) (See also: SE-Design)\n307\nc. Genres (e.g., adventure; walking simulator; first-person shooter; real-time strategy;\nmultiplayer online battle arena (MOBA); role-playing game (rpg))\nd. Audiences and Player Taxonomies (e.g., people who play games; diversity and broadening\nparticipation; pleasures, player types, and preferences; Bartle, yee) (See also: HCI-User)\ne. Proliferation of digital game technologies to domains beyond entertainment (e.g., Education\nand Training; Serious Games; Virtual Production; eSports; Gamification; Immersive\nExperience Design; Creative Industry Practice; Artistic Practice; Procedural Rhetoric) (See\nalso: AI-SEP)"
  },
  {
    "title": "SPD-Interactive: Interactive Computing Platforms",
    "Non-core": "1. Data Analysis Platforms\na. Jupyter notebooks; Google Colab; R; SPSS; Observable.\nb. Cloud SQL/data analysis platforms (e.g., BigQuery) (See also: DM-Querying)\ni. Apache Spark\nii. Data Visualizations (See also: GIT-Visualization)\nc. Interactive presentations backed by data\nd. Design tools requiring low-latency feedback loops\ni. Rendering tools\nii. Graphic design tools\n2. Prompt programming\na. Generative AI (e.g., OpenAI’s ChatGPT, OpenAI’s Codex, GitHub’s Copilot) and LLMs are\naccessed/interacted\n308\n3. Quantum Platforms (See also: AR-Quantum)\na. Program quantum logic operators in quantum machines.\nb. Use API for available quantum services\nc. Signal analysis/Fourier analysis/Signal processing (for music composition, audio/RF\nanalysis) (See also: GIT-Image)"
  },
  {
    "title": "SPD-SEP/Web",
    "Non-core": "1. Privacy concerns with mobile apps\n2. Designing for inclusivity and accessibility\n3. Ethical use of AI in mobile apps\n4. Sustainable app development and server hosting\n5. Avoiding spam or intrusive notifications\n6. Addressing cyberbullying and harassment\n7. Promoting positive online communities\n8. Monetization and advertising\n9. Ethical use of gamification"
  }
]