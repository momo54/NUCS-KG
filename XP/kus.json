[
  {
    "title": "AI-Introduction: Fundamental Issues",
    "CS Core": "1. Overview of AI problems, Examples of successful recent AI applications\n2. Definitions of agents with examples (e.g., reactive, deliberative)\n3. What is intelligent behavior?\na. The Turing test and its flaws\nb. Multimodal input and output\nc. Simulation of intelligent behavior\nd. Rational versus non-rational reasoning\n4. Problem characteristics\na. Fully versus partially observable\nb. Single versus multi-agent\nc. Deterministic versus stochastic\nd. Static versus dynamic\ne. Discrete versus continuous\n5. Nature of agents\n67\na. Autonomous, semi-autonomous, mixed-initiative autonomy\nb. Reflexive, goal-based, and utility-based\nc. Decision making under uncertainty and with incomplete information\nd. The importance of perception and environmental interactions\ne. Learning-based agents\nf. Embodied agents\ni. sensors, dynamics, effectors\n6. Overview of AI Applications, growth, and impact (economic, societal, ethics)",
    "KA Core": "7. Practice identifying problem characteristics in example environments\n8. Additional depth on nature of agents with examples\n9. Additional depth on AI Applications, Growth, and Impact (economic, societal, ethics, security)",
    "Non-core": "10. Philosophical issues\n11. History of AI",
    "Illustrative Learning Outcomes": "1. Describe the Turing test and the “Chinese Room” thought experiment.\n2. Differentiate between optimal reasoning/behavior and human-like reasoning/behavior.\n3. Differentiate the terms: AI, machine learning, and deep learning.\n4. Enumerate the characteristics of a specific problem."
  },
  {
    "title": "AI-Search: Search",
    "CS Core": "1. State space representation of a problem\na. Specifying states, goals, and operators\nb. Factoring states into representations (hypothesis spaces)\nc. Problem solving by graph search\ni. e.g., Graphs as a space, and tree traversals as exploration of that space\nii. Dynamic construction of the graph (not given upfront)\n2. Uninformed graph search for problem solving (See also: AL-Foundational)\na. Breadth-first search\nb. Depth-first search\ni. With iterative deepening\nc. Uniform cost search\n3. Heuristic graph search for problem solving (See also: AL-Strategies)\na. Heuristic construction and admissibility\nb. Hill-climbing\nc. Local minima and the search landscape\ni. Local vs global solutions\nd. Greedy best-first search\ne. A* search\n68\n4. Space and time complexities of graph search algorithms",
    "KA Core": "5. Bidirectional search\n6. Beam search\n7. Two-player adversarial games\na. Minimax search\nb. Alpha-beta pruning\ni. Ply cutoff\n8. Implementation of A* search\n9. Constraint satisfaction",
    "Non-core": "10. Understanding the search space\na. Constructing search trees\nb. Dynamic search spaces\nc. Combinatorial explosion of search space\nd. Search space topology (e.g., ridges, saddle points, local minima)\n11. Local search\n12. Tabu search\n13. Variations on A* (IDA*, SMA*, RBFS)\n14. Two-player adversarial games\na. The horizon effect\nb. Opening playbooks/endgame solutions\nc. What it means to “solve” a game (e.g., checkers)\n15. Implementation of minimax search, beam search\n16. Expectimax search (MDP-solving) and chance nodes\n17. Stochastic search\na. Simulated annealing\nb. Genetic algorithms\nc. Monte-Carlo tree search",
    "Illustrative Learning Outcomes": "1. Design the state space representation for a puzzle (e.g., N-queens or 3-jug problem)\n2. Select and implement an appropriate uninformed search algorithm for a problem (e.g., tic-tac-toe),\nand characterize its time and space complexities.\n3. Select and implement an appropriate informed search algorithm for a problem after designing a\nhelpful heuristic function (e.g., a robot navigating a 2D gridworld).\n4. Evaluate whether a heuristic for a given problem is admissible/can guarantee an optimal solution.\n5. Apply minimax search in a two-player adversarial game (e.g., connect four), using heuristic\nevaluation at a particular depth to compute the scores to back up. [KA Core]\n6. Design and implement a genetic algorithm solution to a problem.\n7. Design and implement a simulated annealing schedule to avoid local minima in a problem.\n69\n8. Design and implement A*/beam search to solve a problem, and compare it against other search\nalgorithms in terms of the solution cost, number of nodes expanded, etc.\n9. Apply minimax search with alpha-beta pruning to prune search space in a two-player adversarial\ngame (e.g., connect four).\n10. Compare and contrast genetic algorithms with classic search techniques, explaining when it is most\nappropriate to use a genetic algorithm to learn a model versus other forms of optimization (e.g.,\ngradient descent).\n11. Compare and contrast various heuristic searches vis-a-vis applicability to a given problem.\n12. Model a logic or Sudoku puzzle as a constraint satisfaction problem, solve it with backtrack search,\nand determine how much arc consistency can reduce the search space."
  },
  {
    "title": "AI-KRR: Fundamental Knowledge Representation and Reasoning",
    "CS Core": "1. Types of representations\na. Symbolic, logical\ni. Creating a representation from a natural language problem statement\nb. Learned subsymbolic representations\nc. Graphical models (e.g., naive Bayes, Bayesian network)\n2. Review of probabilistic reasoning, Bayes theorem (See also: MSF-Probability)\n3. Bayesian reasoning\na. Bayesian inference",
    "KA Core": "4. Random variables and probability distributions\na. Axioms of probability\nb. Probabilistic inference\nc. Bayes’ Rule (derivation)\nd. Bayesian inference (more complex examples)\n5. Independence\n6. Conditional Independence\n7. Markov chains and Markov models\n8. Utility and decision making",
    "Illustrative Learning Outcomes": "1. Given a natural language problem statement, encode it as a symbolic or logical representation.\n2. Explain how we can make decisions under uncertainty, using concepts such as Bayes theorem and\nutility.\n3. Compute a probabilistic inference in a real-world problem using Bayes’ theorem to determine the\nprobability of a hypothesis given evidence.\n4. Apply Bayes’ rule to determine the probability of a hypothesis given evidence.\n5. Compute the probability of outcomes and test whether outcomes are independent.\n70"
  },
  {
    "title": "AI-ML: Machine Learning",
    "CS Core": "1. Definition and examples of a broad variety of machine learning tasks\na. Supervised learning\ni. Classification\nii. Regression\nb. Reinforcement learning\nc. Unsupervised learning\ni. Clustering\n2. Fundamental ideas:\na. No free lunch theorem: no one learner can solve all problems; representational design decisions\nhave consequences.\nb. Sources of error and undecidability in machine learning\n3. A simple statistical-based supervised learning such as linear regression or decision trees\na. Focus on how they work without going into mathematical or optimization details; enough to\nunderstand and use existing implementations correctly\n4. The overfitting problem/controlling solution complexity (regularization, pruning – intuition only)\na. The bias (underfitting) – variance (overfitting) tradeoff\n5. Working with Data\na. Data preprocessing\ni. Importance and pitfalls of preprocessing choices\nb. Handling missing values (imputing, flag-as-missing)\ni. Implications of imputing vs flag-as-missing\nc. Encoding categorical variables, encoding real-valued data\nd. Normalization/standardization\ne. Emphasis on real data, not textbook examples\n6. Representations\na. Hypothesis spaces and complexity\nb. Simple basis feature expansion, such as squaring univariate features\nc. Learned feature representations\n7. Machine learning evaluation\na. Separation of train, validation, and test sets\nb. Performance metrics for classifiers\nc. Estimation of test performance on held-out data\nd. Tuning the parameters of a machine learning model with a validation set\ne. Importance of understanding what a model is doing, where its pitfalls/shortcomings are, and the\nimplications of its decisions\n8. Basic neural networks\na. Fundamentals of understanding how neural networks work and their training process, without\ndetails of the calculations\nb. Basic introduction to generative neural networks (e.g., large language models)\n9. Ethics for Machine Learning (See also: SEP-Context)\na. Focus on real data, real scenarios, and case studies\nb. Dataset/algorithmic/evaluation bias and unintended consequences\n71",
    "KA Core": "10. Formulation of simple machine learning as an optimization problem, such as least squares linear\nregression or logistic regression\na. Objective function\nb. Gradient descent\nc. Regularization to avoid overfitting (mathematical formulation)\n11. Ensembles of models\na. Simple weighted majority combination\n12. Deep learning\na. Deep feed-forward networks (intuition only, no mathematics)\nb. Convolutional neural networks (intuition only, no mathematics)\nc. Visualization of learned feature representations from deep nets\nd. Other architectures (generative NN, recurrent NN, transformers, etc.)\n13. Performance evaluation\na. Other metrics for classification (e.g., error, precision, recall)\nb. Performance metrics for regressors\nc. Confusion matrix\nd. Cross-validation\ni. Parameter tuning (grid/random search, via cross-validation)\n14. Overview of reinforcement learning methods\n15. Two or more applications of machine learning algorithms\na. E.g., medicine and health, economics, vision, natural language, robotics, game play\n16. Ethics for Machine Learning\na. Continued focus on real data, real scenarios, and case studies (See also: SEP-Context)\nb. Privacy (See also: SEP-Privacy)\nc. Fairness (See also: SEP-Privacy)\nd. Intellectual property\ne. Explainability",
    "Non-core": "17. General statistical-based learning, parameter estimation (maximum likelihood)\n18. Supervised learning\na. Decision trees\nb. Nearest-neighbor classification and regression\nc. Learning simple neural networks / multi-layer perceptrons\nd. Linear regression\ne. Logistic regression\nf. Support vector machines (SVMs) and kernels\ng. Gaussian Processes\n19. Overfitting\na. The curse of dimensionality\nb. Regularization (mathematical computations, L and L regularization)\n2 1\n20. Experimental design\n72\na. Data preparation (e.g., standardization, representation, one-hot encoding)\nb. Hypothesis space\nc. Biases (e.g., algorithmic, search)\nd. Partitioning data: stratification, training set, validation set, test set\ne. Parameter tuning (grid/random search, via cross-validation)\nf. Performance evaluation\ni. Cross-validation\nii. Metric: error, precision, recall, confusion matrix\niii. Receiver operating characteristic (ROC) curve and area under ROC curve\n21. Bayesian learning (Cross-Reference AI/Reasoning Under Uncertainty)\na. Naive Bayes and its relationship to linear models\nb. Bayesian networks\nc. Prior/posterior\nd. Generative models\n22. Deep learning\na. Deep feed-forward networks\nb. Neural tangent kernel and understanding neural network training\nc. Convolutional neural networks\nd. Autoencoders\ne. Recurrent networks\nf. Representations and knowledge transfer\ng. Adversarial training and generative adversarial networks\nh. Attention mechanisms\n23. Representations\na. Manually crafted representations\nb. Basis expansion\nc. Learned representations (e.g., deep neural networks)\n24. Unsupervised learning and clustering\na. K-means\nb. Gaussian mixture models\nc. Expectation maximization (EM)\nd. Self-organizing maps\n25. Graph analysis (e.g., PageRank)\n26. Semi-supervised learning\n27. Graphical models (See also: AI-Probability)\n28. Ensembles\na. Weighted majority\nb. Boosting/bagging\nc. Random forest\nd. Gated ensemble\n29. Learning theory\na. General overview of learning theory / why learning works\nb. VC dimension\nc. Generalization bounds\n73\n30. Reinforcement learning\na. Exploration vs exploitation tradeoff\nb. Markov decision processes\nc. Value and policy iteration\nd. Policy gradient methods\ne. Deep reinforcement learning\nf. Learning from demonstration and inverse RL\n31. Explainable / interpretable machine learning\na. Understanding feature importance (e.g., LIME, Shapley values)\nb. Interpretable models and representations\n32. Recommender systems\n33. Hardware for machine learning\na. GPUs / TPUs\n34. Application of machine learning algorithms to:\na. Medicine and health\nb. Economics\nc. Education\nd. Vision\ne. Natural language\nf. Robotics\ng. Game play\nh. Data mining (Cross-reference DM/Data Analytics)\n35. Ethics for Machine Learning\na. Continued focus on real data, real scenarios, and case studies (See also: SEP-Context)\nb. In depth exploration of dataset/algorithmic/evaluation bias, data privacy, and fairness (See also:\nSEP-Privacy, SEP-Context)\nc. Trust / explainability",
    "Illustrative Learning Outcomes": "1. Describe the differences among the three main styles of learning (supervised, reinforcement, and\nunsupervised) and determine which is appropriate to a particular problem domain.\n2. Differentiate the terms of AI, machine learning, and deep learning.\n3. Frame an application as a classification problem, including the available input features and output\nto be predicted (e.g., identifying alphabetic characters from pixel grid input).\n4. Apply two or more simple statistical learning algorithms to a classification task and measure the\nclassifiers’ accuracy.\n5. Identify overfitting in the context of a problem and learning curves and describe solutions to\noverfitting.\n6. Explain how machine learning works as an optimization/search process.\n7. Implement a statistical learning algorithm and the corresponding optimization process to train the\nclassifier and obtain a prediction on new data.\n8. Describe the neural network training process and resulting learned representations.\n74\n9. Explain proper ML evaluation procedures, including the differences between training and testing\nperformance, and what can go wrong with the evaluation process leading to inaccurate reporting of\nML performance.\n10. Compare two machine learning algorithms on a dataset, implementing the data preprocessing and\nevaluation methodology (e.g., metrics and handling of train/test splits) from scratch.\n11. Visualize the training progress of a neural network through learning curves in a well-established\ntoolkit (e.g., TensorBoard) and visualize the learned features of the network.\n12. Compare and contrast several learning techniques (e.g., decision trees, logistic regression, naive\nBayes, neural networks, and belief networks), providing examples of when each strategy is\nsuperior.\n13. Evaluate the performance of a simple learning system on a real-world dataset.\n14. Characterize the state of the art in learning theory, including its achievements and shortcomings.\n15. Explain the problem of overfitting, along with techniques for detecting and managing the problem.\n16. Explain the triple tradeoff among the size of a hypothesis space, the size of the training set, and\nperformance accuracy.\n17. Given a real-world application of machine learning, describe ethical issues regarding the choices of\ndata, preprocessing steps, algorithm selection, and visualization/presentation of results."
  },
  {
    "title": "AI-SEP: Applications and Societal Impact",
    "CS Core": "1. At least one application of AI to a specific problem and field, such as medicine, health,\nsustainability, social media, economics, education, robotics, etc. (choose at least one for the CS\nCore).\na. Formulating and evaluating a specific application as an AI problem\ni. How to deal with underspecified or ill-posed problems\nb. Data availability/scarcity and cleanliness\ni. Basic data cleaning and preprocessing\nii. Data set bias\nc. Algorithmic bias\nd. Evaluation bias\ne. Assessment of societal implications of the application\n2. Deployed deep generative models\na. High-level overview of deep image generative models (e.g., as of 2023, DALL-E, Midjourney,\nStable Diffusion, etc.), their uses, and their shortcomings/pitfalls.\nb. High-level overview of large language models (e.g., as of 2023, ChatGPT, Bard, etc.), their\nuses, and their shortcomings/pitfalls.\n3. Overview of societal impact of AI\n75\na. Ethics (See also: SEP-Context)\nb. Fairness (See also: SEP-Privacy, SEP-DEIA)\nc. Trust/explainability (See also: SEP-Context)\nd. Privacy and usage of training data (See also: SEP-Privacy)\ne. Human autonomy and oversight/regulations/legal requirements (See also: SEP-Context)\nf. Sustainability (See also: SEP-Sustainability)",
    "KA Core": "4. One or more additional applications of AI to a broad set of problems and diverse fields, such as\nmedicine, health, sustainability, social media, economics, education, robotics, etc. (choose a\ndifferent area from that chosen for the CS Core).\na. Formulating and evaluating a specific application as an AI problem\ni. How to deal with underspecified or ill-posed problems\nb. Data availability/scarcity and cleanliness\ni. Basic data cleaning and preprocessing\nii. Data set bias\nc. Algorithmic bias\nd. Evaluation bias\ne. Assessment of societal implications of the application\n5. Additional depth on deployed deep generative models\na. Introduction to how deep image generative models work, (e.g., as of 2023, DALL-E, Midjourney,\nStable Diffusion) including discussion of attention\nb. Introduction to how large language models work, (e.g., as of 2023, ChatGPT, Bard) including\ndiscussion of attention\nc. Idea of foundational models, how to use them, and the benefits/issues with training them from\nbig data\n6. Analysis and discussion of the societal impact of AI\na. Ethics (See also: SEP-Context)\nb. Fairness (See also: SEP-Privacy, SEP-DEIA)\nc. Trust/explainability (See also: SEP-Context)\nd. Privacy and usage of training data (See also: SEP-Privacy)\ne. Human autonomy and oversight/regulations/legal requirements (See also: SEP-Context)\nf. Sustainability (See also: SEP-Sustainability)",
    "Illustrative Learning Outcomes": "1. Given a real-world application domain and problem, formulate an AI solution to it, identifying proper\ndata/input, preprocessing, representations, AI techniques, and evaluation metrics/methodology.\n2. Analyze the societal impact of one or more specific real-world AI applications, identifying issues\nregarding ethics, fairness, bias, trust, and explainability.\n3. Describe some of the failure modes of current deep generative models for language or images, and\nhow this could affect their use in an application."
  },
  {
    "title": "AI-LRR: Logical Representation and Reasoning",
    "Non-core": "76\n1. Review of propositional and predicate logic (See also: MSF-Discrete)\n2. Resolution and theorem proving (propositional logic only)\na. Forward chaining, backward chaining\n3. Knowledge representation issues\na. Description logics\nb. Ontology engineering\n4. Semantic web\n5. Non-monotonic reasoning (e.g., non-classical logics, default reasoning)\n6. Argumentation\n7. Reasoning about action and change (e.g., situation and event calculus)\n8. Temporal and spatial reasoning\n9. Logic programming\na. Prolog, Answer Set Programming\n10. Rule-based Expert Systems\n11. Semantic networks\n12. Model-based and Case-based reasoning",
    "Illustrative Learning Outcomes": "1. Translate a natural language (e.g., English) sentence into a predicate logic statement.\n2. Convert a logic statement into clausal form.\n3. Apply resolution to a set of logic statements to answer a query.\n4. Compare and contrast the most common models used for structured knowledge representation,\nhighlighting their strengths and weaknesses.\n5. Identify the components of non-monotonic reasoning and its usefulness as a representational\nmechanism for belief systems.\n6. Compare and contrast the basic techniques for representing uncertainty.\n7. Compare and contrast the basic techniques for qualitative representation.\n8. Apply situation and event calculus to problems of action and change.\n9. Explain the distinction between temporal and spatial reasoning, and how they interrelate.\n10. Explain the difference between rule-based, case-based, and model-based reasoning techniques.\n11. Define the concept of a planning system and how it differs from classical search techniques.\n12. Describe the differences between planning as search, operator-based planning, and propositional\nplanning, providing examples of domains where each is most applicable.\n13. Explain the distinction between monotonic and non-monotonic inference."
  },
  {
    "title": "AI-Probability: Probabilistic Representation and Reasoning",
    "Non-core": "1. Conditional Independence review\n2. Knowledge representations\na. Bayesian Networks\ni. Exact inference and its complexity\nii. Markov blankets and d-separation\niii. Randomized sampling (Monte Carlo) methods (e.g., Gibbs sampling)\nb. Markov Networks\n77\nc. Relational probability models\nd. Hidden Markov Models\n3. Decision Theory\na. Preferences and utility functions\nb. Maximizing expected utility\nc. Game theory",
    "Illustrative Learning Outcomes": "1. Compute the probability of a hypothesis given the evidence in a Bayesian network.\n2. Explain how conditional independence assertions allow for greater efficiency of probabilistic\nsystems.\n3. Identify examples of knowledge representations for reasoning under uncertainty.\n4. State the complexity of exact inference. Identify methods for approximate inference.\n5. Design and implement at least one knowledge representation for reasoning under uncertainty.\n6. Describe the complexities of temporal probabilistic reasoning.\n7. Design and implement an HMM as one example of a temporal probabilistic system.\n8. Describe the relationship between preferences and utility functions.\n9. Explain how utility functions and probabilistic reasoning can be combined to make rational\ndecisions."
  },
  {
    "title": "AI-Planning: Planning",
    "Non-core": "1. Review of propositional and first-order logic\n2. Planning operators and state representations\n3. Total order planning\n4. Partial-order planning\n5. Plan graphs and GraphPlan\n6. Hierarchical planning\n7. Planning languages and representations\na. PDDL\n8. Multi-agent planning\n9. MDP-based planning\n10. Interconnecting planning, execution, and dynamic replanning\na. Conditional planning\nb. Continuous planning\nc. Probabilistic planning",
    "Illustrative Learning Outcomes": "1. Construct the state representation, goal, and operators for a given planning problem.\n2. Encode a planning problem in PDDL and use a planner to solve it.\n3. Given a set of operators, initial state, and goal state, draw the partial-order planning graph and\ninclude ordering constraints to resolve all conflicts.\n4. Construct the complete planning graph for GraphPlan to solve a given problem.\n78"
  },
  {
    "title": "AI-Agents: Agents and Cognitive Systems",
    "Non-core": "1. Agent architectures (e.g., reactive, layered, cognitive)\n2. Agent theory (including mathematical formalisms)\n3. Rationality, Game Theory\na. Decision-theoretic agents\nb. Markov decision processes (MDP)\nc. Bandit algorithms\n4. Software agents, personal assistants, and information access\na. Collaborative agents\nb. Information-gathering agents\nc. Believable agents (synthetic characters, modeling emotions in agents)\n5. Learning agents\n6. Cognitive systems\na. Cognitive architectures (e.g., ACT-R, SOAR, ICARUS, FORR)\nb. Capabilities (e.g., perception, decision making, prediction, knowledge maintenance)\nc. Knowledge representation, organization, utilization, acquisition, and refinement\nd. Applications and evaluation of cognitive systems\n7. Multi-agent systems\na. Collaborating agents\nb. Agent teams\nc. Competitive agents (e.g., auctions, voting)\nd. Swarm systems and biologically inspired models\ne. Multi-agent learning\n8. Human-agent interaction (See also: HCI-User, HCI-Accessibility)\na. Communication methodologies (verbal and non-verbal)\nb. Practical issues\nc. Applications\ni. Trading agents, supply chain management\nii. Ethical issues of AI interactions with humans\niii. Regulation and legal requirements of AI systems for interacting with humans",
    "Illustrative Learning Outcomes": "1. Characterize and contrast the standard agent architectures.\n2. Describe the applications of agent theory to domains such as software agents, personal assistants,\nand believable agents, and discuss associated ethical implications.\n3. Describe the primary paradigms used by learning agents.\n4. Demonstrate using appropriate examples how multi-agent systems support agent interaction.\n5. Construct an intelligent agent using a well-established cognitive architecture (ACT-R, SOAR) for\nsolving a specific problem."
  },
  {
    "title": "AI-NLP: Natural Language Processing",
    "Non-core": "79\n1. Deterministic and stochastic grammars\n2. Parsing algorithms\na. CFGs and chart parsers (e.g., CYK)\nb. Probabilistic CFGs and weighted CYK\n3. Representing meaning/Semantics\na. Logic-based knowledge representations\nb. Semantic roles\nc. Temporal representations\nd. Beliefs, desires, and intentions\n4. Corpus-based methods\n5. N-grams and HMMs\n6. Smoothing and backoff\n7. Examples of use: POS tagging and morphology\n8. Information retrieval (See also: DM-Unstructured)\na. Vector space model\ni. TF & IDF\nb. Precision and recall\n9. Information extraction\n10. Language translation\n11. Text classification, categorization\na. Bag of words model\n12. Deep learning for NLP (See also: AI-ML)\na. RNNs\nb. Transformers\nc. Multi-modal embeddings (e.g., images + text)\nd. Generative language models",
    "Illustrative Learning Outcomes": "1. Define and contrast deterministic and stochastic grammars, providing examples to show the\nadequacy of each.\n2. Simulate, apply, or implement classic and stochastic algorithms for parsing natural language.\n3. Identify the challenges of representing meaning.\n4. List the advantages of using standard corpora. Identify examples of current corpora for a variety of\nNLP tasks.\n5. Identify techniques for information retrieval, language translation, and text classification.\n6. Implement a TF/IDF transform, use it to extract features from a corpus, and train an off-the-shelf\nmachine learning algorithm using those features to do text classification."
  },
  {
    "title": "AI-Robotics: Robotics",
    "Non-core": "1. Overview: problems and progress\na. State-of-the-art robot systems, including their sensors and an overview of their sensor\nprocessing\n80\nb. Robot control architectures, e.g., deliberative vs reactive control and Braitenberg vehicles\nc. World modeling and world models\nd. Inherent uncertainty in sensing and in control\n2. Sensors and effectors\na. Sensors: e.g., LIDAR, sonar, vision, depth, stereoscopic, event cameras, microphones, haptics,\nb. Effectors: e.g., wheels, arms, grippers\n3. Coordinate frames, translation, and rotation (2D and 3D)\n4. Configuration space and environmental maps\n5. Interpreting uncertain sensor data\n6. Localization and mapping\n7. Navigation and control\n8. Forward and inverse kinematics\n9. Motion path planning and trajectory optimization\n10. Manipulation and grasping\n11. Joint control and dynamics\n12. Vision-based control\n13. Multiple-robot coordination and collaboration\n14. Human-robot interaction (See also: HCI-User, HCI-Accessibility)\na. Shared workspaces\nb. Human-robot teaming and physical HRI\nc. Social assistive robots\nd. Motion/task/goal prediction\ne. Collaboration and communication (explicit vs implicit, verbal or symbolic vs non-verbal or visual)\nf. Trust\n15. Applications and Societal, Economic, and Ethical Issues\na. Societal, economic, right-to-work implications\nb. Ethical and privacy implications of robotic applications\nc. Liability in autonomous robotics\nd. Autonomous weapons and ethics\ne. Human oversight and control",
    "Illustrative Learning Outcomes": "(Note: Due to the expense of robot hardware, all of these could be done in simulation or\nwith low-cost educational robotic platforms.)\n1. List capabilities and limitations of today's state-of-the-art robot systems, including their sensors and\nthe crucial sensor processing that informs those systems.\n2. Integrate sensors, actuators, and software into a robot designed to undertake a specific task.\n3. Program a robot to accomplish simple tasks using deliberative, reactive, and/or hybrid control\narchitectures.\n4. Implement fundamental motion planning algorithms within a robot configuration space.\n5. Characterize the uncertainties associated with common robot sensors and actuators; articulate\nstrategies for mitigating these uncertainties.\n6. List the differences among robots' representations of their external environment, including their\nstrengths and shortcomings.\n81\n7. Compare and contrast at least three strategies for robot navigation within known and/or unknown\nenvironments, including their strengths and shortcomings.\n8. Describe at least one approach for coordinating the actions and sensing of several robots to\naccomplish a single task.\n9. Compare and contrast a multi-robot coordination and a human-robot collaboration approach and\nattribute their differences to differences between the problem settings.\n10. Analyze the societal, economic, and ethical issues of a real-world robotics application."
  },
  {
    "title": "AI-Vision: Perception and Computer Vision",
    "Non-core": "1. Computer vision\na. Image acquisition, representation, processing, and properties\nb. Shape representation, object recognition, and segmentation\nc. Motion analysis\nd. Generative models\n2. Audio and speech recognition\n3. Touch and proprioception\n4. Other modalities (e.g., olfaction)\n5. Modularity in recognition\n6. Approaches to pattern recognition (See also: AI-ML)\na. Classification algorithms and measures of classification quality\nb. Statistical techniques\nc. Deep learning techniques",
    "Illustrative Learning Outcomes": "1. Summarize the importance of image and object recognition in AI and indicate several significant\napplications of this technology.\n2. List at least three image-segmentation approaches, such as thresholding, edge-based and region-\nbased algorithms, along with their defining characteristics, strengths, and weaknesses.\n3. Implement 2d object recognition based on contour-based and/or region-based shape\nrepresentations.\n4. Distinguish the goals of sound-recognition, speech-recognition, and speaker-recognition and\nidentify how the raw audio signal will be handled differently in each of these cases.\n5. Provide at least two examples of a transformation of a data source from one sensory domain to\nanother, e.g., tactile data interpreted as single-band 2d images.\n6. Implement a feature-extraction algorithm on real data, e.g., an edge or corner detector for images\nor vectors of Fourier coefficients describing a short slice of audio signal.\n7. Implement an algorithm combining features into higher-level percepts, e.g., a contour or polygon\nfrom visual primitives or phoneme hypotheses from an audio signal.\n8. Implement a classification algorithm that segments input percepts into output categories and\nquantitatively evaluates the resulting classification.\n9. Evaluate the performance of the underlying feature-extraction, relative to at least one alternative\npossible approach (whether implemented or not) in its contribution to the classification task (8),\nabove.\n82\n10. Describe at least three classification approaches, their prerequisites for applicability, their strengths,\nand their shortcomings.\n11. Implement and evaluate a deep learning solution to problems in computer vision, such as object or\nscene recognition.\nProfessional Dispositions\n● Meticulousness: Since attention must be paid to details when implementing AI and machine\nlearning algorithms, students must be meticulous about detail.\n● Persistence: AI techniques often operate in partially observable environments and optimization\nprocesses may have cascading errors from multiple iterations. Getting AI techniques to work\npredictably takes trial and error, and repeated effort. These call for persistence on the part of the\nstudent.\n● Inventive: Applications of AI involve creative problem formulation and application of AI techniques,\nwhile balancing application requirements and societal and ethical issues.\n● Responsible: Applications of AI can have significant impacts on society, affecting both individuals\nand large populations. This calls for students to understand the implications of work in AI to society,\nand to make responsible choices for when and how to apply AI techniques.\nMathematics Requirements\nRequired:\n● Algebra\n● Precalculus\n● Discrete Math (See also: MSF-Discrete)\no sets, relations, functions, graphs\no predicate and first-order logic, logic-based proofs\n● Linear Algebra (See also: MSF-Linear)\no Matrix operations, matrix algebra\no Basis sets\n● Probability and Statistics (See also: MSF-Statistics)\no Basic probability theory, conditional probability, independence\no Bayes theorem and applications of Bayes theorem\no Expected value, basic descriptive statistics, distributions\no Basic summary statistics and significance testing\no All should be applied to real decision-making examples with real data, not “textbook”\nexamples.\nDesirable:\n● Calculus-based probability and statistics\n● Calculus: single-variable and partial derivatives\n● Other topics in probability and statistics\no Hypothesis testing, data resampling, experimental design techniques\n● Optimization\n● Linear algebra (all other topics)\n83\nCourse Packaging Suggestions\nArtificial Intelligence to include the following:\n● AI-Introduction (4 hours)\n● AI-Search (9 hours)\n● AI-KRR (4 hours)\n● AI-ML (12 hours)\n● AI-Probability (5 hours)\n● AI-SEP (4 hours –integrated throughout the course)\nPrerequisites:\n● SDF-Fundamentals\n● SDF-Data-Structures\n● SDF-Algorithms\n● MSF-Discrete\n● MSF-Probability\nCourse objective: A student who completes this course should understand the basic areas of AI and\nbe able to understand, develop, and apply techniques in each. They should be able to solve problems\nusing search techniques, basic Bayesian reasoning, and simple machine learning methods. They\nshould understand the various applications of AI and associated ethical and societal implications.\nMachine Learning to include the following:\n● AI-ML (32 hours)\n● AI-KRR (4 hours)\n● AI-NLP (4 hours – selected topics, e.g., TF-IDF, bag of words, and text classification)\n● AI-SEP (4 hours – should be integrated throughout the course)\nPrerequisites:\n● SDF-Fundamentals\n● SDF-Data-Structures\n● SDF-Algorithms\n● MSF-Discrete\n● MSF-Probability\n● MSF-Statistics\n● MSF-Linear (optional)\nCourse objective: A student who completes this course should be able to understand, develop, and\napply mechanisms for supervised, unsupervised, and reinforcement learning. They should be able to\nselect the proper machine learning algorithm for a problem, preprocess the data appropriately, apply\nproper evaluation techniques, and explain how to interpret the resulting models, including the model's\nshortcomings. They should be able to identify and compensate for biased data sets and other sources\nof error and be able to explain ethical and societal implications of their application of machine learning\nto practical problems.\nRobotics to include the following:\n● AI-Robotics (25 hours)\n84\n● SPD-Robot (4 hours – focusing on hardware, constraints/considerations, and software\narchitectures; other topics in SPD/Robot Platforms that overlap with AI/Robotics)\n● AI-Search (4 hours – selected topics well-integrated with robotics, e.g., A* and path search)\n● AI-ML (6 hours – selected topics well-integrated with robotics, e.g., neural networks for object\nrecognition)\n● AI-SEP (3 hours – integrated throughout the course; robotics is already a huge application, so\nthis really should focus on societal impact and specific robotic applications).\nPrerequisites:\n● SDF-Fundamentals\n● SDF-Data-Structures\n● SDF-Algorithms\n● MSF-Linear\nCourse objective: A student who completes this course should be able to understand and use robotic\ntechniques to perceive the world using sensors, localize the robot based on features and a map, and\nplan paths and navigate in the world in simple robot applications. They should understand and be able\nto apply simple computer vision, motion planning, and forward and inverse kinematics techniques.\nIntroduction to Data Science to include the following:\n● GIT-Visualization (6 hours) – types of visualization, libraries, foundations\n● GIT-SEP (2 hours) – ethically responsible visualization\n● DM-Core (2 hours) – Parallel and distributed processing (MapReduce, cloud frameworks, etc.)–\n● DM-Modeling (2 hours) – Graph representations, entity resolution\n● DM-Querying (4 hours) – SQL, query formation\n● DM-NoSQL (2 hours) – Graph DBs, data lakes, data consistency\n● DM-Security (2 hours) – privacy, personally identifying information and its protection\n● DM-Analytics (1 hour) – exploratory data techniques, data science lifecycle\n● DM-SEP (2 hours) – Data provenance\n● AI-ML (15 hours) – Data preprocessing, missing data imputation, supervised/semi-\nsupervised/unsupervised learning, text analysis, graph analysis and PageRank, experimental\nmethodology, evaluation, and ethics\n● AI-SEP (3 hours) – Applications specific to data science, interspersed throughout the course\n● MSF-Statistics (3 hours) – Statistical analysis, hypothesis testing, experimental design\nPrerequisites:\n● SDF-Fundamentals\nCourse objective: A student who completes this course should be able to formulate questions as data\nanalysis problems, understand and use statistical techniques to achieve that analysis from real data,\napply visualization techniques to convey the results, and analyze the ethical and societal implications of\ndata science applications. Students should also be able to understand and effectively use data\nmanagement techniques for preprocessing, storage, security, and retrieval of data in current systems.\nCommittee\nChair: Eric Eaton, University of Pennsylvania, Philadelphia, PA, USA\n85\nMembers:\n● Zachary Dodds, Harvey Mudd College, Claremont, CA, USA\n● Susan L. Epstein, Hunter College and The Graduate Center of The City University of New York,\nNew York, NY, USA\n● Laura Hiatt, US Naval Research Laboratory, Washington, DC, USA\n● Amruth N. Kumar, Ramapo College of New Jersey, Mahwah, NJ, USA\n● Peter Norvig, Google, Mountain View, CA, USA\n● Meinolf Sellmann, GE Research, Niskayuna, NY, USA\n● Reid Simmons, Carnegie Mellon University, Pittsburgh, PA, USA\nContributors:\n● Nate Derbinsky, Northeastern University, Boston, MA, USA\n● Eugene Freuder, Insight Centre for Data Analytics, University College Cork, Cork, Ireland\n● Ashok Goel, Georgia Institute of Technology, Atlanta, GA, USA\n● Claudia Schulz, Thomson Reuters, Zurich, Switzerland\n86\nAlgorithmic Foundations (AL)\nPreamble\nAlgorithms and data structures are fundamental to computer science, since every theoretical\ncomputation and applied program consists of algorithms that operate on data elements possessing\nsome underlying structure. Selecting appropriate computational solutions to real-world problems\nbenefits from understanding the theoretical and practical capabilities and limitations of available\nalgorithms and paradigms, including their impact on the environment and society. Moreover, this\nunderstanding provides insight into the intrinsic nature of computation, computational problems, and\ncomputational problem-solving as well as possible solution techniques independent of programming\nlanguage, programming paradigm, computer hardware, or other implementation aspects.\nThis knowledge area focuses on the nature of computation including the concepts and skills required to\ndesign and analyze algorithms for solving real-world computational problems. It complements the\nimplementation of algorithms and data structures found in the Software Development Foundations\n(SDF) knowledge area. As algorithms and data structures are essential in all advanced areas of\ncomputer science, this area provides the algorithmic foundations that every computer science graduate\nis expected to know. Exposure to the breadth of these foundational AL topics is designed to provide\nstudents with the basis for studying these topics in more depth, for studying additional computation and\nalgorithm topics, and for learning advanced algorithms across a variety of CS knowledge areas and\nCS+X disciplines.\nChanges since CS2013\nThis area has been renamed from Algorithms and Complexity to better reflect its foundational scope\nsince topics in this area focus on the practical and theoretical foundations of algorithms, complexity,\nand computability. These topics also provide the foundational prerequisites for advanced study in\ncomputer science. Additionally, topics focused on complexity and computability have been cleanly\nseparated into respective knowledge units. To reinforce the important impact of computation on society,\na Society, Ethics, and the Profession (AL-SEP) knowledge unit has been added with the expectation\nthat SEP implications be addressed in some manner during every lecture hour of focus in this AL\nknowledge area.\nThe increase of four CS Core hours acknowledges the importance of this foundational area in the CS\ncurriculum and returns it to the 2001 level (less than one course). Despite this increase, there is a\nsignificant overlap in hours with the Software Development Fundamentals (SDF) and Mathematical\nFoundations (MSF) areas. There is also a complementary nature of the units in this area since, for\nexample, while linear search of an array covers topics in AL-Foundational, it can be used to\nsimultaneously explain AL-Complexity O(n) and AL-Strategies Brute-Force topics.\nThe KA topics and hours primarily reflect topics studied in a stand-alone computational theory course\nand the availability of additional hours when such a course is included in the curriculum.\n87\nCore Hours\nKnowledge Unit CS Core KA Core\nFoundational Data Structures and Algorithms 11 6\nAlgorithmic Strategies 6\nComplexity Analysis 6 3\nComputational Models and Formal Languages 9 23\nSociety, Ethics, and the Profession Included in SEP hours\nTotal 32 32\nThe 11 CS Core hours in Foundational Data Structures and Algorithms are in addition to 9\nhours counted in SDF and 3 hours counted in MSF.\nKnowledge Units"
  },
  {
    "title": "AL-Foundational: Foundational Data Structures and Algorithms",
    "CS Core: (See also: SDF-Data-Structures, SDF-Algorithms)": "1. Abstract Data Type (ADT) and operations on an ADT (See also: FPL-Types)\na. Dictionary operations (insert, delete, find)\n2. Arrays\na. Numeric vs non-numeric, character strings\nb. Single (vector) vs multidimensional (matrix)\n3. Records/Structs/Tuples and Objects (See also: FPL-OOP)\n4. Linked lists (for historical reasons)\na. Single vs Double and Linear vs Circular\n5. Stacks\n6. Queues and deques\na. Heap-based priority queue\n7. Hash tables/maps\na. Collision resolution and complexity (e.g., probing, chaining, rehash)\n8. Graphs (e.g., [un]directed, [a]cyclic, [un]connected, and [un]weighted)\n(See also: MSF-Discrete)\na. Graph representation: adjacency list vs matrix\n9. Trees (See also: MSF-Discrete)\na. Binary, n-ary, and search trees\nb. Balanced (e.g., AVL, Red-Black, Heap)\n10. Sets (See also: MSF-Discrete)\n88\n11. Search algorithms\na. O(n) complexity (e.g., linear/sequential array/list search)\nb. O(log n) complexity (e.g., binary search)\n2\nc. O(log n) complexity (e.g., uninformed depth/breadth-first tree search)\nb\n12. Sorting algorithms (e.g., stable, unstable)\na. O(n2) complexity (e.g., insertion, selection),\nb. O(n log n) complexity (e.g., quicksort, merge, timsort)\n13. Graph algorithms\na. Shortest path (e.g., Dijkstra’s, Floyd’s)\nb. Minimal spanning tree (e.g., Prim’s, Kruskal’s)",
    "KA Core": "14. Sorting algorithms\na. O(n log n) complexity heapsort\nb. Pseudo O(n) complexity (e.g., bucket, counting, radix)\n15. Graph algorithms\na. Transitive closure (e.g., Warshall’s)\nb. Topological sort\n16. Matching\na. Efficient string matching (e.g., Boyer-Moore, Knuth-Morris-Pratt)\nb. Longest common subsequence matching\nc. Regular expression matching",
    "Non-core": "17. Cryptography algorithms (e.g., SHA-256) (See also: SEC-Crypto)\n18. Parallel algorithms (See also: PDC-Algorithms, FPL-Parallel)\n19. Consensus algorithms (e.g., Blockchain) (See also: SEC-Crypto)\na. Proof of work vs proof of stake (See also: SEP-Sustainability)\n20. Quantum computing algorithms (See also: AL-Models, AR-Quantum)\na. Oracle-based (e.g., Deutsch-Jozsa, Bernstein-Vazirani, Simon)\nb. Superpolynomial speed-up via QFT (e.g., Shor’s)\nc. Polynomial speed-up via amplitude amplification (e.g., Grover’s)\n21. Fast-Fourier Transform (FFT) algorithm\n22. Differential evolution algorithm",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. For each ADT/Data-Structure in this unit\na. Explain its definition, properties, representation(s), and associated ADT operations.\nb. Explain step-by-step how the ADT operations associated with the data structure transform it.\n2. For each algorithm in this unit explain step-by-step how the algorithm operates.\n3. For each algorithmic approach (e.g., sorting) in this unit apply a prototypical example of the\napproach (e.g., merge sort).\n89\n4. Given requirements for a problem, develop multiple solutions using various data structures and\nalgorithms. Subsequently, evaluate the suitability, strengths, and weaknesses selecting an\napproach that best satisfies the requirements.\n5. Explain how collision avoidance and collision resolution is handled in hash tables.\n6. Explain factors beyond computational efficiency that influence the choice of algorithms, such as\nprogramming time, maintainability, and the use of application-specific patterns in the input data.\n7. Explain the heap property and the use of heaps as an implementation of a priority queue.",
      "KA Core": "8. For each of the algorithms and algorithmic approaches in the KA Core topics:\na. Explain a prototypical example of the algorithm, and\nb. Explain step-by-step how the algorithm operates.",
      "Non-core": "9. An appreciation of quantum computation and its application to certain problems."
    }
  },
  {
    "title": "AL-Strategies: Algorithmic Strategies",
    "CS Core": "1. Paradigms\na. Brute-Force (e.g., linear search, selection sort, traveling salesperson, knapsack)\nb. Decrease-and-Conquer\ni. By a Constant (e.g., insertion sort, topological sort),\nii. By a Constant Factor (e.g., binary search),\niii. By a Variable Size (e.g., Euclid’s)\nc. Divide-and-Conquer (e.g., binary search, quicksort, mergesort, Strassen’s)\nd. Greedy (e.g., Dijkstra’s, Kruskal’s, Knapsack)\ne. Transform-and-Conquer\ni. Instance simplification (e.g., find duplicates via list presort)\nii. Representation change (e.g., heapsort)\niii. Problem reduction (e.g., least-common-multiple, linear programming)\niv. Dynamic programming (e.g., Floyd’s, Warshall, Bellman-Ford)\nf. Space vs time tradeoffs (e.g., hashing)\n2. Handling exponential growth (e.g., heuristic A*, branch-and-bound, backtracking)\n3. Iteration vs recursion (e.g., factorial, tree search)",
    "KA Core": "4. Paradigms\na. Approximation algorithms\nb. Iterative improvement (e.g., Ford-Fulkerson, simplex)\nc. Randomized/Stochastic algorithms (e.g., max-cut, balls and bins)",
    "Non-core": "5. Quantum computing\n90",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. For each of the paradigms in this unit,\na. Explain its definitional characteristics,\nb. Explain an example that demonstrates the paradigm including how this example satisfies the\nparadigm’s characteristics.\n2. For each of the algorithms in the AL-Foundational unit, explain the paradigm used by the algorithm\nand how it exemplifies this paradigm.\n3. Given an algorithm, explain the paradigm used by the algorithm and how it exemplifies this\nparadigm.\n4. Give a real-world problem, evaluate appropriate algorithmic paradigms and algorithms from these\nparadigms that address the problem including evaluating the tradeoffs among the paradigms and\nalgorithms selected.\n5. Give examples of iterative and recursive algorithms that solve the same problem, explain the\nbenefits and disadvantages of each approach.\n6. Evaluate whether a greedy approach leads to an optimal solution.\n7. Explain various approaches for addressing computational problems whose algorithmic solutions are\nexponential."
    }
  },
  {
    "title": "AL-Complexity: Complexity",
    "CS Core": "1. Complexity Analysis Framework\na. Best, average, and worst-case performance of an algorithm\nb. Empirical and relative (Order of Growth) measurements\nc. Input size and primitive operations\nd. Time and space efficiency\n2. Asymptotic complexity analysis (average and worst-case bounds)\na. Big-O, Big-Omega, and Big-Theta formal notations\nb. Foundational Complexity Classes and Representative Examples/Problems\ni. O(1) Constant (e.g., array access)\nii. O(log n) Logarithmic (e.g., binary search)\n2\niii. O(n) Linear (e.g., linear search)\niv. O(n log n) Log Linear (e.g., mergesort)\n2\nv. O(n2) Quadratic (e.g., selection sort)\nvi. O(nc) Polynomial (e.g., O(n3) Gaussian elimination)\nvii. O(2n) Exponential (e.g., Knapsack, Satisfiability (SAT),\nTraveling Sales-Person (TSP), all subsets)\nviii. O(n!) Factorial (e.g., Hamiltonian circuit, all permutations)\n3. Empirical measurements of performance\n4. Tractability and intractability\na. P, NP, and NP-Complete Complexity Classes\nb. NP-Complete Problems (e.g., SAT, Knapsack, TSP)\nc. Reductions\n5. Time and space tradeoffs in algorithms\n91",
    "KA Core": "6. Little-o, Little-Omega, and Little Theta notations\n7. Formal recursive analysis\n8. Amortized analysis\n9. Turing Machine-based models of complexity\na. Time complexity\ni. P, NP, NP-C, and EXP classes\nii. Cook-Levin theorem\nb. Space Complexity\ni. NSpace and PSpace\nii. Savitch’s theorem",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Prepare a presentation that explains to first year students the basic concepts of algorithmic\ncomplexity including best, average, and worst-case algorithm behavior, Big- O, Omega, and Theta\nnotations, complexity classes, time and space tradeoffs, empirical measurement, and impact on\npractical problems.\n2. Using examples, explain each of the foundational complexity classes in this unit.\n3. For each foundational complexity class in this unit, explain an algorithm that demonstrates the\nassociated runtime complexity.\n4. For each algorithm in the AL-Foundational unit, explain its runtime complexity class and why it\nbelongs to this class.\n5. Informally evaluate the foundational complexity class of simple algorithms.\n6. Given a problem to program for which there may be several algorithmic approaches, evaluate them\nand determine which are feasible, and select one that is optimal in implementation and run-time\nbehavior.\n7. Develop empirical studies to determine and validate hypotheses about the runtime complexity of\nvarious algorithms by running algorithms on input of various sizes and comparing actual\nperformance to the theoretical analysis.\n8. Explain examples that illustrate time-space tradeoffs of algorithms.\n9. Explain how tree balance affects the efficiency of binary search tree operations.\n10. Explain to a non-technical audience the significance of tractable versus intractable algorithms using\nan intuitive explanation of Big-O complexity.\n11. Explain the significance of NP-Completeness.\n12. Explain how NP-Hard is a lower bound and NP is an upper bound for NP-Completeness.\n13. Explain examples of NP-complete problems.",
      "KA Core": "14. Use recurrence relations to evaluate the time complexity of recursively defined algorithms.\n15. Apply elementary recurrence relations using a form of the Master Theorem.\n16. Apply Big-O notation to give upper case bounds on time/space complexity of algorithms.\n17. Explain the Cook-Levin Theorem and the NP-Completeness of SAT.\n92\n18. Explain the classes P and NP.\n19. Prove that a problem is NP-Complete by reducing a classic known NP-C problem to it (e.g., 3SAT\nand Clique).\n20. Explain the P-space class and its relation to the EXP class."
    }
  },
  {
    "title": "AL-Models: Computational Models and Formal Languages",
    "CS Core": "1. Formal automata\na. Finite State\nb. Pushdown\nc. Linear Bounded\nd. Turing Machine\n2. Formal languages, grammars and Chomsky Hierarchy\n(See also: FPL-Translation, FPL-Syntax)\na. Regular (Type-3)\ni. Regular Expressions\nb. Context-Free (Type-2)\nc. Context-Sensitive (Type-1)\nd. Recursively Enumerable (Type-0)\n3. Relations among formal automata, languages, and grammars\n4. Decidability, (un)computability, and halting\n5. The Church-Turing thesis\n6. Algorithmic correctness\na. Invariants (e.g., in iteration, recursion, tree search)",
    "KA Core": "7. Deterministic and nondeterministic automata\n8. Pumping Lemma proofs\na. Proof of Finite State/Regular-Language limitation\nb. Pushdown Automata/Context-Free-Language limitation\n9. Decidability\na. Arithmetization and diagonalization\n10. Reducibility and reductions\n11. Time complexity based on Turing Machine\n12. Space complexity (e.g., Pspace, Savitch’s Theorem)\n13. Equivalent models of algorithmic computation\na. Turing Machines and Variations (e.g., multi-tape, non-deterministic)\nb. Lambda Calculus (See also: FPL-Functional)\nc. Mu-Recursive Functions",
    "Non-core": "14. Quantum computation (See also: AR-Quantum)\na. Postulates of quantum mechanics\ni. State space\n93\nii. State evolution\niii. State composition\niv. State measurement\nb. Column vector representations of qubits\nc. Matrix representations of quantum operations\nd. Simple quantum gates (e.g., XNOT, CNOT)",
    "Illustrative Learning Outcomes": {
      "KA Core": "11. For each formal automaton in this unit explain (compare/contrast) its deterministic and\nnondeterministic capabilities.\n12. Apply pumping lemmas, or alternative means, to prove the limitations of Finite State and Pushdown\nautomata.\n13. Apply arithmetization and diagonalization to prove the Halting Problem for Turing Machines is\nUndecidability.\n14. Given a known undecidable language, apply a mapping reduction or computational history to prove\nthat another language is undecidable.\n15. Convert among equivalently powerful notations for a language, including among DFAs, NFAs, and\nregular expressions, and between PDAs and CFGs.\n16. Explain Rice’s theorem and its significance.\n94\n17. Explain an example proof of a problem that is uncomputable by reducing a classic known\nuncomputable problem to it.\n18. Explain the Primitive and General Recursive functions (zero, successor, selection, primitive\nrecursion, composition, and Mu), their significance, and Turing Machine implementations.\n19. Explain how computation is performed in Lambda Calculus (e.g., Alpha conversion and Beta\nreduction)",
      "Non-core": "20. For a quantum system give examples that explain the following postulates.\na. State Space – system state represented as a unit vector in Hilbert space,\nb. State Evolution – the use of unitary operators to evolve system state,\nc. State Composition – the use of tensor product to compose systems states,\nd. State Measurement – the probabilistic output of measuring a system state.\n21. Explain the operation of a quantum XNOT or CNOT gate on a quantum bit represented as a matrix\nand column vector, respectively."
    }
  },
  {
    "title": "AL-SEP: Society, Ethics, and the Profession",
    "CS Core: (See also: SEP-Context, SEP-Sustainability)": "1. Social, ethical, and secure algorithms\n2. Algorithmic fairness\n3. Anonymity (e.g., Differential Privacy)\n4. Accountability/Transparency\n5. Responsible algorithms\n6. Economic and other impacts of inefficient algorithms\n7. Sustainability",
    "KA Core": "8. Context aware computing",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Develop algorithmic solutions to real-world societal problems, such as routing an ambulance to a\nhospital.\n2. Explain the impact that an algorithm may have on the environment and society when used to solve\na real-world problem while considering its sustainability and that it can affect different societal\ngroups in different ways.\n3. Prepare a presentation that justifies the selection of appropriate data structures and/or algorithms to\nsolve a given real-world problem.\n4. Explain an example that articulates how differential privacy protects knowledge of an individual’s\ndata.\n5. Explain the environmental impacts of design choices that relate to algorithm design.\n6. Explain the tradeoffs involved in proof-of-work and proof-of-stake algorithms.\n95\nProfessional Dispositions\n● Meticulous: As an algorithm is a formal solution to a computational problem, attention to detail\nis important when developing and combining algorithms.\n● Persistent: As developing algorithmic solutions to computational problems can be challenging,\ncomputer scientists must be resolute in pursuing such solutions.\n● Inventive: As computer scientists develop algorithmic solutions to real-world problems, they\nmust be inventive in developing solutions to these problems.\nMathematics Requirements\nRequired:\n● MSF-Discrete\nCourse Packaging Suggestions\nAs depicted in the following figure, the committee envisions two common approaches for addressing\nfoundational AL topics in CS courses. Both approaches included the required introductory\nProgramming (CS1) and Data Structures (CS2) courses. In a three-course approach, all CS Core\ntopics are covered with additional unused hours to cover other topics. Alternatively, in the four-course\napproach, the AL-Model knowledge unit CS and KA Core topics are addressed in a Computational\nTheory focused course, which leaves room to address additional KA topics in the third Algorithms\ncourse. Both approaches assume Big-O analysis is introduced in the Data Structures (CS2) course and\nthat graphs are taught in the third Algorithms course. The committee recognizes that there are many\ndifferent approaches for packaging AL topics into courses including, for example, introducing graphs in\nCS2 Data Structures, backtracking in an AI course, and AL-Model topics in a theory course that also\naddresses, for instance, FPL topics. The given example is simply one way to cover the entire AL CS\nCore in three introductory courses with additional lecture hours to spare.\nCourses Common to Three and Four Course Exemplars\nProgramming 1 (CS1)\n● AL-Foundational (2 hours)\n○ Arrays and Strings\n○ Search Algorithms (e.g., O(n) Linear Search)\n96\n● AL-SEP (In SEP hours)\nNote: the following AL topics are demonstrated in CS1, but not explicitly taught as such:\n● AL-Strategies (less than hour)\n○ Brute Force (e.g., linear search)\n○ Iteration (e.g., linear search)\n● AL-Complexity (less than 1 hour)\n○ Foundational Complexity Classes\n■ O(1) Constant and O(n) Linear runtime complexities\nCourse objectives: Students should be able to explain, evaluate, and apply arrays in a variety of\nproblem-solving contexts including using linear search for elements in an array. They should also be\nable to begin to explain the impact algorithmic design and use has on society.\nData Structures (CS2)\n● AL-Foundational (12 hours)\n○ Abstract Data Types and Operations (ADTs)\n○ Binary Search\n○ Multi-dimensional Arrays\n○ Linked Lists\n○ Hash Tables/Maps including conflict resolution strategies\n○ Records/Structs/Tuples and Objects\n○ Sets\n○ Stacks, Queues, and Deques\n○ Trees: Binary, Ordered, Breadth- and Depth-first search\n○ Search Algorithms (e.g., O(n2) Selection Sort, O(log n) binary search)\n2\n○ Sorting Algorithms (e.g., O(n log n) Mergesort, O(log n) tree search)\nb\n● AL-Strategies (3 hours)\n○ Brute Force (e.g., selection sort)\n○ Decrease-and-Conquer (e.g., depth/breadth tree search)\n○ Divide-and-Conquer (e.g., mergesort, quicksort)\n○ Iteration vs Recursion (e.g., factorial, tree search)\n○ Space vs Time tradeoff (e.g., hashing)\n● AL-Complexity (3 hours)\n○ Complexity Analysis Framework\n○ Foundational Complexity Classes\n■ O(log n) Logarithmic, O(n log n) Log Linear, and O(n2) Quadratic\n2 2\n○ Time and Space Tradeoffs in Algorithms\n● AL-SEP (In SEP hours)\nCourse objectives: Students should be able to explain, evaluate, and apply the specified data\nstructures and algorithms in a variety of problem-solving contexts. Additionally, they should be able\ndemonstrate the use of different data structures, algorithms, and algorithmic strategies (paradigms) to\n97\nsolve the same problem. Also, they will continue to enhance and refine their understanding of the\nimpact that algorithmic design and use has on society.\nThree Course Exemplar Approach\nAlgorithms-C\n● AL-Foundational (3 hours)\n○ Graphs including Graph Algorithms\n● AL-Complexity (3 hours)\n○ Asymptotic Complexity Analysis\n○ Foundational Complexity Classes\n■ O(2n) Exponential and O(n!) Factorial\n○ Empirical Measurements of Performance\n○ Tractability and Intractability\n● AL-Strategies (3 hours)\n○ Brute Force (e.g., traveling salesperson, knapsack)\n○ Decrease-and-Conquer (e.g., topological sort)\n○ Divide-and-Conquer (e.g., Strassen’s)\n○ Greedy (e.g., Dijkstra’s, Kruskal’s)\n○ Transform-and-Conquer/Reduction (e.g., heapsort, trees (2-3, AVL, Red-Black))\n■ Dynamic Programming (e.g., Warshall’s, Floyd’s, Bellman-Ford)\n○ Handling Exponential Growth (e.g., heuristic A*, branch-and-bound, backtracking)\n● AL-Models (9 hours)\n○ All CS Core topics\n● AL-SEP (In SEP hours)\nCourse objectives: Students should be able to explain, evaluate, and apply the specified data\nstructures and algorithms in a variety of problem-solving contexts. Additionally, they should be able to\nformally explain complexity analysis and the importance of tractability including approaches for handling\nintractable problems. Finally, they should also be able to summarize formal models of computation,\ngrammars, and languages including the definition of a computer as a Turing Machine and the\nundecidability of the Halting problem.\nFour Course Exemplar Approach\nAlgorithms-C (third course)\n● AL-Foundational (3 hours)\n○ Graphs including Graph Algorithms\n○ Sorting Algorithms\n■ O(n log n) heapsort\n■ Pseudo O(n) complexity (e.g., bucket, counting, radix)\n○ Graph Algorithms\n■ Transitive closure (e.g., Warshall’s)\n■ Topological sort\n○ Matching\n■ Efficient String Matching (e.g., Boyer-Moore, Knuth-Morris-Pratt)\n98\n■ Longest common subsequence matching\n■ Regular expression matching\n● AL-Complexity (3 hours)\n○ Asymptotic Complexity Analysis\n○ Foundational Complexity Classes\n■ O(2n) Exponential and O(n!) Factorial\n○ Empirical Measurements of Performance\n○ Tractability and Intractability\n● AL-Strategies (3 hours)\n○ Brute Force (e.g., traveling salesperson, knapsack)\n○ Decrease-and-Conquer (e.g., topological sort)\n○ Divide-and-Conquer (e.g., Strassen’s algorithm)\n○ Greedy (e.g., Dijkstra’s, Kruskal’s)\n○ Transform-and-Conquer/Reduction (e.g., heapsort, trees (2-3, AVL, Red-Black))\n■ Dynamic Programming (e.g., Warshall’s, Floyd’s, Bellman-Ford)\n○ Handling Exponential Growth (e.g., heuristic A*, branch-and-bound, backtracking)\nCourse objectives: Students should be able to explain, evaluate, and apply the specified data\nstructures and algorithms in a variety of problem-solving contexts. Additionally, they should be able to\nformally explain complexity analysis and the importance of tractability including approaches for handling\nintractable problems.\nComputation Theory (fourth course)\n● AL-Complexity (3 hours)\n○ Turing Machine-based models of complexity (P, NP, and NP-C classes)\n○ Space complexity (NSpace, PSpace Savitch’ Theorem)\n● AL-Models (29 hours)\n○ All CS and KA Core topics\n● AL-SEP (In SEP hours)\nCourse objectives: Students should be able to explain, evaluate, and apply models of computation,\ngrammars, and languages. Additionally, they should be able to explain formal proofs that demonstrate\nthe capability and limitations of various automata. Students should be able to relate the complexity of\nRandom Access Models of Computation to Turing Machine models. Finally, students should be able to\nsummarize decidability and reduction proofs.\nCommittee\nChair: Richard Blumenthal, Regis University, Denver, CO, USA\nMembers:\n● Cathy Bareiss, Bethel University, Mishawaka, MN, USA\n● Tom Blanchet, SciTec, Inc., Boulder, CO, USA\n● Doug Lea, State University of New York at Oswego, Oswego, NY, USA\n99\n● Sara Miner More, John Hopkins University, Baltimore, MD, USA\n● Mia Minnes, University of California San Diego, San Diego, CA, USA\n● Atri Rudra, University at Buffalo, Buffalo, NY, USA\n● Christian Servin, El Paso Community College, El Paso, TX, USA\n100\nArchitecture and Organization (AR)\nPreamble\nComputing professionals spend considerable time writing efficient code to solve a particular problem in\nan application domain. As the shift from sequential to parallel processing occurs, a deeper understanding\nof the underlying computer architectures is necessary. Architecture can no longer be viewed as a black\nbox where principles from one architecture can be applied to another. Instead, programmers should look\ninside the black box and use specific components to enhance system performance and energy efficiency.\nThe Architecture and Organization (AR) knowledge area aims to develop a deeper understanding of the\nhardware environments upon which almost all computing is based, and the relevant interfaces provided\nto higher software layers. The target hardware comprises low-end embedded system processors up to\nhigh-end enterprise multiprocessors.\nThe topics in this knowledge area will benefit students by enabling them to appreciate the fundamental\narchitectural principles of modern computer systems, including the challenge of harnessing parallelism\nto sustain performance and energy improvements into the future. This KA will help computer science\nstudents depart from the black box approach and become more aware of the underlying computer system\nand the efficiencies specific architectures can achieve.\nChanges since CS2013\nChanges and additions are summarized as follows.\n● Topics have been revised, particularly AR/Memory Hierarchy and AR/Performance and Energy\nEfficiency. This update brings recent advances in memory caching and energy consumption.\n● The newly created AR/Heterogeneous Architectures covers emerging topics in Computer\nArchitecture: Processing In-Memory (PIM) and domain-specific architectures (e.g., neural\nnetwork processors).\n● The new AR/Quantum Architectures offers a \"toolbox\" covering introductory topics in quantum\ncomputing.\n● Knowledge units have been merged to better deal with overlaps:\n● AR/Multiprocessing and Alternative Architectures were merged into newly created\nAR/Heterogeneous Architectures.\n● The new AR/Secure Processor Architectures covers hardware support for multi-stack security\napplications.\nCore Hours\nKnowledge Unit CS Core KA Core\nDigital Logic and Digital Systems 2 + 1 (SF)\n101\nMachine-Level Data Representation 1\nAssembly Level Machine Organization 1 1 + 1 (PDC)\nMemory Hierarchy 4+2 (OS)\nInterfacing and Communication 1\nFunctional Organization 2\nPerformance and Energy Efficiency 3\nHeterogeneous Architectures 2\nSecure Processor Architectures 2\nQuantum Architectures 2\nSustainability Issues Included in SEP hours\nTotal 9 16\nThe hours shared with OS include overlapping topics and are counted here.\nKnowledge Units"
    }
  },
  {
    "title": "AR-Logic: Digital Logic and Digital Systems",
    "KA Core": "1. Combinational vs sequential logic/field programmable gate arrays (FPGAs) (See also: SF-\nOverview, SF-Foundations, SPD-Embedded)\na. Fundamental combinational\nb. Sequential logic building block\n2. Computer-aided design tools that process hardware and architectural representations\n3. High-level synthesis\na. Register transfer notation\nb. Hardware description language (e.g., Verilog/VHDL/Chisel)\n4. System-on-chip (SoC) design flow\n5. Physical constraints\na. Gate delays\nb. Fan-in and fan-out\nc. Energy/power\nd. Speed of light",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Discuss the progression of computer technology components from vacuum tubes to VLSI, from\nmainframe computer architectures to the organization of warehouse-scale computers.\n2. Describe parallelism and data dependencies between and within components in a modern\nheterogeneous computer architecture.\n3. Explain the relationship between parallelism and power consumption.\n4. Construct the design of basic building blocks for a computer: arithmetic-logic unit (gate-level),\nregisters (gate-level), central processing unit (register transfer-level), and memory (register transfer-\nlevel).\n5. Evaluate simple building blocks (e.g., arithmetic-logic unit, registers, movement between registers)\nof a simple computer design.\n6. Analyze the timing behavior of a pipelined processor, identifying data dependency issues."
    }
  },
  {
    "title": "AR-Representation: Machine-Level Data Representation",
    "CS Core": "1. Overview and history of computer architecture (See also: SPD-Game)\n2. Bits, bytes, and words\n3. Unsigned, signed and two’s complement representations\n4. Numeric data representation and number bases\na. Fixed-point\nb. Floating-point\n5. Representation of non-numeric data\n6. Representation of records, arrays and UTF data types (See also: AL-Foundational)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Discuss why everything in computers are data, including instructions.\n2. Explain how fixed-length number representations can affect accuracy and precision.\n3. Describe how negative integers are stored in sign-magnitude and two’s-complement\nrepresentations.\n4. Discuss how different formats can represent numerical data.\n5. Explain the bit-level representation of non-numeric data, such as characters, strings, records, and\narrays.\n6. Translate numerical data from one format to another.\n7. Describe how a single adder (without overflow detection) can handle both signed (two’s\ncomplement) and unsigned (binary) input without “knowing” which format a given input is using."
    }
  },
  {
    "title": "AR-Assembly: Assembly Level Machine Organization",
    "CS Core": "1. von Neumann machine architecture\n2. Control unit: instruction fetch, decode, and execution (See also: OS-Principles)\n3. Introduction to SIMD vs MIMD and the Flynn taxonomy (See also: PDC-Programs, OS-Scheduling,\nOS-Process)\n103\n4. Shared memory multiprocessors/multicore organization (See also: PDC-Programs, OS-Scheduling)",
    "KA Core": "5. Instruction set architecture (ISA) (e.g., x86, ARM and RISC-V)\na. Fixed vs variable-width instruction sets\nb. Instruction formats\nc. Data manipulation, control, I/O\nd. Addressing modes\ne. Machine language programming\nf. Assembly language programming\n6. Subroutine call and return mechanisms (See also: FPL-Translation, OS-Principles)\n7. I/O and interrupts (See also: OS-Principles)\n8. Heap, static, stack, and code segments (See also: FPL-Translation, OS-Process)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Discuss how the classical von Neumann functional units are implemented in embedded systems,\nparticularly on-chip and off-chip memory.\n2. Describe how instructions are executed in a classical von Neumann machine, with extensions for\nthreads, multiprocessor synchronization, and SIMD execution.\n3. Assess an example diagram with instruction-level parallelism and hazards to describe how they are\nmanaged in typical processor pipelines.",
      "KA Core": "4. Discuss how instructions are represented at the machine level and in the context of a symbolic\nassembler.\n5. Map an example of high-level language patterns into assembly/machine language notations.\n6. Contrast different instruction formats considering aspects such as addresses per instruction and\nvariable-length vs fixed-length formats.\n7. Analyze a subroutine diagram to comment on how subroutine calls are handled at the assembly\nlevel.\n8. Describe basic concepts of interrupts and I/O operations.\n9. Write a simple assembly language program for string/array processing and manipulation."
    }
  },
  {
    "title": "AR-Memory: Memory Hierarchy",
    "CS Core": "1. Memory hierarchy: the importance of temporal and spatial locality (See also: SF-Performance, OS-\nMemory)\n2. Main memory organization and operations (See also: OS-Memory)\n3. Persistent memory (e.g., SSD, standard disks)\n4. Latency, cycle time, bandwidth, and interleaving (See also: SF-Performance)\n5. Cache memories (See also: SF-Performance)\na. Address mapping\nb. Block size\n104\nc. Replacement and store policy\nd. Prefetching\n6. Multiprocessor cache coherence (See also: OS-Scheduling)\n7. Virtual memory (hardware support) (See also: OS-Memory)\n8. Fault handling and reliability (See also: SF-Reliability)\n9. Reliability (See also: SF-Reliability, OS-Faults)\na. Error coding\nb. Data compression\nc. Data integrity",
    "KA Core": "10. Processing In-Memory (PIM)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Using a memory system diagram, identify the main types of memory technology (e.g., SRAM,\nDRAM) and their relative cost and performance.\n2. Measure the effect of memory latency on running time.\n3. Enumerate the functions of a system with virtual memory management.\n4. Compute average memory access time under various cache and memory configurations and mixes\nof instruction and data references."
    }
  },
  {
    "title": "AR-IO: Interfacing and Communication",
    "CS Core": "1. I/O fundamentals (See also: OS-Devices, PDC-Communication)\na. Handshaking and buffering\nb. Programmed I/O\nc. Interrupt-driven I/O (See also: OS-Principles)\n2. Interrupt structures: vectored and prioritized, interrupt acknowledgment (See also: OS-Principles)\n3. I/O devices (e.g., mouse, keyboard, display, camera, sensors, actuators) (See also: GIT-\nFundamentals, GIT-Interaction, OS-Advanced-Files, PDC-Programs)\n4. External storage, physical organization, and drives\n5. Buses fundamentals (See also: OS-Devices)\na. Bus protocols\nb. Arbitration\nc. Direct-memory access (DMA)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Analyze an interrupt control diagram to comment on how interrupts are used to implement I/O\ncontrol and data transfers.\n2. Enumerate various types of buses in a computer system.\n3. List the advantages of magnetic disks and contrast them with those of solid-state disks.\n105"
    }
  },
  {
    "title": "AR-Organization: Functional Organization",
    "KA Core": "1. Implementation of simple datapaths, including instruction pipelining, hazard detection, and\nresolution (e.g., stalls, forwarding)\n2. Control unit\na. Hardwired implementation\nb. Microprogrammed realization\n3. Instruction pipelining (See also: SF-Overview)\n4. Introduction to instruction-level parallelism (ILP) (See also: PDC-Programs)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Compare alternative implementation of datapaths in modern computer architectures.\n2. Produce a set of control signals for adding two integers using hardwired and microprogrammed\nimplementations.\n3. Discuss instruction-level parallelism using pipelining and significant hazards that may occur.\n4. Design a complete processor, including datapath and control.\n5. Compute the average cycles per instruction for a given processor and memory system\nimplementation."
    }
  },
  {
    "title": "AR-Performance-Energy: Performance and Energy Efficiency",
    "KA Core": "1. Performance-energy evaluation (introduction): performance, power consumption, memory, and\ncommunication costs (See also: SF-Evaluation, OS-Scheduling, SPD-Game)\n2. Branch prediction, speculative execution, out-of-order execution, Tomasulo's algorithm\n3. Enhancements for vector processors and GPUs (See also: SPD-Game)\n4. Hardware support for multithreading (See also: OS-Concurrency, OS-Scheduling, PDC-Programs)\na. Race conditions\nb. Lock implementations\nc. Point-to-point synchronization\nd. Barrier implementation\n5. Scalability\n6. Alternative architectures including VLIW/EPIC, accelerators, and other special purpose processors\n7. Dynamic voltage and frequency scaling (DVFS)\n8. Dark Silicon",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Discuss performance and energy efficiency evaluation metrics.\n2. Analyze a speculative execution diagram and write about the decisions that can be made.\n3. Create a GPU performance-watt benchmarking diagram.\n4. Write a multithreaded program that adds (in parallel) elements of two integer vectors.\n5. Recommend a set of design choices for alternative computer architectures.\n106\n6. Enumerate key concepts associated with dynamic voltage and frequency scaling.\n7. Measure energy savings improvement for an 8-bit integer quantization compared to a 32-bit\nquantization."
    }
  },
  {
    "title": "AR-Heterogeneity: Heterogeneous Architectures",
    "KA Core": "1. SIMD and MIMD architectures (e.g., General-Purpose GPUs, TPUs, and NPUs) (See also: PDC-\nPrograms, SPD-Embedded, GIT-Shading, SPD-Game)\n2. Heterogeneous memory systems (See also: OS-Process, PDC-Communication)\na. Shared memory versus distributed memory\nb. Volatile vs non-volatile memory\nc. Coherence protocols\n3. Domain-Specific Architectures (DSAs) (See also: HCI-Accountability, GIT-Shading)\na. Machine Learning Accelerator\nb. In-networking computing (See also: NC-Applications)\nc. Embedded systems for emerging applications\nd. Neuromorphic computing\ne. Edge computing devices\n4. Packaging and integration solutions such as 3DIC and chiplets\n5. Machine learning in architecture design\na. AI algorithms for workload analysis\nb. Optimization of architecture configurations for performance and power efficiency",
    "Illustrative Learning Outcomes": "KA Core\n1. Analyze a system diagram with alternative parallel architectures, e.g., SIMD and MIMD, and identify\nthe key differences.\n2. Discuss what memory-management issues are found in multiprocessors that are not present in\nuniprocessors and how these issues might be resolved.\n3. Indicate the differences between memory backplane, processor memory interconnect, and remote\nmemory via networks, their implications for access latency, and their impact on program\nperformance.\n4. Discuss how you would determine when to use a domain-specific accelerator instead of a general-\npurpose CPU.\n5. Enumerate key differences in architectural design principles between a vector and scalar-based\nprocessing unit.\n6. List the advantages and disadvantages of a PIM architecture."
  },
  {
    "title": "AR-Security: Secure Processor Architectures",
    "KA Core": "1. Discuss principles of secure hardware, exploring a framework for risk analysis and asset protection.\n2. Summarize how Physically Unclonable Functions (PUF) can be a unique device identifier in security\napplications.\n3. Distinguish a random number generator with dedicated hardware support from generators without\nhardware dedicated to generating entropy.\n4. List the advantages and disadvantages of memory protection at the ISA level.\n5. Describe key design issues of a trusted execution environment (TEE) to support virtual machines."
  },
  {
    "title": "AR-Quantum: Quantum Architectures",
    "KA Core": "1. Principles (See also: AL-Models: 8)\na. The wave-particle duality principle\nb. The uncertainty principle in the double-slit experiment\nc. What is a Qubit? Superposition, interference, and measurement. Photons as qubits\nd. Systems of two qubits, Entanglement, Bell states, The No-Signaling theorem\n2. Axioms of QM: superposition principle, measurement axiom, unitary evolution\n3. Single qubit gates for the circuit model of quantum computation: X, Z, H\n4. Two qubit gates and tensor products, working with matrices\n5. The No-Cloning Theorem. The Quantum Teleportation protocol\n6. Algorithms (See also: AL-Foundational)\na. Simple quantum algorithms: Bernstein-Vazirani, Simon’s algorithm\nb. Implementing Deutsch-Josza with Mach-Zehnder Interferometers\nc. Quantum factoring (Shor’s Algorithm)\nd. Quantum search (Grover’s Algorithm)\n7. Implementation aspects (See also: SPD-Interactive)\na. The physical implementation of qubits\nb. Classical control of a Quantum Processing Unit (QPU)\nc. Error mitigation and control, NISQ and beyond\n108\nd. Measurement approaches\n8. Emerging Applications\na. Post-quantum encryption\nb. The Quantum Internet\nc. Adiabatic quantum computation (AQC) and quantum annealing",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Discuss how a quantum object produced as a particle propagates like a wave and is detected as a\nparticle with a probability distribution corresponding to the wave.\n2. Discuss the quantum-level nature that is inherently probabilistic.\n3. Express your view on entanglement that can be used to create non-classical correlations, but there\nis no way to use quantum entanglement to send messages faster than the speed of light.\n4. Describe quantum parallelism and the role of constructive vs destructive interference in quantum\nalgorithms given the probabilistic nature of measurement(s).\n5. Analyze a code snippet providing the role of quantum Fourier transform (QFT) in Shor’s algorithm.\n6. Write a program to implement Shor’s algorithm in a simulator, highlighting the classical components\nand aspects of Shor’s algorithm.\n7. Enumerate the specifics of each qubit modality (e.g., trapped ion, superconducting, silicon spin,\nphotonic, quantum dot, neutral atom, topological, color center, electron-on-helium).\n8. Contrast AQC with the gate model of quantum computation and the problems each is better suited\nto solve."
    }
  },
  {
    "title": "AR-SEP: Sustainability Issues",
    "Non-core": "1. Environmental impacts of implementation decisions\na. Sustainability goals, resource consumption, and economic viability\nb. Carbon footprint, hardware electronic waste\nc. The energy footprint of data centers at various workloads (e.g., AI model training and use)\nd. Guidelines for sustainable design standards",
    "Illustrative Learning Outcomes": {
      "Non-core": "1. Assess the environmental impacts of a given project’s deployment (e.g., the energy consumption of\nCPUs and GPUs, contribution to e-waste, and effect of hardware virtualization in data centers).\nProfessional Dispositions\n● Self-directed: Students should increasingly become self-motivated to acquire complementary\nknowledge.\n● Proactive: Students should exercise control and anticipate issues related to the underlying\ncomputer system.\n109\nMathematics Requirements\n● MSF-Discrete, MSF-Linear, MSF-Statistics, MSF-Calculus, MSF-Probability\nCourse Packaging Suggestions\nComputer Architecture - Introductory Course to include the following:\n● SEP-History (2 hours)\n● AR-Representation (2 hours)\n● AR-Assembly (2 hours)\n● AR-Memory (10 hours)\n● OS-Memory (10 hours)\n● AR-IO (4 hours)\n● AR-Heterogeneity (5 hours)\n● PDC-Programs (4 hours)\n● SEP-Ethical-Analysis (3 hours)\nCourse objectives: Students should understand the fundamentals of modern computer architectures,\nincluding the challenges associated with memory caches, memory management, and pipelining.\nPrerequisites:\n● MSF-Discrete\nComputer Architecture - Advanced Topics Course to include the following:\n● AR-Logic (4 hours)\n● AR-Representation (2 hours)\n● AR-Assembly (2 hours)\n● AR-Memory (10 hours)\n● AR-IO (2 hours)\n● SF-Performance (4 hours)\n● AR-Heterogeneity (4 hours)\n● AR-Performance-Energy (5 hours)\n● AR-Security (4 hours)\n● AR-Quantum (4 hours)\nCourse objectives: Students should understand how computer architectures evolved into today’s\nheterogeneous systems and to what extent choices made in the past can influence the design of future\nhigh-performance computing systems.\nPrerequisites:\n● MSF-Discrete\nSystems Course to include the following:\n● SEP-History (2 hours)\n110\n● SF-Design (2 hours)\n● SF-Reliability (2 hours)\n● OS-Purpose (2 hours)\n● AR-Representation (2 hours)\n● AR-Assembly (2 hours)\n● AR-Memory (8 hours)\n● AR-IO (2 hours)\n● PDC-Algorithms (4 hours)\n● AR-Heterogeneity (4 hours)\n● AR-Performance-Energy (5 hours)\n● NC-Applications (5 hours)\nCourse objectives: Students should understand the advanced architectural aspects of modern\ncomputer systems, including heterogeneous architectures and the required hardware and software\ninterfaces to improve the performance and energy footprint of applications.\nPrerequisites:\n● MSF-Discrete, MSF-Statistics\nCommittee\nChair: Marcelo Pias, Federal University of Rio Grande (FURG), Rio Grande-RS, Brazil\nMembers:\n● Brett A. Becker, University College Dublin, Dublin, Ireland\n● Mohamed Zahran, New York University, New York, NY, USA\n● Monica D. Anderson, University of Alabama, Tuscaloosa, AL, USA\n● Qiao Xiang, Xiamen University, Xiamen, China\n● Adrian German, Indiana University, Bloomington, IN, USA\n111\n112\nData Management (DM)\nPreamble\nSince the mid-1970s, the study of Data Management (DM) has meant an almost exclusive study of\nrelational database systems. Depending on institutional context, students have studied, in varying\nproportions, the following.\n• Data modeling and database design: for example, E-R Data model, relational model,\nnormalization theory\n• Query construction: e.g., relational algebra, SQL\n• Query processing: e.g., indices (B+tree, hash), algorithms (e.g., external sorting, select, project,\njoin), query optimization (transformations, index selection)\n• DBMS internals: e.g., concurrency/locking, transaction management, buffer management\nToday's graduates are expected to possess DBMS user (rather than implementor) skills. These\nprimarily include data modeling and query construction; ability to take an unorganized collection of data,\norganize it using a DBMS, and access/update the collection via queries.\nAdditionally, students need to study the following.\n● The role data plays in an organization. This includes the Data Life Cycle: Creation-Processing-\nReview/Reporting-Retention/Retrieval-Destruction.\n● The social/legal aspects of data collection: e.g., scale, data privacy, database privacy (compliance)\nby design, de-identification, ownership, reliability, database security, and intended and unintended\napplications.\n● Emerging and advanced technologies that are augmenting/replacing traditional relational systems,\nparticularly those used to support (big) data analytics, including NoSQL (e.g., JSON, XML, key-\nvalue store databases), cloud databases, MapReduce, and dataframes.\n● The existing and emerging roles for those involved with data management, which include the\nfollowing.\no Product feature engineers: those who use both SQL and NoSQL operational databases.\no Analytical engineers/data engineers: those who write analytical SQL, Python, and Scala\ncode to build data assets for business groups.\no Business analysts: those who build/manage data most frequently with Excel spreadsheets.\no Data infrastructure engineers: those who implement a data management system in a variety\nof data applications (e.g., OLTP).\no “Everyone” who produces or consumes data must understand the associated social, ethical,\nand professional issues.\nOne role that transcends all the above categories is that of data custodian. Previously, data were seen\nas a resource to be managed (Information Systems Management) just like other enterprise resources.\nToday, data are seen in a larger context. Data about customers can now be seen as belonging to (or in\nsome national contexts, as owned by) those customers. There is now an accepted understanding that\nthe safe and ethical storage, and use, of institutional data is part of being a responsible data custodian.\n113\nFurthermore, we acknowledge the tension between a curricular focus on professional preparation\nversus the study of a knowledge area as a scientific endeavor. This is particularly true with Data\nManagement. For example, proving (or at least knowing) the completeness of Armstrong’s Axioms is\nfundamental in functional dependency theory. However, most computer science graduates will never\nutilize this concept during their professional careers. The same can be said for many other topics in the\nData Management canon. Conversely, if our graduates can only normalize data into Boyce-Codd\nnormal form (using an automated tool) and write SQL queries, without understanding the role that\nindices play in efficient query execution, we have done them and society a disservice.\nTo this end, the number of CS Core hours is relatively small relative to the KA Core hours. This\napproach is designed to allow institutions with differing contexts to customize their curricula\nappropriately. An institution that focuses on OLTP implementation, for example, would prioritize efficient\nstorage and data access, while an institution that focuses on product features would prioritize\nprogrammatic access to extant databases.\nHowever, an institution manages this tension, we wish to give voice to one of the ironies of computer\nscience curricula. Students typically spend much of their educational life reading (and writing) data from\na file or interactively, while outside of the academy the predominant data comes from databases\naccessed programmatically. Perhaps in the not-too-distant future students will learn programmatic\ndatabase access early on and then continue this practice as they progress through their curriculum.\nFinally, we understand that while the Data Management KA may be orthogonal to the SEC (Security)\nand SEP (Society, Ethics, and the Profession) KAs, it is also ground zero for these (and other)\nknowledge areas. When designing persistent data stores, the question of what should be stored must\nbe examined from both legal and ethical perspectives. Are there privacy concerns? And just as\nimportantly, how well protected is the data?\nChanges since CS2013\n● Rename the knowledge area from Information Management to Data Management. This\nrenaming does not represent any kind of philosophical shift. It is simply an effort to avoid\nconfusion with the similar definitions used in Information Systems and Information Technology\ncurricula.\n● Inclusion of NoSQL approaches and MapReduce as CS Core topics.\n● Increased attention to SEP and SEC topics in both the CS Core and KA Core areas.\nCore Hours\nKnowledge Unit CS Core Hours KA Core Hours\nThe Role of Data 2\nCore Database Systems Concepts 2 1\n114\nData Modeling 2 3\nRelational Databases 1 3\nQuery Construction 2 4\nQuery Processing 4\nDBMS Internals 4\nNoSQL Systems 2\nData Security & Privacy 1 2\nData Analytics 3\nDistributed Databases/Cloud Computing\nSemi-structured and Unstructured Databases\nSociety, Ethics, and the Profession Included in SEP hours\nTotal 10 26\nThe CS Core hour in Data Security & Privacy is shared with SEC and is counted here.\nKnowledge Units"
    }
  },
  {
    "title": "DM-Data: The Role of Data and the Data Life Cycle",
    "CS Core": "1. The Data Life Cycle: Creation-Processing-Review/Reporting-Retention/Retrieval-Destruction (See\nalso: SEP-Context, SEP-Ethical-Analysis, SEP-Professional-Ethics, SEP-Privacy, SEP-Security,\nSEC-Foundations)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Identify the five stages of the Data Life Cycle."
    }
  },
  {
    "title": "DM-Core: Core Database System Concepts",
    "CS Core": "1. Purpose and advantages of database systems\n2. Components of database systems\n115\n3. Design of core DBMS functions (e.g., query mechanisms, transaction management, buffer\nmanagement, access methods)\n4. Database architecture, data independence, and data abstraction\n5. Transaction management\n6. Normalization\n7. Approaches for managing large volumes of data (e.g., NoSQL database systems, use of\nMapReduce) (See also: PDC-Algorithms)\n8. How to support CRUD-only applications\n9. Distributed databases/cloud-based systems\n10. Structured, semi-structured, and unstructured data\n11. Use of a declarative query language",
    "KA Core": "12. Systems supporting structured and/or stream content",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Identify at least four advantages that using a database system provides.\n2. Enumerate the components of a (relational) database system.\n3. Follow a query as it is processed by the components of a (relational) database system.\n4. Defend the value of data independence.\n5. Compose a simple select-project-join query in SQL.\n6. Enumerate the four properties of a correct transaction manager.\n7. Describe the advantages for eliminating duplicate repeated data.\n8. Outline how MapReduce uses parallelism to process data efficiently.\n9. Evaluate the differences between structured and semi/unstructured databases."
    }
  },
  {
    "title": "DM-Modeling: Data Modeling",
    "CS Core": "1. Data modeling (See also: SE-Requirements)\n2. Relational data model (See also: MSF-Discrete)",
    "KA Core": "3. Conceptual models (e.g., entity-relationship, UML diagrams)\n4. Semi-structured data models (expressed using DTD, XML, or JSON Schema, for example)",
    "Non-core": "5. Spreadsheet models\n6. Object-oriented models (See also: FPL-OOP)\na. GraphQL\n7. New features in SQL\n8. Specialized Data Modeling topics\na. Time series data (aggregation, join)\nb. Graph data (link traversal)\n116\nc. Techniques for avoiding inefficient raw data access (e.g., “avg daily price”): materialized views\nand special data structures (e.g., Hyperloglog, bitmap)\nd. Geo-Spatial data (e.g., GIS databases) (See also: SPD-Interactive)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Describe the components of the relational data model.\n2. Model 1:1, 1:n, and n:m relationships using the relational data model.",
      "KA Core": "3. Describe the components of the E-R (or some other non-relational) data model.\n4. Model a given environment using a conceptual data model.\n5. Model a given environment using the document-based or key-value store-based data model."
    }
  },
  {
    "title": "DM-Relational: Relational Databases",
    "CS Core": "1. Entity and referential integrity: Candidate key, superkeys\n2. Relational database design",
    "KA Core": "3. Mapping conceptual schema to a relational schema\n4. Physical database design: file and storage structures (See also: OS-Files)\n5. Introduction to Functional dependency theory\n6. Normalization Theory\na. Decomposition of a schema; lossless-join, and dependency-preservation properties of a\ndecomposition\nb. Normal forms (BCNF)\nc. Denormalization (for efficiency)",
    "Non-core": "7. Functional dependency theory\na. Closure of a set of attributes\nb. Canonical Cover\n8. Normalization theory\na. Multi-valued dependency (4NF)\nb. Join dependency (PJNF, 5NF)\nc. Representation theory",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Describe the defining characteristics behind the relational data model.\n2. Comment on the difference between a foreign key and a superkey.\n3. Enumerate the different types of integrity constraints.\n117",
      "KA Core": "4. Compose a relational schema from a conceptual schema which contains 1:1, 1:n, and n:m\nrelationships.\n5. Map appropriate file structure to relations and indices.\n6. Describe how functional dependency theory generalizes the notion of key.\n7. Defend a given decomposition as lossless and or dependency preserving.\n8. Detect which normal form a given decomposition yields.\n9. Comment on reasons for denormalizing a relation."
    }
  },
  {
    "title": "DM-Querying: Query Construction",
    "CS Core": "1. SQL Query Formation\na. Interactive SQL execution\nb. Programmatic execution of an SQL query",
    "KA Core": "2. Relational Algebra\n3. SQL\na. Data definition including integrity and other constraint specifications\nb. Update sublanguage",
    "Non-core": "4. Relational Calculus\n5. QBE and 4th-generation environments\n6. Different ways to invoke non-procedural queries in conventional languages\n7. Introduction to other major query languages (e.g., XPATH, SPARQL)\n8. Stored procedures",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Compose SQL queries that incorporate select, project, join, union, intersection, set difference, and\nset division.\n2. Determine when a nested SQL query is correlated or not.\n3. Iterate over data retrieved programmatically from a database via an SQL query.",
      "KA Core": "4. Define, in SQL, a relation schema, including all integrity constraints and delete/update triggers.\n5. Compose an SQL query to update a tuple in a relation."
    }
  },
  {
    "title": "DM-Processing: Query Processing",
    "KA Core": "1. Page structures\n2. Index structures\na. B+ trees (See also: AL-Foundational)\n118\nb. Hash indices: static and dynamic (See also: AL-Foundational, SEC-Foundations)\nc. Index creation in SQL\n3. File structures (See also: OS-Files)\na. Heap files\nb. Hash files\n4. Algorithms for query operators\na. External Sorting (See also: AL-Foundational)\nb. Selection\nc. Projection; with and without duplicate elimination\nd. Natural Joins: Nested loop, Sort-merge, Hash join\ne. Analysis of algorithm efficiency (See also: AL-Complexity)\n5. Query transformations\n6. Query optimization\na. Access paths\nb. Query plan construction\nc. Selectivity estimation\nd. Index-only plans\n7. Parallel Query Processing (e.g., parallel scan, parallel join, parallel aggregation) (See also: PDC-\nAlgorithms)\n8. Database tuning/performance\na. Index selection\nb. Impact of indices on query performance (See also: SF-Performance, SEP-Sustainability)\nc. Denormalization",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe the purpose and organization of both B+ tree and hash index structures.\n2. Compose an SQL command to create an index (any kind).\n3. Specify the steps for the various query operator algorithms: external sorting, projection with\nduplicate elimination, sort-merge join, hash-join, block nested-loop join.\n4. Derive the run-time (in I/O requests) for each of the above algorithms.\n5. Transform a query in relational algebra to its equivalent appropriate for a left-deep, pipelined\nexecution.\n6. Compute selectivity estimates for a given selection and/or join operation.\n7. Describe how to modify an index structure to facilitate an index-only operation for a given relation.\n8. For a given scenario decide on which indices to support for the efficient execution of a set of\nqueries.\n9. Describe how DBMSs leverage parallelism to speed up query processing by dividing the work\nacross multiple processors or nodes."
    }
  },
  {
    "title": "DM-Internals: DBMS Internals",
    "KA Core": "1. DB Buffer Management (See also: OS-Memory, SF-Resource)\n119\n2. Transaction Management (See also: PDC-Coordination)\na. Isolation Levels\nb. ACID\nc. Serializability\nd. Distributed Transactions\n3. Concurrency Control: (See also: OS-Concurrency)\na. 2-Phase Locking\nb. Deadlocks handling strategies\nc. Quorum-based consistency models\n4. Recovery Manager\na. Relation with Buffer Manager",
    "Non-core": "5. Concurrency Control:\na. Optimistic concurrency control\nb. Timestamp concurrency control\n6. Recovery Manager\na. Write-Ahead logging\nb. ARIES recovery system (Analysis, REDO, UNDO)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe how a DBMS manages its Buffer Pool.\n2. Describe the four properties for a correct transaction manager.\n3. Outline the principle of serializability."
    }
  },
  {
    "title": "DM-NoSQL: NoSQL Systems",
    "KA Core": "1. Why NoSQL? (e.g., Impedance mismatch between Application [CRUD] and RDBMS)\n2. Key-Value and Document data model",
    "Non-core": "3. Storage systems (e.g., Key-Value systems, Data Lakes)\n4. Distribution Models (Sharding and Replication) (See also: PDC-Communication)\n5. Graph Databases\n6. Consistency Models (Update and Read, Quorum consistency, CAP theorem) (See also: PDC-\nCommunication)\n7. Processing model (e.g., Map-Reduce, multi-stage map-reduce, incremental map-reduce) (See also:\nPDC-Communication)\n8. Case Studies: Cloud storage system (e.g., S3); Graph databases; “When not to use NoSQL” (See\nalso: SPD-Web)",
    "Illustrative Learning Outcomes": {
      "KA Core": "120\n1. Develop a use case for the use of NoSQL over RDBMS.\n2. Describe the defining characteristics behind Key-Value and Document-based data models."
    }
  },
  {
    "title": "DM-Security: Data Security and Privacy",
    "CS Core": "1. Differences between data security and data privacy (See also: SEC-Foundations)\n2. Protecting data and database systems from attacks, including injection attacks such as SQL\ninjection (See also: SEC-Foundations)\n3. Personally identifying information (PII) and its protection (See also: SEC-Foundations, SEP-\nSecurity, SEP-Privacy)\n4. Ethical considerations in ensuring the security and privacy of data (See also: SEC-SEP, SEP-\nEthical-Analysis, SEP-Security, SEP-Privacy)",
    "KA Core": "5. Need for, and different approaches to securing data at rest, in transit, and during processing (See\nalso: SEC-Foundations, SEC-Crypto)\n6. Database auditing and its role in digital forensics (See also: SEC-Forensics)\n7. Data inferencing and preventing attacks (See also: SEC-Crypto)\n8. Laws and regulations governing data security and data privacy (See also: SEP-Security, SEP-\nPrivacy, SEC-Foundations, SEC-Governance)",
    "Non-core": "9. Typical risk factors and prevention measures for ensuring data integrity (See also: SEC-\nGovernance)\n10. Ransomware and prevention of data loss and destruction (See also: SEC-Coding, SEC-Forensics)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Describe the differences in the goals for data security and data privacy.\n2. Identify and mitigate risks associated with different approaches to protecting data.\n3. Describe legal and ethical considerations of end-to-end data security and privacy.",
      "KA Core": "4. Develop a database auditing system given risk considerations.\n5. Apply several data exploration approaches to understanding unfamiliar datasets."
    }
  },
  {
    "title": "DM-Analytics: Data Analytics",
    "KA Core": "1. Exploratory data techniques (motivation, representation, descriptive statistics, visualizations)\n2. Data science lifecycle: business understanding, data understanding, data preparation, modeling,\nevaluation, deployment, and user acceptance (See also: AI-ML)\n121\n3. Data mining and machine learning algorithms: e.g., classification, clustering, association, regression\n(See also: AI-ML)\n4. Data acquisition and governance (See also: SEC-Governance)\n5. Data security and privacy considerations (See also: SEP-Security, SEP-Privacy, SEC-Foundations)\n6. Data fairness and bias (See also: SEP-Security, AI-SEP)\n7. Data visualization techniques and their use in data analytics (See also: GIT-Visualization)\n8. Entity Resolution",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe several data exploration approaches, including visualization, to understanding unfamiliar\ndatasets.\n2. Apply several data exploration approaches to understanding unfamiliar datasets.\n3. Describe basic machine learning/data mining algorithms and when they are appropriate for use.\n4. Apply several machine learning/data mining algorithms.\n5. Describe legal and ethical considerations in acquiring, using, and modifying datasets.\n6. Describe issues of fairness and bias in data collection and usage."
    }
  },
  {
    "title": "DM-Distributed: Distributed Databases/Cloud Computing",
    "Non-core": "1. Distributed DBMS (See also: PDC-Communications)\na. Distributed data storage\nb. Distributed query processing\nc. Distributed transaction model\nd. Homogeneous and heterogeneous solutions\ne. Client-server distributed databases (See also: NC-Fundamentals)\n2. Parallel DBMS (See also: PDC-Algorithms)\na. Parallel DBMS architectures: shared memory, shared disk, shared nothing;\nb. Speedup and scale-up, e.g., use of the MapReduce processing model (See also: PDC-\nPrograms, SF-Foundations)\nc. Data replication and weak consistency models (See also: PDC-Coordination)"
  },
  {
    "title": "DM-Unstructured: Semi-structured and Unstructured Databases",
    "Non-core": "1. Vectorized unstructured data (text, video, audio, etc.) and vector storage\na. TF-IDF Vectorizer with ngram\nb. Word2Vec\nc. Array database or array data type handling\n2. Semi-structured databases (e.g., JSON)\na. Storage\ni. Encoding and compression of nested data types\nb. Indexing\ni. Btree, skip index, Bloom filter\n122\nii. Inverted index and bitmap compression\niii. Space filling curve indexing for semi-structured geo-data\nc. Query processing for OLTP and OLAP use cases\ni. Insert, Select, update/delete tradeoffs\nii. Case studies on Postgres/JSON, MongoDB, and Snowflake/JSON"
  },
  {
    "title": "DM-SEP: Society, Ethics, and the Profession",
    "CS Core": "1. Issues related to scale (See also: SEP-Economies)\n2. Data privacy overall (See also: SEP-Privacy, SEP-Ethical-Analysis)\na. Privacy compliance by design (See also: SEP-Privacy)\n3. Data anonymity (See also: SEP-Privacy)\n4. Data ownership/custodianship (See also: SEP-Professional-Ethics)\n5. Intended and unintended applications of stored data (See also: SEP-Professional-Ethics, SEC-\nFoundations)",
    "KA Core": "6. Reliability of data (See also: SEP-Security)\n7. Provenance, data lineage, and metadata management (See also: SEP-Professional-Ethics)\n8. Data security (See also: DM-Security, SEP-Security)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Enumerate three social and three legal issues related to large data collections.\n2. Describe the value of data privacy.\n3. Identify the competing stakeholders with respect to data ownership.\n4. Enumerate three negative unintended consequences from a given (well known) data-centric\napplication (e.g., Facebook, LastPass, Ashley Madison).",
      "KA Core": "5. Describe the meaning of data provenance and lineage.\n6. Identify how a database might contribute to data security as well as how it may introduce\ninsecurities.\nProfessional Dispositions\n● Meticulous: Those who either access or store data collections must be meticulous in fulfilling\ndata ownership responsibilities.\n● Responsible: In conjunction with the professional management of (personal) data, it is equally\nimportant that data are managed responsibly. Protection from unauthorized access as well as\nprevention of irresponsible, though legal, use of data is paramount. Furthermore, data\ncustodians need to protect data not only from outside attack, but from crashes and other\nforeseeable dangers.\n123\n● Collaborative: Data managers and data users must behave in a collaborative fashion to ensure\nthat the correct data are accessed and are used only in an appropriate manner.\n● Responsive: The data that get stored and are accessed are always in response to an\ninstitutional need/request.\nMathematics Requirements\nRequired:\n● Discrete Mathematics: Set theory (union, intersection, difference, cross-product) (See also:\nMSF-Discrete)\nDesired:\n● Probability and Statistics for those studying DM-Analytics. (See also: MSF-Probability, MSF-\nStatistics)\nDesirable Data Structures:\n● Hash functions and tables (See also: AL-Foundational)\n● Balanced (binary) trees (e.g., AVL, 2-3-4, Red-Black) (See also: AL-Foundational)\n● B and B+-trees\nCourse Packaging Suggestions\nFor those implementing a single course on Database Systems, there are a variety of options. As\ndescribed in [1], there are four primary perspectives from which to approach databases:\n● Database design/modeling\n● Database use\n● Database administration\n● Database development, which includes implementation algorithms\nCourse design proceeds by focusing on topics from each perspective in varying degrees according to\none’s institutional context. For example, in [1], one of the courses described can be characterized as\ndesign/modeling (20%), use (20%), development/internals (30%), and administration/tuning/advanced\ntopics (30%). The topics might include the following.\n● DM-SEP (3 hours)\n● DM-Data (1 hour)\n● DM-Core (3 hours)\n● DM-Modeling (5 hours)\n● DM-Relational (4 hours)\n● DM-Querying (6 hours)\n● DM-Processing (5 hours)\n● DM-Internals (5 hours)\n● DM-NoSQL (4 hours)\n● DM-Security (3 hours)\n124\n● DM-Distributed (2 hours)\nThe more interesting question may be how to cover the CS Core concepts in the absence of a\ndedicated database course. The key to accomplishing this may be to normalize database access.\nStarting with the introductory course, students could access a database instead of using file I/O or\ninteractive data entry to acquire the data needed for introductory-level programming. As students\nprogress through their curriculum, additional CS Core topics could be introduced. For example,\nintroductory students could be given the code to access the database along with the SQL query. At the\nintermediate level, they could be writing their own queries. Finally, in a Software Engineering or\ncapstone course, they could practice database design. One advantage of this approach, databases\nacross the curriculum, is that it allows for the inclusion of database-related SEP topics to also be\nspread across the curriculum.\nIn a similar vein one might have a whole course on the Role of Data from either a Security (SEC)\nperspective, or an Ethics (SEP) perspective.\nCommittee\nChair: Mikey Goldweber, Denison University, Granville, OH, USA\nMembers:\n● Sherif Aly, The American University in Cairo, Cairo, Egypt\n● Sara More, Johns Hopkins University, Baltimore, MD, USA\n● Mohamed Mokbel, University of Minnesota, Minneapolis, MN, USA\n● Rajendra K. Raj, Rochester Institute of Technology, Rochester, NY, USA\n● Avi Silberschatz, Yale University, New Haven, CT, USA\n● Min Wei, Microsoft, Seattle, WA, USA\n● Qiao Xiang, Xiamen University, Xiamen, China\nReferences\n1. The 2022 Undergraduate Database Course in Computer Science: What to Teach?. Michael\nGoldweber, Min Wei, Sherif Aly, Rajendra K. Raj, and Mohamed Mokbel. ACM Inroads, 13, 3, 2022.\n125\n126\nFoundations of Programming Languages (FPL)\nPreamble\nThe foundations of programming languages are rooted in discrete mathematics, logic, and formal\nlanguages, and provide a basis for the understanding of complex modern programming languages.\nAlthough programming languages vary according to the language paradigm and the problem domain\nand evolve in response to both societal needs and technological advancement, they share an\nunderlying abstract model of computation and program development. This remains true even as\nprocessor hardware and their interface with programming tools become increasingly intertwined and\nprogressively more complex. An understanding of the common abstractions and programming\nparadigms enables faster learning of programming languages.\nThe Foundations of Programming Languages knowledge area is concerned with articulating the\nunderlying concepts and principles of programming languages, the formal specification of a\nprogramming language and the behavior of a program, explaining how programming languages are\nimplemented, comparing the strengths and weaknesses of various programming paradigms, and\ndescribing how programming languages interface with entities such as operating systems and\nhardware. The concepts covered here are applicable to several languages and an understanding of\nthese principles assists a learner to move readily from one language to another, as well as select a\nprogramming paradigm and language that best suits the problem at hand.\nProgramming languages are the medium through which programmers precisely describe concepts,\nformulate algorithms, and reason about solutions. Over the course of a career, a computer scientist will\nlearn and work with many different languages, separately or together. Software developers must\nunderstand different programming models, programming features and constructs, and underlying\nconcepts to make informed design choices among languages that support multiple complementary\napproaches. It would be useful to know how programming language features are defined, composed,\nand implemented to improve execution efficiency and long-term maintenance of developed software.\nAlso useful is a basic knowledge of language translation, program analysis, run-time behavior, memory\nmanagement and interplay of concurrent processes communicating with each other through message-\npassing, shared memory, and synchronization. Finally, some developers and researchers will need to\ndesign new languages, an exercise which requires greater familiarity with basic principles.\nChanges since CS2013\nChanges since 2013 include a change in name of the KA from Programming Languages to\nFoundations of Programming Languages to reflect the fact that the KA is about the fundamentals\nunderpinning programming languages, and related concepts, not about any specific programming\nlanguage. Changes also include a redistribution of content formerly identified as core Tier-1 and core\nTier-2 within the Programming Language Knowledge Area (KA). In CS2013, graduates were expected\nto complete all Tier-1 topics and 80% of Tier-2 topics, for a total of 24 required hours. These 24 hours\nare designated as CS Core topics in CS2023. The remaining Tier-2 topics are designated as KA Core\ntopics in CS2023. The change in core topics (Tier-1 plus 80% of Tier-2 hours) from 2013 reflects the\n127\nchange in importance or relevance of topics over the past decade. The inclusion of new topics was\ndriven by their current prominence in the programming language landscape, or the anticipated impact\nof emerging areas on the profession in general. Specifically, the changes are:\n● Object-Oriented Programming -4 CS Core hours\n● Functional Programming -2 CS Core hours\n● Event-Driven and Reactive Programming +1 CS Core hour\n● Parallel and Distributed Computing +3 CS Core hours\n● Type Systems -1 CS Core hour\n● Program Representation -1 CS Core hour\nIn addition, a number of knowledge units from CS2013 were renamed to reflect their content more\naccurately, as noted here.\n● Static Analysis was renamed Program Analysis and Analyzers.\n● Concurrency and Parallelism was renamed Parallel and Distributed Computing.\n● Program Representation was renamed Program Abstraction and Representation.\n● Runtime Systems was renamed Runtime Behavior and Systems.\n● Basic Type Systems and Type Systems were merged into a single topic and named Type\nSystems.\nSix new knowledge units were added to reflect their continuing and growing importance as we look\ntoward the 2030s:\n● Shell Scripting +2 CS Core hours\n● Systems Execution and Memory Model +3 CS Core hours\n● Formal Development Methodologies\n● Design Principles of Programming Languages\n● Fundamentals of Programming Languages\n● Society, Ethics, and the Profession\nNotes:\n● Several topics within this knowledge area either build on or overlap content covered in other\nknowledge areas such as the Software Development Fundamentals knowledge area in a\ncurriculum’s introductory courses. Curricula will differ on which topics are integrated in this\nfashion and which are postponed until later courses on software development and programming\nlanguages.\n● Different programming paradigms correspond to different problem domains. Most languages\nhave evolved to integrate more than one programming paradigm such as imperative with object-\noriented, functional programming with object-oriented, logic programming with object-oriented,\nand event and reactive modeling with object-oriented programming.\nHence, the emphasis is not on just one programming paradigm but on a balance of all major\nprogramming paradigms.\n● While the number of CS Core and KA Core hours is identified for each major programming\nparadigm (object-oriented, functional, logic), the distribution of hours across the paradigms may\ndiffer depending on the curriculum and programming languages students have been exposed to\n128\nleading up to coverage of this knowledge area. This document assumes that students have\nexposure to an object-oriented programming language leading into this knowledge area.\n● Imperative programming is not listed as a separate paradigm to be examined. Instead, it is\ntreated as a subset of the object-oriented paradigm.\n● With multicore computing, cloud computing, and computer networking becoming commonly\navailable in the market, it has become critical to understand the integration of “distribution,\nconcurrency, parallelism” along with other programming paradigms as a core area. This\nparadigm is integrated with almost all other major programming paradigms.\n● With ubiquitous computing and real-time temporal computing applications increasing in daily\nhuman life within domains such as health, transportation, smart homes, it has become important\nto cover the software development aspects of event-driven and reactive programming as well as\nparallel and distributed computing. A number of topics covered will require and overlap with\nconcepts in knowledge areas such as Architecture and Organization, Operating Systems, and\nSystems Fundamentals.\n● Some topics from the Parallel and Distributed Computing knowledge unit are likely to be\nintegrated within the curriculum with topics from the Parallel and Distributed Programming\nknowledge area.\n● There is an increasing interest in formal methods to prove program correctness and other\nproperties. To support this, additional coverage of topics related to formal methods has been\nincluded, but all these topics are identified as Non-core.\n● When introducing these topics, it is also important that an instructor provides context for this\nmaterial including why we have an interest in programming languages and what they do for us\nin terms of providing a human readable version of instructions for a computer to execute.\nCore Hours\nKnowledge Unit CS Core KA Core\nObject-Oriented Programming 4 + 1 (SDF) 1\nFunctional Programming 4 3\nLogic Programming 2 + 1 (MSF)\nShell Scripting 2\nEvent-Driven and Reactive Programming 2 2\nParallel and Distributed Computing 2 + 1 (PDC) 2\nAspect-Oriented Programming\nType Systems 3 3\nSystems Execution and Memory Model 2 + 1 (AR and\nOS)\n129\nLanguage Translation and Execution 2 3\nProgram Abstraction and Representation 3\nSyntax Analysis\nCompiler Semantic Analysis\nProgram Analysis and Analyzers\nCode Generation\nRuntime Behavior and Systems\nAdvanced Programming Constructs\nLanguage Pragmatics\nFormal Semantics\nFormal Development Methodologies\nDesign Principles of Programming Languages\nSociety, Ethics, and the Profession Included in SEP hours\nTotal 21 19\nThe CS and KA Core totals do not include the shared hours that have been counted in other knowledge\nareas.\nKnowledge Units"
    }
  },
  {
    "title": "FPL-OOP: Object-Oriented Programming",
    "CS Core": "1. Imperative programming as a subset of object-oriented programming.\n2. Object-oriented design:\na. Decomposition into objects carrying state and having behavior.\nb. Class-hierarchy design for modeling.\n3. Definition of classes: fields, methods, and constructors. (See also: SDF-Fundamentals)\n4. Subclasses, inheritance (including multiple inheritance), and method overriding.\n5. Dynamic dispatch: definition of method-call.\n6. Exception handling. (See also: SDF-Fundamentals, PDC-Coordination, SE-Construction)\n7. Object-oriented idioms for encapsulation:\na. Privacy, data hiding, and visibility of class members.\nb. Interfaces revealing only method signatures.\nc. Abstract base classes, traits and mixins.\n130\n8. Dynamic vs static properties.\n9. Composition vs inheritance.\n10. Subtyping:\na. Subtype polymorphism; implicit upcasts in typed languages.\nb. Notion of behavioral replacement: subtypes acting like supertype.\nc. Relationship between subtyping and inheritance.",
    "KA Core": "11. Collection classes, iterators, and other common library components.\n12. Metaprogramming and reflection.",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Enumerate the differences between imperative and object-oriented programming paradigms.\n2. Compose a class through design, implementation, and testing to meet behavioral requirements.\n3. Build a simple class hierarchy utilizing subclassing that allows code to be reused for distinct\nsubclasses.\n4. Predict and validate control flow in a program using dynamic dispatch.\n5. Compare and contrast how computational solutions to a problem differ in procedural, functional,\nand object-oriented approaches.\n6. Compare and contrast mechanisms to define and protect data elements within procedural,\nfunctional, and object-oriented approaches.\n7. Compare and contrast the benefits and costs/impact of using inheritance (subclasses) and\ncomposition (specifically, how to base composition on higher order functions).\n8. Explain the relationship between object-oriented inheritance (code-sharing and overriding) and\nsubtyping (the idea of a subtype being usable in a context that expects the supertype).\n9. Use object-oriented encapsulation mechanisms such as interfaces and private members.\n10. Define and use iterators and other operations on aggregates, including operations that take\nfunctions as arguments, in multiple programming languages, selecting the most natural idioms for\neach language. (See also: FPL-Functional)",
      "KA Core": "11. Use collection classes and iterators effectively to solve a problem."
    }
  },
  {
    "title": "FPL-Functional: Functional Programming",
    "CS Core": "1. Develop basic algorithms that avoid assigning to mutable states or considering reference equality.\n2. Develop useful functions that take and return other functions.\n3. Compare and contrast how computational solutions to a problem differ in procedural, functional,\nand object-oriented approaches.\n4. Compare and contrast mechanisms to define and protect data elements within procedural,\nfunctional, and object-oriented approaches.",
    "KA Core": "5. Explain a simple example of lambda expression being implemented using a virtual machine, such\nas a SECD machine, showing storage and reclaim of the environment.\n6. Correctly interpret variables and lexical scope in a program using function closures.\n7. Use functional encapsulation mechanisms such as closures and modular interfaces.\n8. Compare and contrast stateful vs stateless execution.\n9. Define and use iterators and other operations on aggregates, including operations that take\nfunctions as arguments, in multiple programming languages, selecting the most natural idioms for\neach language. (See also: FPL-OOP)",
    "Non-core": "10. Illustrate graph reduction using a λ-expression using a shared subexpression.\n11. Illustrate the execution of a simple nested λ-expression using an abstract machine, such as an ABC\nmachine.\n12. Illustrate narrowing, residuation, and semantic unification using simple illustrative examples.\n132\n13. Illustrate the concurrency constructs using simple programming examples of known concepts such\nas a buffer being read and written concurrently or sequentially. (See also: FPL-OOP)"
  },
  {
    "title": "FPL-Logic: Logic Programming",
    "KA Core": "1. Use a logic language to implement a conventional algorithm.\n2. Use a logic language to implement an algorithm employing implicit search using clauses, relations,\nand cuts.\n3. Use a simple illustrative example to show correspondence between First Order Predicate Logic\n(FOPL) and logic programs using Horn clauses.\n4. Use examples to illustrate the unification algorithm and its role of parameter-passing in query\nreduction.\n5. Use simple logic programs interleaving relations, functions, and recursive programming such as\nfactorial and Fibonacci numbers and simple complex relationships between entities and illustrate\nexecution and parameter-passing using unification and backtracking.",
    "Non-core": "6. Illustrate computation of simple programs such as Fibonacci and show overhead of recomputation,\nand then show how to improve execution overhead."
  },
  {
    "title": "FPL-Scripting: Shell Scripting",
    "CS Core": "1. Create and execute automated scripts to manage various system tasks.\n2. Solve various text processing problems through scripting."
  },
  {
    "title": "FPL-Event-Driven: Event-Driven and Reactive Programming",
    "CS Core": "1. Implement event handlers for use in reactive systems, such as GUIs.\n2. Examine why an event-driven programming style is natural in domains where programs react to\nexternal events.",
    "KA Core": "3. Define and use a reactive framework.\n134\n4. Describe an interactive system in terms of a model, a view, and a controller."
  },
  {
    "title": "FPL-Parallel: Parallel and Distributed Computing",
    "CS Core": "1. Explain why programming languages do not guarantee sequential consistency in the presence of\ndata races and what programmers must do as a result.\n2. Implement correct concurrent programs using multiple programming models, such as shared\nmemory, actors, futures, synchronization constructs, and data-parallelism primitives.\n3. Use a message-passing model to analyze a communication protocol.\n4. Use synchronization constructions such as monitor/synchronized methods in a simple program.\n5. Modeling data dependency using simple programming constructs involving variables, read and\nwrite.\n6. Modeling control dependency using simple constructs such as selection and iteration.",
    "KA Core": "7. Explain how REST API's integrate applications and automate processes.\n8. Explain benefits, constraints and challenges related to distributed and parallel computing."
  },
  {
    "title": "FPL-Aspect: Aspect-Oriented Programming",
    "Non-core": "1. Aspects\n2. Join points\n3. Advice\na. Before\nb. After (as finally, returning or throwing)\nc. Around\n4. Point cuts\na. Designators\n5. Weaving – static and dynamic\n6. Alternatives including annotations and IDEs"
  },
  {
    "title": "FPL-Types: Type Systems",
    "CS Core": "1. Describe, for both a primitive and a compound type, the values that have that type.\n137\n2. Describe, for a language with a static type system, the operations that are forbidden statically, such\nas passing the wrong type of value to a function or method.\n3. Describe examples of program errors detected by a type system.\n4. Identify program properties, for multiple programming languages, that are checked statically and\nprogram properties that are checked dynamically.\n5. Describe an example program that does not type-check in a particular language and yet would have\nno error if run.\n6. Use types and type-error messages to write and debug programs.",
    "KA Core": "7. Explain how typing rules define the set of operations that are legal for a type.\n8. List the type rules governing the use of a particular compound type.\n9. Explain why undecidability requires type systems to conservatively approximate program behavior.\n10. Define and use program pieces (such as functions, classes, methods) that use generic types,\nincluding for collections.\n11. Discuss the differences among generics, subtyping, and overloading.\n12. Explain multiple benefits and limitations of static typing in writing, maintaining, and debugging\nsoftware.",
    "Non-core": "13. Define a type system precisely and compositionally.\n14. For various foundational type constructors, identify the values they describe and the invariants they\nenforce.\n15. Precisely describe the invariants preserved by a sound type system.\n16. Prove type safety for a simple language in terms of preservation and progress theorems.\n17. Implement a unification-based type-inference algorithm for a simple language.\n18. Explain how static overloading and associated resolution algorithms influence the dynamic behavior\nof programs."
  },
  {
    "title": "FPL-Systems: Systems Execution and Memory Model",
    "CS Core": "1. Explain how a core language construct, such as data abstractions and control abstractions, is\nexecuted.\n2. Explain how programming language implementations typically organize memory into global data,\ntext, heap, and stack sections and how features such as recursion and memory management map\nto this memory model.\n3. Explain why memory leaks and dangling pointer problems occur, and what can be done by a\nprogrammer to avoid/fix them."
  },
  {
    "title": "FPL-Translation: Language Translation and Execution",
    "CS Core": "1. Explain and understand the differences between compiled, JIT, and interpreted language\nimplementations, including the benefits and limitations of each.\n2. Differentiate syntax and parsing from semantics and evaluation.\n139\n3. Use BNF and extended BNF to specify the syntax of simple constructs such as if-then-else, type\ndeclaration and iterative constructs for known languages such as C++ or Python.\n4. Illustrate the parse tree using a simple sentence/arithmetic expression.\n5. Illustrate translation of syntax diagrams to BNF/extended BNF for simple constructs such as if-then-\nelse, type declaration, iterative constructs, etc.\n6. Illustrate ambiguity in parsing using nested if-then-else/arithmetic expression and show resolution\nusing precedence order.\nKA-Core:\n7. Discuss the benefits and limitations of garbage collection, including the notion of reachability.",
    "KA Core": "9. Run-time representation of core language constructs such as objects (method tables) and functions\nthat can be passed as parameters to and returned from functions (closures)\n10. Secure compiler development (See also: SEC-Foundations, SEC-Coding)\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Abstraction: Program Abstraction and Representation",
    "KA Core": "1. Illustrate the scope of variables and visibility using simple programs.\n2. Illustrate different types of parameter-passing using simple pseudo programming language.\n3. Explain side-effect using global and nonlocal variables and how to fix such programs.\n4. Explain how programs that process other programs treat the other programs as their input data.\n5. Describe a grammar and an abstract syntax tree for a small language.\n6. Describe the benefits of having program representations other than strings of source code.\n7. Implement a program to process some representation of code for some purpose, such as an\ninterpreter, an expression optimizer, or a documentation generator.",
    "Non-core": "10. L-values and R-values: mapping mutable variable-name to L-values; mapping immutable variable-\nnames to R-values\n11. Environment vs store and their properties\n12. Data and control abstraction\n13. Mechanisms for information exchange between program units such as procedures, functions, and\nmodules: nonlocal variables, global variables, parameter-passing, import-export between modules\n14. Data structures to represent code for execution, translation, or transmission.\n15. Low level instruction representation such as virtual machine instructions, assembly language, and\nbinary representation (See also: AR-Representation, AR-Assembly)\n16. Lambda calculus, variable binding, and variable renaming. (See also: AL-Models, FPL-Formalism)\n17. Types of semantics: operational, axiomatic, denotational, behavioral; define and use abstract\nsyntax trees; contrast with concrete syntax.\n140\nIllustrative learning outcomes:"
  },
  {
    "title": "FPL-Syntax: Syntax Analysis",
    "Non-core": "1. Use formal grammars to specify the syntax of languages.\n2. Illustrate the role of lookahead tables in parsing.\n3. Use declarative tools to generate parsers and scanners.\n4. Recognize key issues in syntax definitions: ambiguity, associativity, precedence."
  },
  {
    "title": "FPL-Semantics: Compiler Semantic Analysis",
    "Non-core": "1. Draw the abstract syntax tree for a small language.\n2. Implement context-sensitive, source-level static analyses such as type-checkers or resolving\nidentifiers to identify their binding occurrences.\n3. Describe semantic analyses using an attribute grammar."
  },
  {
    "title": "FPL-Analysis: Program Analysis and Analyzers",
    "Non-core": "1. Explain the difference between dataflow graph and control flow graph.\n2. Explain why non-trivial sound program analyses must be approximate.\n3. Argue why an analysis is correct (sound and terminating).\n4. Explain why potential aliasing limits sound program analysis and how alias analysis can help.\n5. Use the results of a program analysis for program optimization and/or partial program correctness."
  },
  {
    "title": "FPL-Code: Code Generation",
    "Non-core": "1. Identify all essential steps for automatically converting source code into assembly or other low-level\nlanguages.\n2. Explain the low-level code necessary for calling functions/methods in modern languages.\n3. Discuss why separate compilation requires uniform calling conventions.\n4. Discuss why separate compilation limits optimization because of unknown effects of calls.\n5. Discuss opportunities for optimization introduced by naive translation and approaches for achieving.\noptimization, such as instruction selection, instruction scheduling, register allocation, and peephole\noptimization."
  },
  {
    "title": "FPL-Run-Time: Run-time Behavior and Systems",
    "Non-core": "1. Discuss benefits and limitations of automatic memory management.\n2. Explain the use of metadata in run-time representations of objects and activation records, such as\nclass pointers, array lengths, return addresses, and frame pointers.\n3. Compare and contrast static allocation vs stack-based allocation vs heap-based allocation of data\nelements.\n4. Explain why some data elements cannot be automatically deallocated at the end of a\nprocedure/method call (need for garbage collection).\n5. Discuss advantages, disadvantages, and difficulties of just-in-time and dynamic recompilation.\n6. Discuss the use of sandboxing in mobile code.\n7. Identify the services provided by modern language run-time systems."
  },
  {
    "title": "FPL-Constructs: Advanced Programming Constructs",
    "Non-core": "1. Use various advanced programming constructs and idioms correctly.\n2. Discuss how various advanced programming constructs aim to improve program structure, software\nquality, and programmer productivity.\n3. Discuss how various advanced programming constructs interact with the definition and\nimplementation of other language features."
  },
  {
    "title": "FPL-Pragmatics: Language Pragmatics",
    "Non-core": "1. Discuss the role of concepts such as orthogonality and well-chosen defaults in language design.\n2. Objectively evaluate and justify language-design decisions.\n3. Implement an example program whose result can differ under different rules for evaluation order,\nprecedence, or associativity.\n4. Illustrate uses of delayed evaluation, such as user-defined control abstractions.\n5. Discuss the need for allowing calls to external calls and system libraries and the consequences for\nlanguage implementation."
  },
  {
    "title": "FPL-Formalism: Formal Semantics",
    "Non-core": "1. Construct formal semantics for a small language.\n2. Write a lambda-calculus program and show its evaluation to a normal form.\n3. Discuss the different approaches of operational, denotational, and axiomatic semantics.\n4. Use induction to prove properties of all programs in a language.\n145\n5. Use induction to prove properties of all programs in a language that is well-typed according to a\nformally defined type system.\n6. Use parametricity to establish the behavior of code given only its type."
  },
  {
    "title": "FPL-Methodologies: Formal Development Methodologies",
    "Non-core": "1. Use formal modeling techniques to develop and validate architectures.\n2. Use proof assisted programming languages to develop fully specified and verified software artifacts.\n3. Use verifier and specification support in programming languages to formally validate system\nproperties.\n4. Integrate symbolic validation tooling into a programming workflow.\n5. Discuss when and how formal methods can be effectively used in the development process."
  },
  {
    "title": "FPL-Design: Design Principles of Programming Languages",
    "Non-core": "1. Language design principles\na. Simplicity\nb. Security (See also: SEC-Coding)\nc. Fast translation\nd. Efficient object code\ne. Orthogonality\nf. Readability\ng. Completeness\nh. Implementation strategies\n2. Designing a language to fit a specific domain or problem\n3. Interoperability between programming languages\n4. Language portability\n5. Formal description of a programming language\n6. Green computing principles (See also: SEP-Sustainability)\n146",
    "Illustrative Learning Outcomes": {
      "Non-core": "1. Understand what constitutes good language design and apply that knowledge to evaluate a real\nprogramming language."
    }
  },
  {
    "title": "FPL-SEP: Society, Ethics, and the Profession",
    "Non-core": "1. Consciously design programming languages to be inclusive and non-offensive.\nProfessional Dispositions\n1. Professional: Students must demonstrate and apply the highest standards when using\nprogramming languages and formal methods to build safe systems that are fit for their purpose.\n2. Meticulous: Attention to detail is essential when using programming languages and applying\nformal methods.\n3. Inventive: Programming and approaches to formal proofs is inherently a creative process, students\nmust demonstrate innovative approaches to problem solving. Students are accountable for their\nchoices regarding the way a problem is solved.\n4. Proactive: Programmers are responsible for anticipating all forms of user input and system\nbehavior and to design solutions that address each one.\n5. Persistent: Students must demonstrate perseverance since the correct approach is not always\nself-evident and a process of refinement may be necessary to reach the solution.\nMathematics Requirements\nRequired:\n● Discrete Mathematics – Boolean algebra, proof techniques, digital logic, sets and set\noperations, mapping, functions and relations, states and invariants, graphs and relations, trees,\ncounting, recurrence relations, finite state machine, regular grammar. (See also: MSF-Discrete)\n● Logic – propositional logic (negations, conjunctions, disjunctions, conditionals, biconditionals),\nfirst-order logic, logical reasoning (induction, deduction, abduction). (See also: MSF-Discrete)\n147\n● Mathematics – Matrices, probability, statistics. (See also: MSF-Probability, MSF-Statistics)\nCourse Packaging Suggestions\nCourse\nTwo example courses are presented illustrating how the content may be covered. The first is an\nintroductory course which covers the CS Core and KA Core content. This course focuses on the\ndifferent programming paradigms and ensures familiarity with each to a level sufficient to be able to\ndecide which paradigm is appropriate in each circumstance.\nThe second course is an advanced course focused on the implementation of a programming language,\nthe formal description of a programming language and a formal description of the behavior of a\nprogram.\nWhile these two courses have been the predominant way to cover this knowledge area over the past\ndecade, it is by no means the only way that this content can be covered. Institutions can, for example,\nchoose to cover only the CS Core content (24 hours) as part of one or spread over multiple courses\n(e.g., Software Engineering). Natural combinations are easily identifiable since they are the areas in\nwhich the Foundations of Programming Languages knowledge area overlaps with other knowledge\nareas. Such overlaps have been identified throughout this knowledge area.\nProgramming Language Concepts (Introduction) Course to include the following:\n● FPL-OOP: Object-Oriented Programming (6 hours)\n● FPL-Functional: Functional Programming (7 hours)\n● FPL-Logic: Logic Programming (3 hours)\n● FPL-Scripting: Shell Scripting (2 hours)\n● FPL-Event-Driven: Event-Driven and Reactive Programming (4 hours)\n● FPL-Parallel: Parallel and Distributed Computing (5 hours)\n● FPL-Types: Type Systems (6 hours)\n● FPL-Systems: Systems Execution and Memory Model (3 hours)\n● FPL-Translation: Language Translation and Execution (5 hours)\n● FPL-Abstraction: Program Abstraction and Representation (3 hours)\n● FPL-SEP: Society, Ethics, and the Profession (1 hour)\nPrerequisites:\n● Discrete Mathematics – Boolean algebra, proof techniques, digital logic, sets and set\noperations, mapping, functions and relations, states and invariants, graphs and relations, trees,\ncounting, recurrence relations, finite state machine, regular grammar. (See also: MSF-Discrete).\nProgramming Language Implementation (Advanced) Course to include the following:\n● FPL-Types: Type Systems (3 hours)\n● FPL-Translation: Language Translation and Execution (2 hours)\n● FPL-Syntax: Syntax Analysis(3 hours)\n● FPL-Semantics: Compiler Semantic Analysis (5 hours)\n● FPL-Analysis: Program Analysis and Analyzers (5 hours)\n148\n● FPL-Code: Code Generation(5 hours)\n● FPL-Run-Time: Run-time Systems (4 hours)\n● FPL-Constructs: Advanced Programming Constructs (4 hours)\n● FPL-Pragmatics: Language Pragmatics (3 hours)\n● FPL-Formalism: Formal Semantics (5 hours)\n● FPL-Methodologies: Formal Development Methodologies (5 hours)\nPrerequisites:\n● Discrete mathematics – Boolean algebra, proof techniques, digital logic, sets and set\noperations, mapping, functions and relations, states and invariants, graphs and relations, trees,\ncounting, recurrence relations, finite state machine, regular grammar (See also: MSF-Discrete).\n● Logic – propositional logic (negations, conjunctions, disjunctions, conditionals, biconditionals),\nfirst-order logic, logical reasoning (induction, deduction, abduction). (See also: MSF-Discrete).\n● Introductory programming course (See also: SDF-Fundamentals).\n● Programming proficiency in programming concepts such as: (See also: SDF-Fundamentals):\n● Type declarations such as basic data types, records, indexed data elements such as arrays\nand vectors, and class/subclass declarations, types of variables\n● Scope rules of variables\n● Selection and iteration concepts, function and procedure calls, methods, object creation\n● Data structure concepts such as: (See also: SDF-DataStructures):\n● Abstract data types, sequence and string, stack, queues, trees, dictionaries (See also: SDF-\nData-Structures)\n● Pointer-based data structures such as linked lists, trees, and shared memory locations (See\nalso: SDF-Data-Structures, AL-Foundational)\n● Hashing and hash tables (See also: SDF-Data-Structures, AL-Foundational)\n● System fundamentals and computer architecture concepts such as (See also: SF-Foundations):\n● Digital circuits design, clocks, bus (See also: OS-Principles)\n● registers, cache, RAM, and secondary memory (See also: OS-Memory)\n● CPU and GPU (See also: AR-Heterogeneity)\n● Basic knowledge of operating system concepts such as\n● Interrupts, threads and interrupt-based/thread-based programming (See also: OS-\nConcurrency)\n● Scheduling, including prioritization (See also: OS-Scheduling)\n● Memory fragmentation (See also: OS-Memory)\n● Latency\nCommittee\nChair: Michael Oudshoorn, High Point University, High Point, NC, USA\nMembers:\n● Annette Bieniusa, TU Kaiserslautern, Kaiserslautern, Germany\n● Brijesh Dongol, University of Surrey, Guildford, UK\n● Michelle Kuttel, University of Cape Town, Cape Town, South Africa\n● Doug Lea, State University of New York at Oswego, Oswego, NY, USA\n149\n● James Noble, Victoria University of Wellington, Wellington, New Zealand\n● Mark Marron, Microsoft Research, Seattle, WA, USA and University of Kentucky, Lexington, KY,\nUSA\n● Peter-Michael Osera, Grinnell College, Grinnell, IA, USA\n● Michelle Mills Strout, University of Arizona, Tucson, AZ, USA\nContributors:\n● Alan Dearle, University of St. Andrews, St. Andrews, Scotland\n150\nGraphics and Interactive Techniques (GIT)\nPreamble\nComputer graphics is the term used to describe the computer generation and manipulation of images\nand can be viewed as the science of enabling visual communication through computation. Its\napplication domains include animation, Computer Generated Imagery (CGI) and Visual Effects (VFX);\nengineering; machine learning; medical imaging; scientific, information, and knowledge visualization;\nsimulators; special effects; user interfaces; and video games. Traditionally, graphics at the\nundergraduate level focused on rendering, linear algebra, physics, the graphics pipeline, interaction,\nand phenomenological approaches. Today’s graphics courses increasingly include data science,\nphysical computing, animation, and haptics. Thus, the knowledge area (KA) expanded beyond core\nimage-based computer graphics. At the advanced level, undergraduate institutions are more likely to\noffer one or several courses specializing in a specific graphics knowledge unit (KU) or topic: e.g.,\ngaming, animation, visualization, tangible or physical computing, and immersive courses such as\nAugmented Reality (AR)/Virtual Reality (VR)/eXtended Reality (XR). There is considerable connection\nwith other computer science knowledge areas (KAs): Algorithmic Foundations, Architecture and\nOrganization, Artificial Intelligence; Human-Computer Interaction; Parallel and Distributed Computing;\nSpecialized Platform Development; Software Engineering; and Society, Ethics, and the Profession.\nFor students to become adept at the use and generation of computer graphics and interactive\ntechniques, many issues must be addressed, such as human perception and cognition, data and image\nfile formats, display specifications and protocols, hardware interfaces, and application program\ninterfaces (APIs). Unlike other knowledge areas, knowledge units within Graphics and Interactive\nTechniques may be included in a variety of elective courses. Alternatively, graphics topics may be\nintroduced in an applied project in courses primarily covering human computer interaction, embedded\nsystems, web development, introductory programming courses, etc. Undergraduate computer science\nstudents who study the knowledge units specified below through a balance of theory and applied\ninstruction will be able to understand, evaluate, and/or implement the related graphics and interactive\ntechniques as users and developers. Because technology changes rapidly, the Graphics and\nInteractive Techniques subcommittee attempted to avoid being overly prescriptive. Any examples of\nAPIs, programs, and languages should be considered as appropriate examples in 2023. In effect, this is\na snapshot in time.\nGraphics as a knowledge area has expanded and become pervasive since the CS2013 report.\nAR/VR/XR, artificial intelligence, computer vision, data science, machine learning, and interfaces driven\nby embedded sensors in everything from cars to coffee makers use graphics and interactive\ntechniques. The now ubiquitous smartphone has made much of the world’s population regular users\nand creators of graphics, digital images, and the interactive techniques to manipulate them. Animations,\ngames, visualizations, and immersive applications that ran on desktops in 2013, now can run on mobile\ndevices. The amount of stored digital data grew exponentially since 2013, and both data and\nvisualizations are now published by myriad sources including news media and scientific organizations.\nRevenue from mobile video games now exceeds that of music and movies combined [1]. CGI and VFX\nare employed in almost all films, animations, TV productions, advertising, and business graphics. The\n151\nnumber of people who create graphics has skyrocketed, as have the number of applications and\ngenerative tools used to produce graphics.\nIt is critical that students and faculty confront the ethical issues, questions, and conundrums that have\narisen and will continue to arise in and because of applications in computer graphics. Today’s\nheadlines unfortunately already provide examples of inequity and/or wrong-doing in autonomous\nnavigation, deepfakes, computational photography, generative images, and facial recognition.\nOverview of Knowledge Units\nThe following knowledge units are included in Graphics and Interactive Techniques. Descriptions are\nincluded below where they are not explicitly evident from the title. Graphics as a knowledge area is\nunique in that many of its knowledge units can and are taught as stand-alone courses where\nimplementation projects are critical to student mastery. Apart from Applied Rendering and Techniques\nwhich scaffolds the typical undergraduate interactive computer graphics course, the other knowledge\nunit are more specialized. To be consistent with the design of CS2023 those knowledge unit are limited\nto two weeks of instruction, corresponding roughly to 6 hours of instruction. This limitation allows a two-\nweek knowledge unit to be added to a course. Due to that time restriction, we list their Core Topic skill\nlevels in most of the knowledge units as “Explain.” However, if one of the thematic knowledge units is\nimplemented as a full-term course, our expectation is that the skill levels will rise to “Apply” or “Develop”\nwhich is reflected in many of the practical illustrative learning outcomes. This is not meant to be\nprescriptive but to encourage customization. How to implement a knowledge unit is left to the discretion\nof the instructor. If given a two-week constraint to teach one of the thematic knowledge units, many of\nus would choose to limit the topics and include an applied project. Our hope is that an inclusive list of\ntopics will help faculty design a course that best meets their and their department’s pedagogical goals.\n● GIT-Fundamentals: Fundamental Concepts. For nearly every computer scientist and\nsoftware developer, understanding of how humans interact with machines is essential.\n● GIT-Visualization: Visualization. Visualization seeks to determine and present underlying\ncorrelated structures and relationships in data sets from a wide variety of application areas. The\nprime objective is to communicate the information in a way which enhances understanding.\n● GIT-Rendering: Applied Rendering and Techniques. This unit includes basic rendering and\nfundamental graphics techniques that nearly every undergraduate course in graphics will cover\nand that are essential for further study in most graphics-related courses.\n● GIT-Modeling: Geometric Modeling. Graphics must be encoded in computer memory, often in\nthe form of a mathematical specification of shape and form.\n● GIT-Shading: Shading and Advanced Rendering. This unit contains more in-depth coverage\nof rendering topics.\n● GIT-Animation: Computer Animation. Computer Animation is concerned with the generation\nof moving imagery.\n● GIT-Simulation: Simulation. Simulation has strong ties to Computational Science. However, in\nthe graphics domain, simulation techniques are re-purposed to a different end. Rather than\ncreating predictive models, the goal instead is to achieve a mixture of physical plausibility and\n152\nartistic intention. To illustrate, the goals of “model surface tension in a liquid” and “produce a\ncrown splash” are related, but different. Depending on the simulation goals, covered topics may\nvary as shown.\n● Particle systems\n○ Integration methods (Forward Euler, Midpoint, Leapfrog)\n● Rigid Body Dynamics\n○ Particle systems\n○ Collision Detection\n○ Triangle/point\n○ Edge/edge\n● Cloth\n○ Particle systems\n○ Mass/spring networks\n○ Collision Detection\n● Particle-Based Water\n○ Integration methods\n○ Smoother Particle Hydrodynamics (SPH) Kernels\n○ Signed Distance Function-Based Collisions\n● Grid-Based Smoke and Fire\n○ Semi-Lagrangian Advection\n○ Pressure Projection\n● Grid and Particle-Based Water\n○ Particle-Based Water\n● Grid-Based Smoke and Fire\n○ Semi-Lagrangian Advection\n○ Pressure Projection\n● Grid and Particle-Based Water\n○ Particle-Based Water\n○ Grid-Based Smoke, and Fire\n● GIT-Immersion: Immersion. Immersion includes Augmented Reality (AR), Virtual Reality (VR),\nand Mixed Reality (MR).\n● GIT-Interaction: Interaction. Interactive computer graphics is a requisite part of real-time\napplications ranging from the utilitarian-like word processors to virtual and/or augmented reality\napplications.\n● GIT-Image: Image Processing. Image Processing consists of the analysis and processing of\nimages for multiple purposes, but most frequently to improve image quality and to manipulate\nimagery. It lies at the cornerstone of computer vision.\n● GIT-Physical: Tangible/Physical Computing. Tangible/Physical Computing refers to\nmicrocontroller-based interactive systems that detect and respond to sensor input.\n● GIT-SEP: Society, Ethics, and the Profession.\n153\nChanges since CS2013\nIn order to align CS2013’s Graphics and Visualization areas with the ACM Special Interest Group on\nGraphic and Interactive Techniques (SIGGRAPH) and to reflect the natural expansion of the field to\ninclude haptic and physical computing in addition to images, we have renamed it Graphics and\nInteractive Techniques (GIT). To capture the expanded footprint of the knowledge area , the following\nfive knowledge units have been added to the original list consisting of Fundamental Concepts,\nVisualization, Basic Rendering (renamed Rendering), Geometric Modeling, Advanced Rendering\n(renamed Shading), and Computer Animation.\n● Immersion (MR, AR, VR)\n● Interaction\n● Image Processing\n● Tangible/Physical Computing\n● Simulation\nCore Hours\nKnowledge Unit CS Core KA Core\nFundamental Concepts 4 3\nVisualization 6\nApplied Rendering and 15\nTechniques\nGeometric Modeling 6\nShading and Advanced 6\nRendering\nComputer Animation 6\nSimulation 6\nImmersion (MR, AR, VR) 6\nInteraction 4\nImage Processing 6\nTangible/Physical Computing 6\nSociety, Ethics, and the Included in SEP hours\nProfession\n154\nTotal 4\nKnowledge Units"
  },
  {
    "title": "GIT-Fundamentals: Fundamental Concepts",
    "CS Core": "1. Uses of computer graphics and interactive techniques and their potential risks and abuses.\na. Entertainment, business, and scientific applications: e.g., visual effects, generative imagery,\ncomputer vision, machine learning, user interfaces, video editing, games and game engines,\ncomputer-aided design and manufacturing, data visualization, and virtual/augmented/mixed\nreality\nb. Intellectual property, deep fakes, facial recognition, privacy (See also: SEP-DEIA, SEP-Privacy,\nSEP-IP, SEP-Professional-Ethics)\n2. Graphic output\na. Displays (e.g., LCD)\nb. Printers\nc. Analog film\nd. Concepts\ni. Resolution (e.g., pixels, dots)\nii. Aspect ratio\niii. Frame rate\n3. Human vision system\na. Tristimulus reception (RGB)\nb. Eye as a camera (projection)\nc. Persistence of vision (frame rate, motion blur)\nd. Contrast (detection, Mach banding, dithering/aliasing)\ne. Non-linear response (dynamic range, tone mapping)\nf. Binocular vision (stereo)\ng. Accessibility (color deficiency, strobing, monocular vision, etc.) (See also: SEP-DEIA, HCI-User)\n4. Standard image formats\na. Raster\ni. Lossless (e.g., TIF)\nii. Lossy (e.g., JPG, GIF, etc.)\nb. Vector (e.g., SVG, Adobe Illustrator)\n5. Digitization of analog data\na. Rasterization\nb. Resolution\nc. Sampling and quantization\n6. Color models: additive (RGB), subtractive (CMYK), and color perception (HSV)\n7. Tradeoffs between storing image data and re-computing image data\n8. Spatialization: coordinate systems, absolute and relative positioning\n9. Animation as a sequence of still images\n155",
    "KA Core": "10. Applied interactive graphics (e.g., processing, python)\n11. Display characteristics (protocols and ports)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Identify common uses of digital presentation to humans (e.g., computer graphics, sound).\n2. Describe how analog signals can be reasonably represented by discrete samples, for example, how\nimages can be represented by pixels.\n3. Compute the memory requirement for storing a color image given its resolution.\n4. Create a graphic depicting how the limits of human perception affect choices about the digital\nrepresentation of analog signals.\n5. Indicate when and why you should use each of the following common file formats: JPG, PNG, MP3,\nMP4, and GIF.\n6. Describe color models and their use in graphics display devices.\n7. Compute the memory requirements for a multi-second movie (lasting n seconds) displaying at a\nspecific framerate (f frames per second) at a specified resolution (r pixels per frame)\n8. Compare and contrast digital video to analog video.\n9. Describe the basic process of producing continuous motion from a sequence of discrete frames\n(sometimes called “flicker fusion”).\n10. Describe a possible visual misrepresentation that could result from digitally sampling an analog\nworld.\n11. Compute memory space requirements based on resolution and color coding.\n12. Compute time requirements based on refresh rates and rasterization techniques.",
      "KA Core": "13. Design a user interface and an alternative for persons with color perception deficiency.\n14. Construct a simple graphical user interface using a graphics library."
    }
  },
  {
    "title": "GIT-Visualization: Visualization",
    "KA Core": "1. Scientific Data Visualization and Information Visualization\n2. Visualization techniques\na. Statistical visualization (e.g., scatterplots, bar graphs, histograms, line graphs, pie charts, trees,\nand graphs)\nb. Text visualization\nc. Geospatial visualization\nd. 2D/3D scalar fields\ne. Vector fields\nf. Direct volume rendering\n3. Visualization pipeline\na. Structuring data\nb. Mapping data to visual representations (e.g., scales, grammar of graphics)\nc. View transformations (e.g., pan, zoom, filter, select)\n156\n4. Common data formats (e.g., HDF, netCDF, geotiff, GeoJSON, shape files, raw binary, JSON, CSV,\nplain text)\n5. High-dimensional data handling techniques\na. Statistical (e.g., averaging, clustering, filtering)\nb. Perceptual (e.g., multi-dimensional vis, parallel coordinates, trellis plots)\n6. Perceptual and cognitive foundations that drive visual abstractions.\na. Human optical system\nb. Color theory\nc. Gestalt theories\n7. Design and evaluation of visualizations\na. Purpose (e.g., analysis, communication, aesthetics)\nb. Accessibility\nc. Appropriateness of encodings\nd. Misleading visualizations",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Compare and contrast data visualization and information visualization.\n2. Deploy basic algorithms for visualization.\n3. Compare the tradeoffs of visualization algorithms in terms of accuracy and performance.\n4. Design a suitable visualization for a particular combination of data characteristics, application tasks,\nand audience.\n5. Analyze the effectiveness of a given visualization for a particular task.\n6. Design a process to evaluate the utility of a visualization algorithm or system.\n7. Identify a variety of applications of visualization including representations of scientific, medical, and\nmathematical data; flow visualization; and spatial analysis."
    }
  },
  {
    "title": "GIT-Rendering: Applied Rendering and Techniques",
    "KA Core: (See also: SPD-Game)": "1. Object and scene modeling\na. Object representations: polygonal, parametric, etc.\nb. Modeling transformations: affine and coordinate-system transformations\nc. Scene representations: scene graphs\n2. Camera and projection modeling\na. Pinhole cameras, similar triangles, and projection model\nb. Camera models\nc. Projective geometry\n3. Radiometry and light models\na. Radiometry\nb. Rendering equation\nc. Rendering in nature – emission and scattering, etc.\n4. Rendering\na. Simple triangle rasterization\nb. Rendering with a shader-based API\n157\nc. Visibility and occlusion, including solutions to this problem (e.g., depth buffering, Painter’s\nalgorithm, and ray tracing)\nd. Texture mapping, including minification and magnification (e.g., trilinear MIP mapping)\ne. Application of spatial data structures to rendering.\nf. Ray tracing\ng. Sampling and anti-aliasing",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe and illustrate the light transport problem (i.e., light is emitted, scatters around the scene,\nand is measured by the eye).\n2. Describe the basic rendering pipeline.\n3. Compare and contrast how forward and backwards rendering factor into the graphics pipeline.\n4. Create a program to display 2D shapes in a window.\n5. Create a program to display 3D models.\n6. Produce linear perspective from similar triangles by converting points (x, y, z) to points (x/z, y/z, 1).\n7. Compute two-dimensional and 3-dimensional points by applying affine transformations.\n8. Indicate the changes required to extend 2D transformation operations to handle transformations in\n3D.\n9. Define texture mapping, sampling, and anti-aliasing, and describe examples of each.\n10. Compare ray tracing and rasterization for the visibility problem.\n11. Construct a program that performs transformation and clipping operations on simple two-\ndimensional shapes.\n12. Implement a simple real-time renderer using a rasterization API (e.g., OpenGL, webGL) using\nvertex buffers and shaders.\n13. Compare and contrast the different rendering techniques.\n14. Compare and contrast the difference in transforming the camera vs the models."
    }
  },
  {
    "title": "GIT-Modeling: Geometric Modeling",
    "KA Core": "1. Basic geometric operations such as intersection calculation and proximity tests on 2D objects\n2. Surface representation/model\na. Tessellation\nb. Mesh representation, mesh fairing, and mesh generation techniques such as Delaunay\ntriangulation, and marching cubes/tetrahedrons\nc. Parametric polynomial curves and surfaces\nd. Implicit representation of curves and surfaces\ne. Spatial subdivision techniques\n3. Volumetric representation/model\na. Volumes, voxels, and point-based representations.\nb. Signed Distance Fields\nc. Sparse Volumes, i.e., VDB\nd. Constructive Solid Geometry (CSG) representation\n4. Procedural representation/model\n158\na. Fractals\nb. L-Systems\n5. Multi-resolution modeling (See also: SPD-Game)\n6. Reconstruction, e.g., 3D scanning, photogrammetry",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Contrast representing curves and surfaces in both implicit and parametric forms.\n2. Create simple polyhedral models by surface tessellation.\n3. Create a mesh representation from an implicit surface.\n4. Create a fractal model or terrain using a procedural method.\n5. Create a mesh from data points acquired with a laser scanner.\n6. Create CSG models from simple primitives, such as cubes and quadric surfaces.\n7. Contrast modeling approaches with respect to space and time complexity and quality of image."
    }
  },
  {
    "title": "GIT-Shading: Shading and Advanced Rendering",
    "KA Core": "1. Solutions and approximations to the rendering equation, for example\na. Distribution ray tracing and path tracing\nb. Photon mapping\nc. Bidirectional path tracing\nd. Metropolis light transport\n2. Time (motion blur), lens position (focus), and continuous frequency (color) and their impact on\nrendering\n3. Shadow mapping\n4. Occlusion culling\n5. Bidirectional Scattering Distribution function (BSDF) theory and microfacets\n6. Subsurface scattering\n7. Area light sources\n8. Hierarchical depth buffering\n9. Image-based rendering\n10. Non-photorealistic rendering\n11. Realtime rendering\n12. GPU architecture (See also: AR-Heterogeneity)\n13. Human visual systems including adaptation to light, sensitivity to noise, and flicker fusion (See also:\nHCI-Accessibility, SEP-DEIA)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe how an algorithm estimates a solution to the rendering equation.\n2. Discuss the properties of a rendering algorithm (e.g., complete, consistent, and unbiased).\n3. Analyze the bandwidth and computation demands of a simple shading algorithm.\n4. Implement a non-trivial shading algorithm (e.g., toon shading, cascaded shadow maps) under a\nrasterization API.\n159\n5. State how a particular artistic technique might be implemented in a renderer.\n6. Describe how one might recognize the shading techniques used to create a particular image.\n7. Write a program that implements any of the specified graphics techniques using a primitive graphics\nsystem at the individual pixel level.\n8. Write a ray tracer for scenes using a simple (e.g., Phong’s) Bidirectional Reflection Distribution\nFunction (BRDF) plus reflection and refraction."
    }
  },
  {
    "title": "GIT-Animation: Computer Animation",
    "KA Core": "1. Principles of Animation: Squash and Stretch, Timing, Anticipation, Staging, Follow Through and\nOverlapping Action, Straight Ahead Action, and Pose-to-Pose Action, Slow In and Out, Arcs,\nExaggeration, and Appeal\n2. Types of animation\na. 2- and 3-dimensional animation\nb. Motion graphics\nc. Motion capture\nd. Motion graphics\ne. Stop animation\n3. Key-frame animation\na. Keyframe Interpolation Methods: Lerp/Slerp/Spline\n4. Forward and inverse kinematics (See also: SPD-Robot, AI-Robotics)\n5. Skinning algorithms\na. Capturing\nb. Linear blend, dual quaternion\nc. Rigging\nd. Blend shapes\ne. Pose space deformation\n6. Motion capture\na. Set up and fundamentals\nb. Blending motion capture clips\nc. Blending motion capture and keyframe animation\nd. Ethical considerations (See also: SEP-DEIA, SEP-Privacy)\ni. Avoidance of “default” captures - there is no typical human walk cycle.\nii. Accessibility",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Using a simple open-source character model and rig, describe visually why each of the principles of\nanimation is fundamental to realistic animation.\n2. Compute the location and orientation of model parts using a forward kinematic approach.\n3. Compute the orientation of articulated parts of a model from a location and orientation using an\ninverse kinematic approach.\n4. Compare the tradeoffs in different representations of rotations.\n160\n5. Write a script that implements the spline interpolation method for producing in-between positions\nand orientations.\n6. Deploy off-the-shelf animation software to construct, rig, and animate simple organic forms."
    }
  },
  {
    "title": "GIT-Simulation: Simulation",
    "KA Core": "1. Collision detection and response\na. Signed Distance Fields\nb. Sphere/sphere\nc. Triangle/point\nd. Edge/edge\n2. Procedural animation using noise\n3. Particle systems\na. Integration methods (e.g., forward Euler, midpoint, leapfrog)\nb. Mass/spring networks\nc. Position-based dynamics\nd. Rules (e.g., boids, crowds)\ne. Rigid bodies\n4. Grid-based fluids\na. Semi-Lagrangian advection\nb. Pressure projection\n5. Heightfields\na. Terrain: transport, erosion\nb. Water: ripple, shallow water.\n6. Rule-based systems (e.g., L-systems, space-colonizing systems, Game of Life)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Implement algorithms for physical modeling of particle dynamics using simple Newtonian\nmechanics (e.g., Witkin & Kass, snakes and worms, symplectic Euler, Stormer/Verlet, or midpoint\nEuler methods)\n2. Contrast the basic ideas behind fluid simulation methods for modeling ballistic trajectories (e.g., for\nsplashes, dust, fire, or smoke).\n3. Implement a smoke solver with user interaction."
    }
  },
  {
    "title": "GIT-Immersion: Immersion",
    "KA Core: (See also: SPD-Game, SPD-Mobile, HCI-Design)": "1. Immersion levels (i.e., Virtual Reality (VR), Augmented Reality (AR), and Mixed Reality (MR))\n2. Definitions of and distinctions between immersion and presence\n3. 360 Video\n4. Stereoscopic display\na. Head-mounted displays\nb. Stereo glasses\n161\n5. Viewer tracking\na. Inside out and outside In\nb. Head/Body/Hand/tracking\n6. Time-critical rendering to achieve optimal Motion To Photon (MTP) latency\na. Multiple Levels Of Details (LOD)\nb. Image-based VR\nc. Branching movies\n7. Distributed VR, collaboration over computer network\n8. Presence and factors that impact level of immersion\n9. 3D interaction\n10. Applications in medicine, simulation, training, and visualization\n11. Safety in immersive applications\na. Motion sickness\nb. VR obscures the real world, which increases the potential for falls and physical accidents",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Create a stereoscopic image.\n2. Design and write an AR or VR application.\n3. Summarize the pros and cons of different types of viewer tracking.\n4. Compare and contrast the differences between geometry- and image-based virtual reality.\n5. Analyze the design issues of user action synchronization and data consistency in a networked\nenvironment.\n6. Create the specifications for an augmented reality application to be used by surgeons in the\noperating room.\n7. Assess an immersive application’s accessibility (See also: HCI-Accessibility, SEP-DEIA)\n8. Identify the most important technical characteristics of a VR system/application that should be\ncontrolled to avoid motion sickness and explain why."
    }
  },
  {
    "title": "GIT-Interaction: Interaction",
    "KA Core": "1. Event Driven Programming (See also: FPL-Event-Driven)\na. Mouse or touch events\nb. Keyboard events\nc. Voice input\nd. Sensors\ne. Message passing communication\nf. Network events\n2. Graphical User Interface (Single Channel)\na. Window\nb. Icons\nc. Menus\nd. Pointing Devices\n3. Accessibility (See also: SEP-DEIA)\n162",
    "Non-core": "4. Gestural Interfaces (See also: SPD-Game)\na. Touch screen gestures\nb. Hand and body gestures\n5. Haptic Interfaces\na. External actuators\nb. Gloves\nc. Exoskeletons\n6. Multimodal Interfaces\n7. Head-worn Interfaces\na. Brain-computer interfaces, e.g., Electroencephalography (EEG) electrodes and Multi-Electrode\nArrays (MEAs)\nb. Headsets with embedded eye tracking\nc. AR glasses\n8. Natural Language Interfaces (See also: AI-NLP)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Create a simple game that responds to single channel mouse and keyboard events.\n2. Create a mobile app that responds to touch events.\n3. Design and create an application that responds to different event triggers.\nNone-core:\n4. Assess the consistency or lack of consistency in cross-platform touch screen gestures.\n5. Design and create an application that provides haptic feedback.\n6. Write a program that is controlled by gestures."
    }
  },
  {
    "title": "GIT-Image: Image Processing",
    "KA Core: (See also: AI-Vision)": "1. Morphological operations\na. Connected components\nb. Dilation\nc. Erosion\nd. Computing region properties (area, perimeter, centroid, etc.)\n2. Color histograms\na. Representation\nb. Contrast enhancement through normalization\n3. Image enhancement\na. Convolution\nb. Blur (e.g., Gaussian)\nc. Sharpen (e.g., Laplacian)\nd. Frequency filtering (e.g., low-pass, high-pass)\n4. Image restoration\n163\na. Noise, degradation\nb. Inpainting and other completion algorithms\nc. Wiener filter\n5. Image coding\na. Redundancy\nb. Compression (e.g., Huffman coding)\nc. Discrete Cosine Transform (DCT), wavelet transform, Fourier transforms (See also: SPD-\nInteractive)\nd. Nyquist Theorem\ne. Watermarks\n6. Connections to deep learning (e.g., Convolutional Neural Networks) (See also: AI-ML)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Write a program that uses dilation and erosion to smooth the edges of a binary image.\n2. Manipulating the hue of an image.\n3. Write a program that applies a high-pass filter to an image. (The advanced variation would be to\nfilter an image using a high-pass filter in the frequency domain.)\n4. Write a program that restores missing parts of an image using an in-paint algorithm (e.g., Poisson\nimage editing)\n5. Assess the results of selectively filtering an image in the frequency domain."
    }
  },
  {
    "title": "GIT-Physical: Tangible/Physical Computing",
    "KA Core": "1. Interaction with the physical world (See also: SPD-Embedded)\na. Acquisition of data from sensors\nb. Driving external actuators\n2. Connection to physical artifacts\na. Computer-Aided Design (CAD)\nb. Computer-Aided Manufacturing (CAM)\nc. Fabrication (See also: HCI-Design)\ni. Prototyping\nii. Additive (3D printing)\niii. Subtractive (Computer Numerical Control (CNC) milling)\niv. Forming (vacuum forming)\n3. Internet of Things (See also: SPD-Interactive)\na. Network connectivity\nb. Wireless communication",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Construct a simple virtual switch or application button and use it to turn on an LED.\n2. Construct a simple system to move a servo in response to sensor data.\n164\n3. Create a circuit and accompanying microcontroller code that uses a light sensor to vary a property\nof something else (e.g., color or brightness of an LED or graphic, position of an external actuator).\n4. Create a circuit with a variable resistor and write a microcontroller program that reads and responds\nto the resistor’s changing values.\n5. Create a 3D form in a CAD package.\na. Show how affine transformations are achieved in the CAD program.\nb. Show an example of instances of an object.\nc. Create a fabrication plan. Provide a cost estimate for materials and time. How will you fabricate\nit?\nd. Fabricate it. How closely did your actual fabrication process match your plan? Where did it\ndiffer?\n6. Write the G- and M-Code to construct a 3D maze and use a CAD/CAM package to check your\nwork.\n7. Decide and defend your decision to use Ethernet, WiFi, Bluetooth, RFID/NFC, or something else for\ninternet connectivity when designing an IoT pill dispenser. Create an IoT pill dispenser.\n8. Distinguish between the different types of fabrication and describe when you would use each."
    }
  },
  {
    "title": "GIT-SEP: Society, Ethics, and the Profession",
    "KA Core": "1. Accessibility in immersive, interactive, and physical computing applications (See also: SEP-DEIA)\na. Accessible to people with mobility impairments\nb. Accessible to people with vision and/or hearing impairments\n2. Ethics/privacy in graphics applications. (See also: SEP-Privacy, SEP-Professional-Ethics, and\nSEP-Security)\na. Acquisition of private data (room scans, body proportions, active cameras, etc.)\nb. Can’t look away from immersive applications easily\nc. Danger to self/surroundings while immersed\nd. Ethical pitfalls of facial recognition\ne. Misleading visualizations\ni. Due to incorrect data because of exaggeration, hole filling, smoothing, data cleanup, etc.\nii. Even correct data can mislead (e.g., aliasing can cause back moving or stopped fan\nblades)\nf. Privacy regarding health and other personal information\ng. Bias in image processing\ni. Deep fakes\nii. Applications that misidentify people based on skin color or hairstyle\n3. Intellectual Property law as it relates to computer graphics and interactive techniques (See also:\nSEP-IP)\na. images used to train generative AI\nb. images produced by generative AI\n4. Current and past contributors to the field (See also: SEP-DEIA)",
    "Illustrative Learning Outcomes": {
      "KA Core": "165\n1. Discuss the security issues inherent in location tags.\n2. Describe the ethical pitfalls of facial recognition. Can facial recognition be used ethically? If so,\nhow?\n3. Discuss the copyright issues of using watermarked images to train a neural network.\nProfessional Dispositions\n● Self-directed: Graphics hardware and software evolves rapidly. Students need to understand the\nimportance of being a life-long learner.\n● Collaborative: Graphics developers typically work in diverse teams composed of people with\ndisparate subject matter expertise. Students should understand the value of being a good team\nmember, and their teamwork skills should be cultivated and evaluated with constructive feedback.\n● Effective communicator: Communication is critical. Students’ technical communication—verbal,\nwritten, and in code—should be practiced and evaluated.\n● Creative: Creative problem-solving lies at the core of computer graphics.\nMathematics Requirements\nRequired:\n1. Coordinate geometry\n2. Trigonometry\n3. MSF-Linear*\na. Points (coordinate systems & homogeneous coordinates), vectors, and matrices\nb. Vector operations: addition, scaling, dot and cross products\nc. Matrix operations: addition, multiplication, determinants\nd. Affine transformations\n4. MSF-Calculus*\na. Continuity\n*Note, if students enroll in a graphics class without linear algebra or calculus, graphics faculty can teach\nwhat is needed. To wit, many graphics textbooks cover the requisite mathematics in the appendix.\nDesirable:\n1. MSF-Linear\na. Eigenvectors and Eigen decomposition\nb. Gaussian elimination and lower upper factorization\nc. Singular value decomposition\n2. MSF-Calculus\na. Quaternions\nb. Differentiation\nc. Vector calculus\nd. Tensors\ne. Differential geometry\n3. MSF-Probability\n166\n4. MSF-Statistics\n5. MSF-Discrete\na. Numerical methods for simulation\nNecessary and Desirable Data Structures:\n1. Data Structures necessary for this knowledge area (See also: AL-Foundational, SDF-Algorithms,\nSDF-Data-Structures)\na. Directed Acyclic Graphs\nb. Tuples (points / vectors / matrices of fixed dimension)\nc. Dense 1D, 2D, 3D arrays.\n2. Data Structures desirable for this knowledge area (See also: AL-Foundational, SDF-Algorithms,\nSDF-Data-Structures, SDF-Practices)\na. Array Structures and Structure of Arrays\nb. Trees (e.g., K-trees, quadtrees, Huffman Trees)\nCourse Packaging Suggestions\nInteractive Computer Graphics to include the following:\n● GIT-Rendering (20 hours)\n● GIT-Modeling (6 hours)\n● GIT-Interaction (4 hours)\n● SEP-Professional-Ethics, SEP-DEIA (3 hours)\nPrerequisites:\n● AL-Foundational\n● AL-Strategies\n● SDF-Algorithms\n● SDF-Data-Structures\n● SDF-Practices\n● MSF-Linear as a prerequisite or cover relevant topics in class\nCourse objectives: Students should understand and be able to create basic computer graphics using\nan API. They should know how to position and orient models, the camera, and distant and local lights.\nNote: depending on the instructor, this course can be customized to include topics from another\ngraphics knowledge unit, for example a two-week unit on image processing or advanced rendering.\nMedia Computation to include the following:\n● GIT-Fundamentals (4 hours)\n● GIT-Rendering (6 hours)\n● GIT-Interaction (3 hours)\n● SDF-Fundamentals (10 hours)\n● AL-Foundational (7 hours)\n● HCI-User (5 hours)\n● GIT-SEP (4 hours)\nCourse objectives: In this introductory programming class, students should be able to explain,\nevaluate, and apply algorithms and arrays that use and produce digital media.\n167\nUser-Centered Development to include the following:\n● GIT-Fundamentals (4 hours)\n● GIT-Rendering (6 hours)\n● GIT-Interaction (3 hours)\n● HCI-User (8 hours)\n● HCI-Accessibility (3 hours)\n● HCI-SEP (4 hours)\n● SE-Construction (4 hours)\n● SPD-Web, SPD-Game, SPD-Mobile (8 hours)\nStudents should be able to develop applications that are usable and useful for people.\nGraphical user interface (GUI) designs will be implemented and analyzed using rapid\nprototyping.\nTangible Computing to include the following:\n● GIT-Physical (14 hours)\n● GIT-Interaction (4 hours)\n● SPD-Embedded (10 hours)\n● HCI-User (3 hours)\n● HCI-Design (3 hours)\n● SEP-Privacy and SEP-DEIA (3 hours)\nPrerequisites:\n● AL-Foundational\nCourse objectives: Students should be able to use human-centered design to build circuits and\nprogram a networked microcontroller. Additionally, they will learn to work with real time sensors and\nunderstand polarity, Ohm’s law, and how to work with electronics safely.\nImage Processing to include the following:\n● GIT-Image (20 hours)\n● GIT-Interaction (4 hours)\n● SEP-Privacy, SEP-DEIA and SEP-IP (3 hours)\nPrerequisites:\n● AL-Foundational\n● AL-Strategies\n● SDF-Algorithms\n● SDF-Data-Structures\n● SDF-Practices\nCourse objectives: Students should understand and be able to appropriately acquire, process,\ndisplay, and save digital images.\nData Visualization to include the following:\n● GIT-Visualization (20 hours)\n● GIT-Interaction (4 hours)\n● GIT-Fundamentals (4 hours)\n168\n● HCI-User (3 hours)\n● HCI-Design (3 hours)\n● SEP-Privacy, SEP-DEIA, and SEP-Professional-Ethics (3 hours)\nPrerequisites:\n● AL-Foundational\n● AL-Strategies\n● SDF-Algorithms\n● SDF-Data-Structures\n● SDF-Practices\n● MSF-Probability\n● MSF-Statistics\nCourse objectives: Students should understand how to select a dataset; ensure the data are accurate\nand appropriate; design, develop and test a usable visualization program that depicts the data; and be\nable to read and evaluate existing visualizations.\nSimulation to include the following:\n● GIT-Simulation (10 hours)\n● GIT-Rendering (15 hours)\n● GIT-Shading: (6 hours)\n● SEP-Professional-Ethics (3 hours)\nPrerequisites:\n● AL-Foundational\n● AL-Strategies\n● SDF-Algorithms\n● SDF-Data-Structures\n● SDF-Practices\n● MSF-Linear as a prerequisite or cover relevant topics in class\n● MSF-Probability\nCourse objectives: Students should understand and be able to create directable simulations, both of\nphysical and non-physical systems.\nIntroduction to AR and VR to include the following:\n● GIT-Immersive (15 hours)\n● GIT-Fundamentals (4 hours)\n● GIT-Interactive (8 hours)\n● SEP-Privacy, SEP-DEIA, and SEP-Professional-Ethics (3 hours)\nCourse objectives: Students should understand and be able to develop VR and AR applications.\nComputer Animation to include the following:\n● GIT-Animation (30 hours)\n● SEP-Privacy, SEP-DEIA, and SEP-Professional-Ethics (3 hours)\nPrerequisites:\n● Interactive Computer Graphics course\n169\nCourse objectives: Students should understand and be able to create short animations employing the\nprinciples of animation.\nLighting and Shading to include the following:\n● GIT-Shading (12 hours)\n● GIT-Modeling (6 hours)\n● GIT-Interaction (4 hours)\n● SEP-IP, SEP-DEIA, and SEP-Professional-Ethics (3 hours)\nPrerequisites:\n● Interactive Computer Graphics course\nCourse objectives: Students should be able to create realistic and non-photorealistic lighting and\nunderstand the underlying theory of shading and lighting.\nCommittee\nChair: Susan Reiser, University of North Carolina Asheville, Asheville, NC, USA\nMembers:\n● Erik Brunvand, University of Utah, Salt Lake City, UT, USA\n● Kel Elkins, NASA/GSFC Scientific Visualization Studio, Greenbelt, MD, USA\n● Jeff Lait, SideFX, Toronto, Canada\n● Amruth Kumar, Ramapo College, Mahwah, NJ, USA\n● Paul Mihail, Valdosta State University, Valdosta, GA, USA\n● Tabitha Peck, Davidson College, Davidson, NC, USA\n● Ken Schmidt, NOAA NCEI, Asheville, NC, USA\n● Dave Shreiner, UnityTechnologies & Sonoma State University, San Francisco, CA, USA\nContributors:\n● Ginger Alford, Southern Methodist University, University Park, TX, USA\n● Christopher Andrews, Middlebury College, Middlebury, VT, USA\n● A. J. Christensen, NASA/GSFC Scientific Visualization Studio – SSAI, Champaign, IL, USA\n● Roger Eastman, University of Maryland, College Park, MD, USA\n● Ted Kim, Yale University, New Haven, CT, USA\n● Barbara Mones, University of Washington, Seattle, WA, USA\n● Greg Shirah, NASA/GSFC Scientific Visualization Studio, Greenbelt, MD, USA\n● Beatriz Sousa Santos, University of Aveiro, Portugal\n● Anthony Steed, University College, London, UK\n170\nReferences\n1. Jon Quast, Clay Bruning, and Sanmeet Deo. \"Markets: This Opportunity for Investors Is Bigger\nThan Movies and Music Combined.\" https://www.nasdaq.com/articles/this-opportunity-for-investors-\nis-bigger-than-movies-and-music-combined-2021-10-03. Accessed March 2024.\n171\n172\nHuman-Computer Interaction (HCI)\nPreamble\nComputational systems not only enable users to solve problems, but also foster social connectedness\nand support a broad variety of human endeavors. Thus, these systems should work well with their\nusers and solve problems in ways that respect individual dignity, social justice, and human values and\ncreativity. Human-computer interaction (HCI) addresses those issues from an interdisciplinary\nperspective that includes computer science, psychology, business strategy, and design principles.\nEach user is different and, from the perspective of HCI, the design of every system that interacts with\npeople should anticipate and respect that diversity. This includes not only accessibility, but also cultural\nand societal norms, neural diversity, modality, and the responses the system elicits in its users. An\neffective computational system should evoke trust while it treats its users fairly, respects their privacy,\nprovides security, and abides by ethical principles.\nThese goals require design-centric engineering that begins with intention and with the understanding\nthat design is an iterative process, one that requires repeated evaluation of its usability and its impact\non its users. Moreover, technology evokes user responses, not only by its output, but also by the\nmodalities with which it senses and communicates. This knowledge area heightens the awareness of\nthese issues and should influence every computer scientist.\nChanges since CS2013\nDriven by this broadened perspective, the HCI knowledge area has revised the CS2013 document in\nseveral ways:\n● Knowledge units have been renamed and reformulated to reflect current practice and to anticipate\nfuture technological development.\n● There is increased emphasis on the nature of diversity and the centrality of design focused on the\nuser.\n● Modality (e.g., text, speech) is still emphasized given its key role throughout HCI, but with a\nreduced emphasis on specific modalities in favor of a more timely and empathetic approach.\n● The curriculum reflects the importance of understanding and evaluating the impacts and\nimplications of a computational system on its users, including issues in ethics, fairness, trust, and\nexplainability.\n● Given its extensive interconnections with other knowledge areas, we believe HCI is itself a cross-\ncutting knowledge area with connections to Artificial Intelligence, Graphics and Interactive\nTechniques, Software Development Fundamentals, Software Engineering, and Society, Ethics, and\nthe Profession.\n173\nCore Hours\nKnowledge Unit CS Core KA Core\nUnderstanding the User 2 5\nAccountability and Responsibility in Design 2 2\nAccessibility and Inclusive Design 2 2\nEvaluating the Design 1 2\nSystem Design 1 5\nSociety, Ethics, and the Profession Included in SEP hours\nTotal Hours 8 16\nKnowledge Units"
    }
  },
  {
    "title": "HCI-User: Understanding the User: Individual goals and interactions with others",
    "CS Core": "1. User-centered design and evaluation methods. (See also: SEP-Context, SEP-Ethical-Analysis,\nSEP-Professional-Ethics)\na. “You are not the users”\nb. User needs-finding\nc. Formative studies\nd. Interviews\ne. Surveys\nf. Usability tests",
    "KA Core": "2. User-centered design methodology. (See also: SE-Tools)\na. Personas/persona spectrum\nb. User stories/storytelling and techniques for gathering stories\nc. Empathy maps\nd. Needs assessment (techniques for uncovering needs and gathering requirements - e.g.,\ninterviews, surveys, ethnographic and contextual enquiry) (See also: SE-Requirements)\ne. Journey maps\nf. Evaluating the design (See also: HCI-Evaluation)\ng. Interfacing with stakeholders, as a team\nh. Risks associated with physical, distributed, hybrid and virtual teams\n3. Physical and cognitive characteristics of the user\na. Physical capabilities that inform interaction design (e.g., color perception, ergonomics)\n174\nb. Cognitive models that inform interaction design (e.g., attention, perception and recognition,\nmovement, memory)\nc. Topics in social/behavioral psychology (e.g., cognitive biases, change blindness)\n4. Designing for diverse user populations. (See also: SEP-DEIA, HCI-Accessibility)\na. How differences (e.g., in race, ability, age, gender, culture, experience, and education)\nimpact user experiences and needs\nb. Internationalization\nc. Designing for users from other cultures\nd. Cross-cultural design\ne. Challenges to effective design evaluation. (e.g., sampling, generalization; disability and\ndisabled experiences)\nf. Universal design\n5. Collaboration and communication (See also: AI-SEP, SE-Teamwork, SEP-Communication, SPD-\nGame)\na. Understanding the user in a multi-user context\nb. Synchronous group communication (e.g., chat rooms, conferencing, online games)\nc. Asynchronous group communication (e.g., email, forums, social networks)\nd. Social media, social computing, and social network analysis\ne. Online collaboration\nf. Social coordination and online communities\ng. Avatars, characters, and virtual worlds",
    "Non-core": "6. Multi-user systems",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Conduct a user-centered design process that is integrated into a project.",
      "KA Core": "2. Compare and contrast the needs of users with those of designers.\n3. Identify the representative users of a design and discuss who else could be impacted by it.\n4. Describe empathy and evaluation as elements of the design process.\n5. Carry out and document an analysis of users and their needs.\n6. Construct a user story from a needs assessment.\n7. Redesign an existing solution to a population whose needs differ from those of the initial target\npopulation.\n8. Contrast the different needs-finding methods for a given design problem.\n9. Reflect on whether your design would benefit from low-tech or no-tech components.",
      "Non-core": "10. Recognize the implications of designing for a multi-user system/context.\n175"
    }
  },
  {
    "title": "HCI-Accountability: Accountability and Responsibility in Design",
    "CS Core: (See also: SEP-Context)": "1. Design impact\na. Sustainability (See also: SEP-Sustainability)\nb. Inclusivity (See also: SEP-DEIA)\nc. Safety, security and privacy (See also: SEP-Security, SEC-Foundations)\nd. Harm and disparate impact (See also: SEP-DEIA)\n2. Ethics in design methods and solutions (See also: SEP-Ethical-Analysis, SEP-Context, SEP-\nIntellectual Property)\na. The role of artificial intelligence (See also: AI-SEP)\nb. Responsibilities for considering stakeholder impact and human factors (See also: SEP-\nProfessional-Ethics)\nc. Role of design to meet user needs\n3. Requirements in design (See also: SEP-Professional-Ethics)\na. Ownership responsibility\nb. Legal frameworks, compliance requirements\nc. Consideration beyond immediate user needs, including via iterative reconstruction of\nproblem analysis and “digital well-being” features",
    "KA Core": "4. Value-sensitive design (See also: SEP-Ethical-Analysis, SEP-Context, SEP-Communication)\na. Identify direct and indirect stakeholders\nb. Determine and include diverse stakeholder values and value systems.\n5. Persuasion through design (See also: SEP-Communication)\na. Assess the persuasive content of a design\nb. Employ persuasion as a design goal\nc. Distinguish persuasive interfaces from manipulative interfaces",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Identify and critique the potential impacts of a design on society and relevant communities to\naddress such concerns as sustainability, inclusivity, safety, security, privacy, harm, and disparate\nimpact.",
      "KA Core": "2. Identify the potential human factor elements in a design.\n3. Identify and understand direct and indirect stakeholders.\n4. Develop scenarios that consider the entire lifespan of a design, beyond the immediately planned\nuses that anticipate direct and indirect stakeholders.\n5. Identify and critique the potential factors in a design that impact direct and indirect stakeholders and\nbroader society (e.g., transparency, sustainability of the system, trust, artificial intelligence).\n6. Assess the persuasive content of a design and its intent relative to user interests.\n7. Critique the outcomes of a design given its intent.\n8. Understand the impact of design decisions.\n176"
    }
  },
  {
    "title": "HCI-Accessibility: Accessibility and Inclusive Design",
    "CS Core": "1. Background (See also: SEP-DEIA, SEP-Security)\na. Societal and legal support for and obligations to people with disabilities\nb. Accessible design benefits everyone\n2. Techniques\na. Accessibility standards (e.g., Web Content Accessibility Guidelines) (See also: SPD-Web)\n3. Technologies (See also: SE-Tools)\na. Features and products that enable accessibility and support inclusive development by\ndesigners and engineers\n4. IDFs (Inclusive Design Frameworks) (See also: SEP-DEIA)\na. Recognizing differences\n5. Universal design",
    "KA Core": "6. Background\na. Demographics and populations (permanent, temporary, and situational disability)\nb. International perspectives on disability (See also: SEP-DEIA)\nc. Attitudes towards people with disabilities (See also: SEP-DEIA)\n7. Techniques\na. UX (user experience) design and research\nb. Software engineering practices that enable inclusion and accessibility. (See also: SEP-DEIA)\n8. Technologies\na. Examples of accessibility-enabling features, such as conformance to screen readers\n9. Inclusive Design Frameworks\na. Creating inclusive processes such as participatory design\nb. Designing for larger impact",
    "Non-core": "10. Background (See also: SEP-DEIA)\na. Unlearning and questioning\nb. Disability studies\n11. Technologies: the Return On Investment (ROI) of inclusion\n12. Inclusive Design Frameworks: user-sensitive inclusive design (See also: SEP-DEIA)\n13. Critical approaches to HCI (e.g., inclusivity) (See also: SEP-DEIA)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Identify accessibility challenges faced by people with different disabilities and specify the associated\naccessible and assistive technologies that address them. (See also: AI-Agents, AI-Robotics)\n2. Identify appropriate inclusive design approaches, such as universal design and ability-based\ndesign.\n3. Identify and demonstrate understanding of software accessibility guidelines.\n4. Demonstrate recognition of laws and regulations applicable to accessible design.\n177",
      "KA Core": "5. Apply inclusive frameworks to design, such as universal design and usability and ability-based\ndesign, and demonstrate accessible design of visual, voice-based, and touch-based UIs.\n6. Demonstrate understanding of laws and regulations applicable to accessible design.\n7. Demonstrate understanding of what is appropriate and inappropriate high level of skill during\ninteraction with individuals from diverse populations.\n8. Analyze web pages and mobile apps for current standards of accessibility.",
      "Non-core": "9. Biases towards disability, race, and gender have historically, either intentionally or unintentionally,\ninformed technology design.\na. Find examples.\nb. Consider how those experiences (learnings?) might inform design.\n10. Conceptualize user experience research to identify user needs and generate design insights."
    }
  },
  {
    "title": "HCI-Evaluation: Evaluating the Design",
    "CS Core": "1. Methods for evaluation with users\na. Formative (e.g., needs-finding, exploratory analysis) and summative assessment (e.g.,\nfunctionality and usability testing)\nb. Elements to evaluate (e.g., utility, efficiency, learnability, user satisfaction, affective elements\nsuch as pleasure and engagement)\nc. Understanding ethical approval requirements before engaging in user research (See also: SE-\nTools, SEP-Ethical-Analysis, SEP-Security, SEP-Privacy, SEP-Professional-Ethics)",
    "KA Core": "2. Methods for evaluation with users (See also: SE-Validation)\na. Qualitative methods (qualitative coding and thematic analysis)\nb. Quantitative methods (statistical tests)\nc. Mixed methods (e.g., observation, think-aloud, interview, survey, experiment)\nd. Presentation requirements (e.g., reports, personas)\ne. User-centered testing\nf. Heuristic evaluation\ng. Challenges and shortcomings to effective evaluation (e.g., sampling, generalization)\n3. Study planning\na. How to set study goals\nb. Hypothesis design\nc. Approvals from Institutional Research Boards and ethics committees (See also: SEP-Ethical-\nAnalysis, SEP-Security, SEP-Privacy)\nd. How to pre-register a study\ne. Within-subjects vs between-subjects design\n4. Implications and impacts of design with respect to the environment, material, society, security,\nprivacy, ethics, and broader impacts. (See also: SEC-Foundations)\n178\na. The environment\nb. Material\nc. Society\nd. Security\ne. Privacy\nf. Ethics\ng. Broader impacts",
    "Non-core": "5. Techniques and tools for quantitative analysis\na. Statistical packages\nb. Visualization tools\nc. Statistical tests (e.g., ANOVA, t-tests, post-hoc analysis, parametric vs non-parametric tests)\nd. Data exploration and visual analytics; how to calculate effect size.\n6. Data management\na. Data storage and data sharing (open science)\nb. Sensitivity and identifiability.",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Discuss the differences between formative and summative assessment and their role in evaluating\ndesign",
      "KA Core": "2. Select appropriate formative or summative evaluation methods at different points throughout the\ndevelopment of a design.\n3. Discuss the benefits of using both qualitative and quantitative methods for evaluation.\n4. Evaluate the implications and broader impacts of a given design.\n5. Plan a usability evaluation for a given user interface, and justify its study goals, hypothesis design,\nand study design.\n6. Conduct a usability evaluation of a given user interface and draw defensible conclusions given the\nstudy design.",
      "Non-core": "7. Select and run appropriate statistical tests on provided study data to test for significance in the\nresults.\n8. Pre-register a study design, with planned statistical tests."
    }
  },
  {
    "title": "HCI-Design: System Design",
    "CS Core": "1. Prototyping techniques and tools\na. Low-fidelity prototyping\nb. Rapid prototyping\nc. Throw-away prototyping\n179\nd. Granularity of prototyping\n2. Design patterns\na. Iterative design\nb. Universal design (See also: SEP-DEIA)\nc. Interaction design (e.g., data-driven design, event-driven design)\n3. Design constraints\na. Platforms (See also: SPD-Game)\nb. Devices\nc. Resources\nd. Balance among usability, security and privacy (See also: SEC-Foundations)",
    "KA Core": "4. Design patterns and guidelines\na. Software architecture patterns\nb. Cross-platform design\nc. Synchronization considerations\n5. Design processes (See also: SEP-Communication)\na. Participatory design\nb. Co-design\nc. Double-diamond\nd. Convergence and divergence\n6. Interaction techniques (See also: GIT-Interaction)\na. Input and output vectors (e.g., gesture, pose, touch, voice, force)\nb. Graphical user interfaces\nc. Controllers\nd. Haptics\ne. Hardware design\nf. Error handling\n7. Visual UI design (See also: GIT-Visualization)\na. Color\nb. Layout\nc. Gestalt principles",
    "Non-core": "8. Immersive environments (See also: GIT-Immersion)\na. XR (encompasses virtual reality, augmented reality, and mixed reality)\nb. Spatial audio\n9. 3D printing and fabrication\n10. Asynchronous interaction models\n11. Creativity support tools\n12. Voice UI designs",
    "Illustrative Learning Outcomes": {
      "CS Core": "180\n1. Propose system designs tailored to a specified appropriate mode of interaction.\n2. Follow an iterative design and development process that incorporates the following:\na. Understanding the user\nb. Developing an increment\nc. Evaluating the increment\nd. Feeding those results into a subsequent iteration\n3. Explain the impact of changing constraints and design tradeoffs (e.g., hardware, user, security.) on\nsystem design.",
      "KA Core": "4. Evaluate architectural design approaches in the context of project goals.\n5. Identify synchronization challenges as part of the user experience in distributed environments.\n6. Evaluate and compare the privacy implications behind different input techniques for a given\nscenario.\n7. Explain the rationale behind a UI design based on visual design principles.",
      "Non-core": "8. Evaluate the privacy implications within a VR/AR/MR scenario"
    }
  },
  {
    "title": "HCI-SEP: Society, Ethics, and the Profession",
    "CS Core": "1. Universal and user-centered design (See also: HCI-User, SEP-DEIA)\n2. Accountability (See also: HCI-Accountability)\n3. Accessibility and inclusive design (See also: SEP-DEIA, SEP-Security)\n4. Evaluating the design (See also: HCI-Evaluation)\n5. System design (See also: HCI-Design)",
    "KA Core": "6. Participatory and inclusive design processes\n7. Evaluating the design: Implications and impacts of design: with respect to the environment,\nmaterial, society, security, privacy, ethics, and broader impacts (See also: SEC-Foundations, SEP-\nPrivacy)",
    "Non-core": "8. VR/AR/MR scenarios",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Conduct a user-centered design process that is integrated into a project.\n2. Identify and critique the potential impacts of a design on society and relevant communities to\naddress such concerns as sustainability, inclusivity, safety, security, privacy, harm, and disparate\nimpact.",
      "KA Core": "181\n2. Critique a recent example of a non-inclusive design choice, its societal implications, and propose\npotential design improvements.\n3. Evaluating the design: Identify the implications and broader impacts of a given design.",
      "Non-core": "4. Evaluate the privacy implications within a VR/AR/MR scenario.\nProfessional Dispositions\n● Adaptable: An HCI practitioner should be adaptable to address dynamic changes in technology,\nuser needs, and design challenges.\n● Meticulous: An HCI practitioner should be meticulous in ensuring that their products are both user-\nfriendly and meet the objectives of the project.\n● Empathetic: An HCI practitioner must demonstrate understanding of the user’s needs.\n● Team-oriented: The successful HCI practitioner should focus on the success of the team.\n● Inventive: An HCI practitioner should design solutions that are informed by past practice, the needs\nof the audience, and HCI fundamentals. Creativity is required to blend these into something that\nsolves the problem appropriately and elegantly.\nMathematics Requirements\nRequired:\n● Basic statistics (MSF-Statistics) to support the evaluation and interpretation of results, including\ncentral tendency, variability, frequency distribution.\nCourse Packaging Suggestions\nIntroduction to HCI for CS majors and minors, to include the following:\n● HCI-User: Understanding the User (7 hours)\n● HCI-Accountability: Accountability and Responsibility in Design: (2 hours)\n● HCI-Accessibility: Accessibility and Inclusive Design: (4 hours)\n● HCI-Evaluation: Evaluating the Design: (3 hours)\n● HCI-Design: System Design: (10 hours)\n● HCI-SEP: Society, Ethics, and the Profession: (2 hours)\nPrerequisites:\n● CS2\nCourse objectives: A student who completes this course should be able to describe user-centered\ndesign principles and apply them in the context of a small project.\nIntroduction to Data Visualization to include the following:\n● GIT-Visualization (30 hours)\n● GIT-Rendering (10 hours)\n● HCI-User: Understanding the User (3 hours)\n182\n● SEP-Privacy, SEP-Ethical-Analysis (4 hours)\nPrerequisites:\n● CS2\n● MSF-Linear\nCourse objectives: Students should understand how to select a dataset; ensure the data are accurate\nand appropriate; and design, develop and test a visualization program that depicts the data and is\nusable.\nAdvanced Course: Usability Testing\n● HCI-User (5 hours)\n● HCI-Accountability (3 hours)\n● HCI-Accessibility (4 hours)\n● HCI-Evaluation (20 hours)\n● HCI-Design (3 hours)\n● HCI-SEP (5 hours)\nPrerequisites:\n● Introductory/Foundation courses in HCI\n● Research methods, MSF-Statistics\nCourse objectives: Students should be able to formally evaluate products including the design and\nexecution of usability test tasks, recruitment of appropriate users, design of test tasks, design of the test\nenvironment, test plan development and implementation, analysis and interpretation of the results, and\ndocumentation and presentation of results and recommendations. Students should be able to select\nappropriate techniques, procedures, and protocols to apply in various situations for usability testing with\nusers. Students should also be able to design an appropriate evaluation plan, effectively conduct the\nusability test, collect data, and analyze results so that they can suggest improvements.\nCommittee\nChair: Susan L. Epstein, Hunter College and The Graduate Center of The City University of New York,\nNY, USA\nMembers:\n● Sherif Aly, The American University of Cairo, Cairo, Egypt\n● Jeremiah Blanchard, University of Florida, Gainesville, FL, USA\n● Zoya Bylinskii, Adobe Research, Cambridge, MA, USA\n● Paul Gestwicki, Ball State University, Muncie, IN, USA\n● Susan Reiser, University of North Carolina at Asheville, Asheville, NC, USA\n● Amanda M. Holland-Minkley, Washington and Jefferson College, Washington, PA, USA\n● Ajit Narayanan, Google, Chennai, India\n● Nathalie Riche, Microsoft, Redmond, WA, USA\n● Kristen Shinohara, Rochester Institute of Technology, Rochester, NY, USA\n● Olivier St-Cyr, University of Toronto, Toronto, Canada\n183\n184\nMathematical and Statistical Foundations (MSF)\nPreamble\nA strong mathematical foundation remains a bedrock of computer science education and infuses the\npractice of computing whether in developing algorithms, designing systems, modeling real-world\nphenomena, or computing with data. This Mathematical and Statistical Foundations (MSF) knowledge\narea – the successor to the ACM CS2013 [1] curriculum's \"Discrete Structures\" area – seeks to identify\nthe mathematical and statistical material that undergirds modern computer science. The change of\nname corresponds to a realization both that the broader name better describes the combination of\ntopics from the 2013 report and from those required for the recently growing areas of computer science,\nsuch as artificial intelligence, machine learning, data science, and quantum computing, many of which\nhave continuous mathematics as their foundations.\nThe committee sought the following inputs to prepare their recommendations:\n● A survey about mathematical preparation distributed to computer science faculty (nearly 600\nrespondents) across a variety of institutional types and in various countries;\n● Math-related curricular views amongst data collected from ACM’s survey of industry\nprofessionals (865 respondents);\n● Mathematics requirements stated by all the knowledge areas in the report;\n● Direct input from the computer science theory community; and\n● Review of past curricular reports including recent ones on data science (e.g., Park City report\n[2]) and quantum computing education.\nChanges since CS2013\nThe breadth of mathematics needed to address the mathematical needs of rapidly growing areas such\nas artificial intelligence, machine learning, robotics, data science, and quantum computing has grown\nbeyond discrete structures. These areas call for a renewed focus on probability, statistics, and linear\nalgebra, as supported by the faculty survey that asked respondents to rate various mathematical areas\nin their importance for both an industry career as well as for graduate school: the combined such\nratings for probability, statistics, and linear algebra, for example, were 98%, 98% and 89% respectively,\nreflecting a strong consensus in the computer science academic community.\nCore Hours\nAcknowledging some tensions\nSeveral challenges face computer science (CS) programs when weighing mathematics requirements:\n(1) many CS majors, perhaps aiming for a software career, are unenthusiastic about investing in\nmathematics; (2) institutions such as liberal-arts colleges often limit how many courses a major may\nrequire, while others may require common engineering courses that fill up the schedule; and (3) some\nprograms adopt a more pre-professional curricular outlook while others emphasize a more foundational\none. Thus, we are hesitant to recommend an all-encompassing set of mathematical topics that “every\n185\nCS degree must require.” Instead, we outline two sets of core requirements, a CS Core set suited to\nhours-limited majors and a more expansive set of CS Core plus KA Core to align with technically\nfocused programs. The principle here is that considering the additional foundational mathematics\nneeded for AI, data science, and quantum computing, programs ought to consider as much as possible\nfrom the more expansive CS+KA version unless there are sound institutional reasons for alternative\nrequirements.\nNote: the hours in a row (example: linear algebra) add up to 40 (= 5 + 35), reflecting a standard course;\nshorter combined courses may be created, for example, by including probability in discrete\nmathematics (29 hours of discrete mathematics, 11 hours of probability).\nKnowledge Unit CS Core KA Core\nDiscrete Mathematics 29 11\nProbability 11 29\nStatistics 10 30\nLinear Algebra 5 35\nCalculus 0 40\nTotal 55 145\nRationale for recommended hours",
      "CS Core: While some discrete mathematics courses include probability, we highlight its importance": "with a minimum number of hours (11) to reflect the strong consensus in the academic community\nbased on the survey. Taken together, the total CS Core across discrete mathematics and probability\n(40 hours) is typical of a one-term course. Fifteen hours are allotted to statistics and linear algebra for\nbasic definitions so that, for example, students should at least be familiar with terms like mean,\nstandard deviation, and vector. These could be covered in regular computer science courses. Many\nprograms typically include a broader statistics requirement.",
      "KA Core: The KA Core hours can be read as the remaining hours available to flesh out each topic into": "a standard 40-hour course. Note that the calculus hours roughly correspond to the typical Calculus-I\ncourse now standard across the world. Based on our survey, most programs already require Calculus-I.\nHowever, we have left out Calculus-II (an additional 40 hours) and left it to programs to decide whether\nCalculus-II should be added to program requirements. Programs could choose to require a more\nrigorous calculus-based probability or statistics sequence, or non-calculus-based versions. Similarly,\nlinear algebra can be taught as an applied course without a calculus prerequisite or as a more\nadvanced course.\n186\nKnowledge Units"
    }
  },
  {
    "title": "MSF-Discrete: Discrete Mathematics",
    "CS Core": "1. Sets, relations, functions, cardinality\n2. Recursive mathematical definitions\n3. Proof techniques (induction, proof by contradiction)\n4. Permutations, combinations, counting, pigeonhole principle\n5. Modular arithmetic\n6. Logic: truth tables, connectives (operators), inference rules, formulas, normal forms, simple\npredicate logic\n7. Graphs: basic definitions\n8. Order notation",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Sets, Relations, and Functions, Cardinality\na. Explain with examples the basic terminology of functions, relations, and sets.\nb. Perform the operations associated with sets, functions, and relations.\nc. Relate practical examples to the appropriate set, function, or relation model, and interpret the\nassociated operations and terminology in context.\nd. Calculate the size of a finite set, including making use of the sum and product rules and\ninclusion-exclusion principle.\ne. Explain the difference between finite, countable, and uncountable sets.\n2. Recursive mathematical definitions\na. Apply recursive definitions of sequences or structures (e.g., Fibonacci numbers, linked lists,\nparse trees, fractals).\nb. Formulate inductive proofs of statements about recursive definitions.\nc. Solve a variety of basic recurrence relations.\nd. Analyze a problem to determine underlying recurrence relations.\ne. Given a recursive/iterative code snippet, describe its underlying recurrence relation, hypothesize\na closed form for the recurrence relation, and prove the hypothesis correct (usually, using\ninduction).\n3. Proof Techniques\na. Identify the proof technique used in a given proof.\nb. Outline the basic structure of each proof technique (direct proof, proof by contradiction, and\ninduction) described in this unit.\nc. Apply each of the proof techniques (direct proof, proof by contradiction, and induction) correctly\nin the construction of a sound argument.\nd. Determine which type of proof is best for a given problem.\ne. Explain the parallels between ideas of mathematical and/or structural induction to recursion and\nrecursively defined structures.\n187\nf. Explain the relationship between weak and strong induction and give examples of the\nappropriate use of each.\n4. Permutations, combinations, and counting\na. Apply counting arguments, including sum and product rules, inclusion-exclusion principle, and\narithmetic/geometric progressions.\nb. Apply the pigeonhole principle in the context of a formal proof.\nc. Compute permutations and combinations of a set, and interpret the meaning in the context of\nthe specific application.\nd. Map real-world applications to appropriate counting formalisms, such as determining the\nnumber of ways to arrange people around a table, subject to constraints on the seating\narrangement, or the number of ways to determine certain hands in cards (e.g., a full house).\n5. Modular arithmetic\na. Perform computations involving modular arithmetic.\nb. Explain the notion of the greatest common divisor and apply Euclid's algorithm to compute it.\n6. Logic\na. Convert logical statements from informal language to propositional and predicate logic\nexpressions.\nb. Apply formal methods of symbolic propositional and predicate logic, such as calculating validity\nof formulae, computing normal forms, or negating a logical statement.\nc. Use the rules of inference to construct proofs in propositional and predicate logic.\nd. Describe how symbolic logic can be used to model real-life situations or applications, including\nthose arising in computing contexts such as software analysis (e.g., program correctness),\ndatabase queries, and algorithms.\ne. Apply formal logic proofs and/or informal, but rigorous, logical reasoning to real problems, such\nas predicting the behavior of software or solving problems such as puzzles.\nf. Describe the strengths and limitations of propositional and predicate logic.\ng. Explain what it means for a proof in propositional (or predicate) logic to be valid.\n7. Graphs\na. Illustrate by example the basic terminology of graph theory, and some of the properties and\nspecial cases of types of graphs, including trees.\nb. Demonstrate different traversal methods for trees and graphs, including pre-, post-, and in-order\ntraversal of trees, along with breadth-first and depth-first search for graphs.\nc. Model a variety of real-world problems in computer science using appropriate forms of graphs\nand trees, such as representing a network topology, the organization of a hierarchical file\nsystem, or a social network.\nd. Show how concepts from graphs and trees appear in data structures, algorithms, proof\ntechniques (structural induction), and counting.",
      "KA Core": "The recommended topics are the same between CS core and KA-core, but with far more hours, the\nKA-core can cover these topics in depth and might include more computing-related applications."
    }
  },
  {
    "title": "MSF-Probability: Probability",
    "CS Core": "188\n1. Basic notions: sample spaces, events, probability, conditional probability, Bayes’ rule\n2. Discrete random variables and distributions\n3. Continuous random variables and distributions\n4. Expectation, variance, law of large numbers, central limit theorem\n5. Conditional distributions and expectation\n6. Applications to computing, the difference between probability and statistics (as subjects)",
    "KA Core": "The recommended topics are the same between CS core and KA-core, but with far more hours, the\nKA-core can cover these topics in depth and might include more computing-related applications.",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Basic notions: sample spaces, events, probability, conditional probability, Bayes’ rule\na. Translate a prose description of a probabilistic process into a formal setting of sample spaces,\noutcome probabilities, and events.\nb. Calculate the probability of simple events.\nc. Determine whether two events are independent.\nd. Compute conditional probabilities, including through applying (and explaining) Bayes' Rule.\n2. Discrete random variables and distributions\na. Define the concept of a random variable and indicator random variable.\nb. Determine whether two random variables are independent.\nc. Identify common discrete distributions (e.g., uniform, Bernoulli, binomial, geometric).\n3. Continuous random variables and distributions\na. Identify common continuous distributions (e.g., uniform, normal, exponential).\nb. Calculate probabilities using cumulative density functions.\n4. Expectation, variance, law of large numbers, central limit theorem\na. Define the concept of expectation and variance of a random variable.\nb. Compute the expected value and variance of simple or common discrete/continuous random\nvariables.\nc. Explain the relevance of the law of large numbers and central limit theorem to probability\ncalculations.\n5. Conditional distributions and expectation\na. Explain the distinction between joint, marginal, and conditional distributions.\nb. Compute marginal and conditional distributions from a full distribution, for both discrete and\ncontinuous random variables.\nc. Compute conditional expectations for both discrete and continuous random variables.\n6. Applications to computing\na. Describe how probability can be used to model real-life situations or applications, such as\npredictive text, hash tables, and quantum computation.\nb. Apply probabilistic processes to solving computational problems, such as through randomized\nalgorithms or in security contexts.\n189"
    }
  },
  {
    "title": "MSF-Statistics: Statistics",
    "CS Core": "1. Basic definitions and concepts: populations, samples, measures of central tendency, variance\n2. Univariate data: point estimation, confidence intervals",
    "KA Core": "3. Multivariate data: estimation, correlation, regression\n4. Data transformation: dimension reduction, smoothing\n5. Statistical models and algorithms\n6. Hypothesis testing",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Basic definitions and concepts: populations, samples, measures of central tendency, variance\na. Create and interpret frequency tables.\nb. Display data graphically and interpret graphs (e.g., histograms).\nc. Recognize, describe, and calculate means, medians, quantiles (location of data).\nd. Recognize, describe, and calculate variances, interquartile ranges (spread of data).\n2. Univariate data: point estimation, confidence intervals\na. Formulate maximum likelihood estimation (in linear-Gaussian settings) as a least-squares\nproblem.\nb. Calculate maximum likelihood estimates.\nc. Calculate maximum a posteriori estimates and make a connection with regularized least\nsquares.\nd. Compute confidence intervals as a measure of uncertainty.",
      "KA Core": "3. Sampling, bias, adequacy of samples, Bayesian vs frequentist interpretations\n4. Multivariate data: estimation, correlation, regression\na. Formulate the multivariate maximum likelihood estimation problem as a least-squares problem.\nb. Interpret the geometric properties of maximum likelihood estimates.\nc. Derive and calculate the maximum likelihood solution for linear regression.\nd. Derive and calculate the maximum a posteriori estimates for linear regression.\ne. Implement both maximum likelihood and maximum a posteriori estimates in the context of a\npolynomial regression problem.\nf. Formulate and understand the concept of data correlation (e.g., in 2D)\n5. Data transformation: dimension reduction, smoothing\na. Formulate and derive Principal Component Analysis (PCA) as a least-squares problem.\nb. Geometrically interpret PCA (when solved as a least-squares problem).\nc. Describe when PCA works well (one can relate back to correlated data).\nd. Geometrically interpret the linear regression solution (maximum likelihood).\n6. Statistical models and algorithms\na. Apply PCA to dimensionality reduction problems.\nb. Describe the tradeoff between compression and reconstruction power.\n190\nc. Apply linear regression to curve-fitting problems.\nd. Explain the concept of overfitting.\ne. Discuss and apply cross-validation in the context of overfitting and model selection (e.g., degree\nof polynomials in a regression context)."
    }
  },
  {
    "title": "MSF-Linear: Linear Algebra",
    "CS Core": "1. Vectors: definitions, vector operations, geometric interpretation, angles: Matrices: definition, matrix\noperations, meaning of Ax=b.",
    "KA Core": "2. Matrices, matrix-vector equation, geometric interpretation, geometric transformations with matrices\n3. Solving equations, row-reduction\n4. Linear independence, span, basis\n5. Orthogonality, projection, least-squares, orthogonal bases\n6. Linear combinations of polynomials, Bezier curves\n7. Eigenvectors and eigenvalues\n8. Applications to computer science: Principal Components Analysis (PCA), Singular Value\nDecomposition (SVD), page-rank, graphics",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Vectors: definitions, vector operations, geometric interpretation, angles\na. Describe algebraic and geometric representations of vectors in Rn and their operations,\nincluding addition, scalar multiplication, and dot product.\nb. List properties of vectors in Rn.\nc. Compute angles between vectors in Rn.",
      "KA Core": "2. Matrices, matrix-vector equation, geometric interpretation, geometric transformations with matrices\na. Perform common matrix operations, such as addition, scalar multiplication, multiplication, and\ntransposition.\nb. Relate a matrix to a homogeneous system of linear equations.\nc. Recognize when two matrices can be multiplied.\nd. Relate various matrix transformations to geometric illustrations.\n3. Solving equations, row-reduction\na. Formulate, solve, apply, and interpret properties of linear systems.\nb. Perform row operations on a matrix.\nc. Relate an augmented matrix to a system of linear equations.\nd. Solve linear systems of equations using the language of matrices.\ne. Translate word problems into linear equations.\nf. Perform Gaussian elimination.\n4. Linear independence, span, basis\na. Define subspace of a vector space.\n191\nb. List examples of subspaces of a vector space.\nc. Recognize and use basic properties of subspaces and vector spaces.\nd. Determine if specific subsets of a vector space are subspaces.\ne. Discuss the existence of a basis of an abstract vector space.\nf. Describe coordinates of a vector relative to a given basis.\ng. Determine a basis for and the dimension of a finite-dimensional space.\nh. Discuss spanning sets for vectors in Rn.\ni. Discuss linear independence for vectors in Rn.\nj. Define the dimension of a vector space.\n5. Orthogonality, projection, least-squares, orthogonal bases\na. Explain the Gram-Schmidt orthogonalization process.\nb. Define orthogonal projections.\nc. Define orthogonal complements.\nd. Compute the orthogonal projection of a vector onto a subspace, given a basis for the subspace.\ne. Explain how orthogonal projections relate to least square approximations.\n6. Linear combinations of polynomials, Bezier curves\na. Identify polynomials as generalized vectors.\nb. Explain linear combinations of basic polynomials.\nc. Describe orthogonality for polynomials.\nd. Distinguish between basic polynomials and Bernstein polynomials.\ne. Apply Bernstein polynomials to Bezier curves.\n7. Eigenvectors and eigenvalues\na. Find the eigenvalues and eigenvectors of a matrix.\nb. Define eigenvalues and eigenvectors geometrically.\nc. Use characteristic polynomials to compute eigenvalues and eigenvectors.\nd. Use eigenspaces of matrices, when possible, to diagonalize a matrix.\ne. Perform diagonalization of matrices.\nf. Explain the significance of eigenvectors and eigenvalues.\ng. Find the characteristic polynomial of a matrix.\nh. Use eigenvectors to represent a linear transformation with respect to a particularly nice basis.\n8. Applications to computer science: PCA, SVD, page-rank, graphics\na. Explain the geometric properties of PCA.\nb. Relate PCA to dimensionality reduction.\nc. Relate PCA to solving least-squares problems.\nd. Relate PCA to solving eigenvector problems.\ne. Apply PCA to reducing the dimensionality of a high-dimensional dataset (e.g., images).\nf. Explain the page-rank algorithm and understand how it relates to eigenvector problems.\ng. Explain the geometric differences between SVD and PCA.\nh. Apply SVD to a concrete example (e.g., movie rankings)."
    }
  },
  {
    "title": "MSF-Calculus",
    "KA Core": "1. Sequences, series, limits\n192\n2. Single-variable derivatives: definition, computation rules (chain rule etc.), derivatives of important\nfunctions, applications\n3. Single-variable integration: definition, computation rules, integrals of important functions,\nfundamental theorem of calculus, definite vs indefinite, applications (including in probability)\n4. Parametric and polar representations\n5. Taylor series\n6. Multivariate calculus: partial derivatives, gradient, chain-rule, vector valued functions,\n7. Optimization: convexity, global vs local minima, gradient descent, constrained optimization, and\nLagrange multipliers.\n8. Ordinary Differential Equations (ODEs): definition, Euler method, applications to simulation, Monte\nCarlo integration\n9. CS applications: gradient descent for machine learning, forward and inverse kinematics,\napplications of calculus to probability\nNote: the calculus topics listed above are aligned with computer science goals rather than with\ntraditional calculus courses. For example, multivariate calculus is often a course by itself, but computer\nscience undergraduates only need parts of it for machine learning.",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Sequences, series, limits\na. Explain the difference between infinite sets and sequences.\nb. Explain the formal definition of a limit.\nc. Derive the limit for examples of sequences and series.\nd. Explain convergence and divergence.\ne. Apply L’Hospital’s rule and other approaches to resolving limits.\n2. Single-variable derivatives: definition, computation rules (chain rule etc.), derivatives of important\nfunctions, applications\na. Explain a derivative in terms of limits.\nb. Explain derivatives as functions.\nc. Perform elementary derivative calculations from limits.\nd. Apply sum, product, and quotient rules.\ne. Work through examples with important functions.\n3. Single-variable integration: definition, computation rules, integrals of important functions,\nfundamental theorem of calculus, definite vs indefinite, applications (including in probability)\na. Explain the definitions of definite and indefinite integrals.\nb. Apply integration rules to examples with important functions.\nc. Explore the use of the fundamental theorem of calculus.\nd. Apply integration to problems.\n4. Parametric and polar representations\na. Apply parametric representations of important curves.\nb. Apply polar representations.\n5. Taylor series\na. Derive Taylor series for some important functions.\nb. Apply the Taylor series to approximations.\n193\n6. Multivariate calculus: partial derivatives, gradient, chain-rule, vector valued functions, applications\nto optimization, convexity, global vs local minima.\na. Compute partial derivatives and gradients.\nb. Work through examples with vector-valued functions with gradient notation.\nc. Explain applications to optimization.\n7. ODEs: definition, Euler method, applications to simulation\na. Apply the Euler method to integration.\nb. Apply the Euler method to a single-variable differential equation.\nc. Apply the Euler method to multiple variables in an ODE.\nProfessional Dispositions\nWe focus on dispositions helpful to students learning mathematics.\n● Growth mindset. Perhaps the most important of the dispositions, students should be persuaded\nthat anyone can learn mathematics, certainly the subset foundational to CS, and that success is not\ndependent on innate ability.\n● Practice mindset. Students should be educated about the nature of “doing” mathematics and\nlearning through practice with problems as opposed to merely listening or observing demonstrations\nin the classroom.\n● Deferred gratification. Most students are likely to learn at least some mathematics from\nmathematics departments unfamiliar with computing applications; computing departments should\nacclimate the students to the notion of waiting to see computing applications. Many of the new\ngrowth areas such as AI or quantum computing can serve as motivation.\n● Persistence. Student perceptions are often driven by frustration with inability to solve hard\nproblems that they see some peers tackle seemingly effortlessly; computing departments should\nhelp promote the notion that eventual success through persistence is what matters.\n● Skepticism and inquiry. Students often look for “given formulas” as handed down by experts only\nto be memorized and used. Yet, a theoretical mindset and, more broadly, a scientific one, should\nfeature skepticism and a curiosity about how formulas are established.\nMathematics Requirements\nThe most important topics expected from students entering a computing program typically correspond\nto pre-calculus courses in high school.\nRequired:\n● Algebra and numeracy\no Numeracy: numbers, operations, types of numbers, fluency with arithmetic, exponent\nnotation, rough orders of magnitude, fractions, and decimals.\no Algebra: rules of exponents, solving linear or quadratic equations with one or two variables,\nfactoring, algebraic manipulation of expressions with multiple variables.\n● Precalculus\no Coordinate geometry: distances between points, areas of common shapes.\no Functions: function notation, drawing and interpreting graphs of functions.\n194\no Exponentials and logarithms: a general familiarity with the functions and their graphs.\no Trigonometry: familiarity with basic trigonometric functions and the unit circle.\nCourse Packaging Suggestions\nEvery department faces constraints in delivering content, which precludes merely requiring a long list of\ncourses covering every single desired topic. These constraints include content-area ownership, faculty\nsize, student preparation, and limits on the number of departmental courses a curriculum can require.\nWe list below some options for offering mathematical foundations, combinations of which might best fit\nany specific institution.\n● Traditional course offerings. With this approach, a computer science department can require\nstudents to take courses provided by mathematics departments in any of the five broad\nmathematical areas listed above.\n● A “Continuous Structures” analog of Discrete Structures. Many computer science departments\nnow offer courses that prepare students mathematically for AI and machine learning. Such courses\ncan combine just enough calculus, optimization, linear algebra, and probability; yet others may split\nlinear algebra into its own course. These courses have the advantage of motivating students with\ncomputing applications and including programming as pedagogy for mathematical concepts.\n● Integration into application courses. An application course, such as machine learning, can be\nspread across two courses, with the course sequence including the needed mathematical\npreparation taught just-in-time, or a single machine learning course can balance preparatory\nmaterial with new topics. This may have the advantage of mitigating turf issues and helping\nstudents see applications immediately after encountering mathematics.\n● Specific course adaptations. For nearly a century, physics and engineering needs have driven\nthe structure of calculus, linear algebra, and probability. Computer science departments can\ncollaborate with their colleagues in mathematics departments to restructure mathematics-offered\nsections in those areas that are driven by computer science applications. For example, calculus\ncould be reorganized to fit the needs of computing programs into two calculus courses, leaving a\nlater third calculus course for engineering and physics students.\nCommittee\nChair: Rahul Simha, The George Washington University, Washington DC, USA\nMembers:\n● Richard Blumenthal, Regis University, Denver, CO, USA\n● Marc Deisenroth, University College London, London, UK\n● MIkey Goldweber, Denison University, Granville, OH, USA\n● David Liben-Nowell, Carleton College, Northfield, MN, USA\n● Jodi Tims, Northeastern University, Boston, MA, USA\n195\nReferences\n1. ACM/IEEE-CS Joint Task Force on Computing Curricula. “Computing Science Curricula 2013.”\n(New York, USA: ACM Press and IEEE Computer Society Press, 2013).\n2. Richard D. De Veaux, Mahesh Agarwal, Maia Averett, Benjamin S. Baumer, Andrew Bray, Thomas\nC. Bressoud, Lance Bryant, Lei Z. Cheng, Amanda Francis, Robert Gould, Albert Y. Kim, Matt\nKretchmar, Qin Lu, Ann Moskol, Deborah Nolan, Roberto Pelayo, Sean Raleigh, Ricky J. Sethi,\nMutiara Sondjaja, Neelesh Tiruviluamala, Paul X. Uhlig, Talitha M. Washington, Curtis L. Wesley,\nDavid White, Ping Ye, Curriculum Guidelines for Undergraduate Programs in Data Science, Annual\nReview of Statistics and Its Application, 4, 1 (2017): 15-30.\n196\nNetworking and Communication (NC)\nPreamble\nNetworking and communication play a central role in interconnected computer systems that are\ntransforming the daily lives of billions of people. The public internet provides connectivity for networked\napplications that serve ever-increasing numbers of individuals and organizations around the world.\nComplementing the public sector, major proprietary networks leverage their global footprints to support\ncost-effective distributed computing, storage, and content delivery. Advances in satellite networks\nexpand connectivity to rural areas. Device-to-device communication underlies the emerging Internet of\nThings.\nThis knowledge area deals with key concepts in networking and communication, as well as their\nrepresentative instantiations in the internet and other computer networks. Besides the basic principles\nof switching and layering, the area at its core provides knowledge on naming, addressing, reliability,\nerror control, flow control, congestion control, domain hierarchy, routing, forwarding, modulation,\nencoding, framing, and access control. The area also covers knowledge units in network security and\nmobility, such as security threats, countermeasures, device-to-device communication, and multi-hop\nwireless networking. In addition to the fundamental principles, the area includes their specific realization\nof the Internet as well as hands-on skills in the implementation of networking and communication\nconcepts. Finally, the area comprises emerging topics such as network virtualization and quantum\nnetworking.\nAs the main learning outcome, learners develop a thorough understanding of the role and operation of\nnetworking and communication in networked computer systems. They learn how network structure and\ncommunication protocols affect the behavior of distributed applications. The area can be used to\neducate not only key principles but also their specific instantiations in the internet and equip the student\nwith hands-on implementation skills. While computer-system, networking, and communication\ntechnologies are advancing at a fast pace, the gained fundamental knowledge enables the student to\nreadily apply the concepts in new technological settings.\nChanges since CS2013\nCompared to the 2013 curricula, the knowledge area broadens its core focus to expand on reliability\nsupport, routing, forwarding, and single-hop communication. Due to the enhanced core, learners\nacquire a deeper understanding of the impact that networking and communication have on the behavior\nof distributed applications. Reflecting the increased importance of network security, the area adds a\nrespective knowledge unit as a new elective. To track the advancing frontiers in networking and\ncommunication knowledge, the social networking knowledge unit was removed and an emerging\nknowledge unit on topics, such as middleboxes, software-defined networks, and quantum networking,\nwas added. Other changes consist of redistributing all the topics from the old unit on resource allocation\namong other units to resolve overlap between knowledge units in the 2013 curricula.\n197\nCore Hours\nKnowledge Unit CS Core KA Core\nFundamentals 2.5 + 0.25 (SEP) + 0.25 (SF)\nNetworked Applications 3.5 + 0.25 (SEP) + 0.25\n(PDC)\nReliability Support 5.75 + 0.25 (SF)\nRouting And Forwarding 4\nSingle-Hop Communication 3\nMobility Support 4\nNetwork Security 2.25 + 0.5 (SEC) + 0.25\n(SEP)\nEmerging Topics 4\nTotal 7 24\nThe shared hours correspond to overlapping concepts that are covered from a networking perspective\nand are only counted here.\nKnowledge Units"
    }
  },
  {
    "title": "NC-Fundamentals: Fundamentals",
    "CS Core": "1. Importance of networking in contemporary computing, and associated challenges. (See also: SEP-\nContext, SEP-Privacy)\n2. Organization of the internet (e.g., users, Internet Service Providers, autonomous systems, content\nproviders, content delivery networks)\n3. Switching techniques (e.g., circuit and packet)\n4. Layers and their roles (application, transport, network, datalink, and physical)\n5. Layering principles (e.g., encapsulation and hourglass model) (See also: SF-Foundations)\n6. Network elements (e.g., routers, switches, hubs, access points, and hosts)\n7. Basic queueing concepts (e.g., relationship with latency, congestion, service levels, etc.)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Articulate the organization of the internet.\n2. List and define the appropriate network terminology.\n198\n3. Describe the layered structure of a typical networked architecture.\n4. Identify the different types of complexity in a network (edges, core, etc.)."
    }
  },
  {
    "title": "NC-Applications: Networked Applications",
    "CS Core": "1. Naming and address schemes (e.g., DNS, and Uniform Resource Identifiers)\n2. Distributed application paradigms (e.g., client/server, peer-to-peer, cloud, edge, and fog) (See also:\nPDC-Communication, PDC-Coordination)\n3. Diversity of networked application demands (e.g., latency, bandwidth, and loss tolerance) (See\nalso: PDC-Communication, SEP-Sustainability, SEP-Context)\n4. Coverage of application-layer protocols (e.g., HTTP)\n5. Interactions with TCP, UDP, and Socket APIs (See also: PDC-Programs)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Define the principles of naming, addressing, resource location.\n2. Analyze the needs of specific networked application demands.\n3. Describe the details of one application layer protocol.\n4. Implement a simple client-server socket-based application."
    }
  },
  {
    "title": "NC-Reliability: Reliability Support",
    "KA Core": "1. Unreliable delivery (e.g., UDP)\n2. Principles of reliability (e.g., delivery without loss, duplication, or out of order) (See also: SF-\nReliability)\n3. Error control (e.g., retransmission, error correction)\n4. Flow control (e.g., stop and wait, window based)\n5. Congestion control (e.g., implicit and explicit congestion notification)\n6. TCP and performance issues (e.g., Tahoe, Reno, Vegas, Cubic)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe the operation of reliable delivery protocols.\n2. List the factors that affect the performance of reliable delivery protocols.\n3. Describe some TCP reliability design issues.\n4. Design and implement a simple reliable protocol."
    }
  },
  {
    "title": "NC-Routing: Routing and Forwarding",
    "KA Core": "1. Routing paradigms and hierarchy (e.g., intra/inter domain, centralized and decentralized, source\nrouting, virtual circuits, QoS)\n2. Forwarding methods (e.g., forwarding tables and matching algorithms)\n3. IP and Scalability issues (e.g., NAT, CIDR, BGP, different versions of IP)\n199",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe various routing paradigms and hierarchies.\n2. Describe how packets are forwarded in an IP network.\n3. Describe how the Internet tackles scalability challenges. ."
    }
  },
  {
    "title": "NC-SingleHop: Single Hop Communication",
    "KA Core": "1. Introduction to modulation, bandwidth, and communication media\n2. Encoding and Framing\n3. Medium Access Control (MAC) (e.g., random access and scheduled access)\n4. Ethernet and WiFi\n5. Switching (e.g., spanning trees, VLANS).\n6. Local Area Network Topologies (e.g., data center, campus networks).",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe some basic aspects of modulation, bandwidth, and communication media.\n2. Describe in detail a MAC protocol.\n3. Demonstrate understanding of encoding and framing solution tradeoffs.\n4. Describe details of the implementation of Ethernet.\n5. Describe how switching works.\n6. Describe one kind of a LAN topology."
    }
  },
  {
    "title": "NC-Security: Network Security",
    "KA Core": "1. General intro about security (Threats, vulnerabilities, and countermeasures) (See also: SEP-\nSecurity, SEC-Foundations, SEC-Engineering)\n2. Network specific threats and attack types (e.g., denial of service, spoofing, sniffing and traffic\nredirection, attacker-in-the-middle, message integrity attacks, routing attacks, ransomware, and\ntraffic analysis) (See also: SEC-Foundations, SEC-Engineering)\n3. Countermeasures (: SEC-Foundations, SEC-Crypto, SEC-Engineering)\na. Cryptography (e.g. SSL, TLS, symmetric/asymmetric)\nb. Architectures for secure networks (e.g., secure channels, secure routing protocols, secure\nDNS, VPNs, DMZ, Zero Trust Network Access, hyper network security, anonymous\ncommunication protocols, isolation)\nc. Network monitoring, intrusion detection, firewalls, spoofing and DoS protection, honeypots,\ntracebacks, BGP Sec, RPKI",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe some of the threat models of network security.\n200\n2. Describe specific network-based countermeasures.\n3. Analyze various aspects of network security from a case study."
    }
  },
  {
    "title": "NC-Mobility: Mobility",
    "KA Core": "1. Principles of cellular communication (e.g., 4G, 5G)\n2. Principles of Wireless LANs (mainly 802.11)\n3. Device to device communication (e.g., IoT communication)\n4. Multi-hop wireless networks (e.g., ad hoc networks, opportunistic, delay tolerant)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe some aspects of cellular communication such as registration\n2. Describe how 802.11 supports mobile users\n3. Describe practical uses of device-to-device communication, as well as multihop\n4. Describe one type of mobile network such as ad hoc"
    }
  },
  {
    "title": "NC-Emerging: Emerging Topics",
    "KA Core": "1. Middleboxes (e.g., advances in usage of AI, intent-based networking, filtering, deep packet\ninspection, load balancing, NAT, CDN)\n2. Network Virtualization (e.g., SDN, Data Center Networks)\n3. Quantum Networking (e.g., Intro to the domain, teleportation, security, Quantum Internet)\n4. Satellite, mmWave, Visible Light",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe the value of advances in middleboxes in networks.\n2. Describe the importance of Software Defined Networks.\n3. Describe some of the added value achieved by using Quantum Networking.\nProfessional Dispositions\n● Meticulous: Students must be particular about the specifics of understanding and creating\nnetworking protocols.\n● Collaborative: Students must work together to develop multiple components that interact together\nand to respond to failures and threats.\n● Proactive: Students must be able to predict failures, threats, and how to deal with them while\navoiding reactive modes of operation only.\n● Professional: Students must comply with the needs of the community and their expectations from\na networked environment, and the demands of regulatory bodies.\n201\n● Responsive: Students must act swiftly to changes in requirements in network configurations and\nchanging user requirements.\n● Adaptive: Students need to reconfigure systems under varying modes of operation.\nMathematics Requirements\nRequired:\n● MSF-Probability.\n● MSF-Statistics.\n● MSF-Discrete.\n● MSF-Linear Simple queuing theory concepts.\nCourse Packaging Suggestions\nCoverage of the concepts of networking including but not limited to types of applications used by the\nnetwork, reliability, routing and forwarding, single hop communication, security, and other emerging\ntopics.\nNote: both courses cover the same knowledge units but with different allocation of hours for each\nknowledge unit.\nCourse objectives: By the end of this course, learners should be able to understand many of the\nfundamental concepts associated with networking, learn about many types of networked applications,\nand develop at least one, understand basic routing and forwarding, single hop communications, and\ndeal with some issues pertaining to mobility, security, and emerging areas, all with embedded social,\nethical, and issues pertaining to the profession.\nIntroductory Course:\n● NC-Fundamentals (8 hours)\n● NC-Applications (12 hours)\n● NC-Reliability (6 hours)\n● NC-Routing (4 hours)\n● NC-SingleHop (3 hours)\n● NC-Mobility (3 hours)\n● NC-Security (3 hours)\n● SEP-Context (1 hour)\n● NC-Emerging (2 hours)\nCourse objectives: By the end of this course, learners would have obtained a refresher about some of\nthe fundamental issues of networking, networked applications, reliability, and routing and forwarding,\nand indulged in additional details of single hop communications, mobility, security, and emerging topics\nin the area, all while considering embedded social and ethical issues as well as issues pertaining to the\nprofession.\n202\nAdvanced Course:\n● NC-Fundamentals (3 hours)\n● NC-Applications (4 hours)\n● NC-Reliability(7 hours)\n● NC-Routing (6 hours)\n● NC-SingleHop (5 hours)\n● NC-Mobility (5 hours)\n● NC-Security (5 hours)\n● SEP-Privacy, SEP-Security, SEP-Sustainability (2 hours)\n● NC-Emerging (5 hours)\nCommittee\nChair: Sherif G. Aly, The American University in Cairo, Cairo, Egypt\nMembers:\n● Khaled Harras, Carnegie Mellon University, Pittsburgh, PA, USA\n● Moustafa Youssef, The American University in Cairo, Cairo, Egypt\n● Sergey Gorinsky, IMDEA Networks Institute, Madrid, Spain\n● Qiao Xiang, Xiamen University, Xiamen, China\nContributors:\n● Alex (Xi) Chen: Huawei, Montreal, Canada\n203\n204\nOperating Systems (OS)\nPreamble\nThe operating system is a collection of services needed to safely interface the hardware with\napplications. Core topics focus on the mechanisms and policies needed to virtualize computation,\nmemory, and Input/Output (I/O). Overarching themes that are reused at many levels in computer\nsystems are well illustrated in operating systems (e.g., polling vs interrupts, caching, flexibility vs costs,\nscheduling approaches to processes, page replacement, etc.). The Operating Systems knowledge area\ncontains the key underlying concepts for other knowledge areas — trust boundaries, concurrency,\npersistence, and safe extensibility.\nChanges since CS2013\nChanges from CS2013 include:\n● Renamed File Systems knowledge unit to File Systems API and Implementation knowledge\nunit,\n● Moved topics from the previous Performance and Evaluation knowledge unit to the Systems\nFundamentals (SF) knowledge area,\n● Moved some topics from File Systems API and Implementation and Device Management to the\nAdvanced File Systems knowledge unit, and\n● Added topics on systems programming and the creation of platform-specific executables to the\nFoundations of Programming Languages (FPL) knowledge area.\nCore Hours\nKnowledge Unit CS Core KA Core\nRole and Purpose of Operating Systems 2\nPrinciples of Operating System 2\nConcurrency 2 1\nProtection and Safety 2 1\nScheduling 2\nProcess Model 2\nMemory Management 0.5 +1.5 (AR)\nDevice Management 0.5+0.5 (AR)\n205\nFile Systems API and Implementation 2\nAdvanced File Systems 1\nVirtualization 1\nReal-time and Embedded Systems 1\nFault Tolerance 1\nSociety, Ethics, and the Profession Included in SEP hours\nTotal 8 13 (+ 2 counted in AR)\nKnowledge Units"
    }
  },
  {
    "title": "OS-Purpose: Role and Purpose of Operating Systems",
    "CS Core": "1. Operating systems mediate between general purpose hardware and application-specific software.\n2. Universal operating system functions (e.g., process, user and device interfaces, persistence of\ndata)\n3. Extended and/or specialized operating system functions (e.g., embedded systems, server types\nsuch as file, web, multimedia, boot loaders and boot security)\n4. Design issues (e.g., efficiency, robustness, flexibility, portability, security, compatibility, power,\nsafety, tradeoffs between error checking and performance, flexibility and performance, and security\nand performance) (See also: SEC-Engineering)\n5. Influences of security, networking, multimedia, parallel and distributed computing\n6. Overarching concern of security/protection: Neglecting to consider security at every layer creates\nan opportunity to inappropriately access resources.\nExample concepts:\na. Unauthorized access to files on an unencrypted drive can be achieved by moving the media to\nanother computer.\nb. Operating systems enforced security can be defeated by infiltrating the boot layer before the\noperating system is loaded.\nc. Process isolation can be subverted by inadequate authorization checking at API boundaries.\nd. Vulnerabilities in system firmware can provide attack vectors that bypass the operating system\nentirely.\ne. Improper isolation of virtual machine memory, computing, and hardware can expose the host\nsystem to attacks from guest systems.\nf. The operating system may need to mitigate exploitation of hardware and firmware\nvulnerabilities, leading to potential performance reductions (e.g., Spectre and Meltdown\nmitigations).\n7. Exposure of operating systems functions in shells and systems programming. (See also: FPL-\nScripting)\n206",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Understand the objectives and functions of modern operating systems.\n2. Evaluate the design issues in different usage scenarios (e.g., real time OS, mobile, server).\n3. Understand the functions of a contemporary operating system with respect to convenience,\nefficiency, and the ability to evolve.\n4. Understand how evolution and stability are desirable and mutually antagonistic in operating\nsystems function."
    }
  },
  {
    "title": "OS-Principles: Principles of Operating System",
    "CS Core": "1. Operating system software design and approaches (e.g., monolithic, layered, modular, micro-\nkernel, unikernel)\n2. Abstractions, processes, and resources\n3. Concept of system calls and links to application program interfaces (e.g., Win32, Java, Posix). (See\nalso: AR-Assembly)\n4. The evolution of the link between hardware architecture and the operating system functions\n5. Protection of resources means protecting some machine instructions/functions (See also: AR-\nAssembly)\nExample concepts:\na. Applications cannot arbitrarily access memory locations or file storage device addresses.\nb. Protection of coprocessors and network devices\n6. Leveraging interrupts from hardware level: service routines and implementations. (See also: AR-\nAssembly)\nExample concepts:\na. Timer interrupts for implementing time slices\nb. I/O interrupts for putting blocking threads to sleep without polling\n7. Concept of user/system state and protection, transition to kernel mode using system calls (See\nalso: AR-Assembly)\n8. Mechanism for invoking system calls, the corresponding mode and context switch and return from\ninterrupt (See also: AR-Assembly)\n9. Performance costs of context switches and associated cache flushes when performing process\nswitches in Spectre-mitigated environments.",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Understand how the application of software design approaches to operating systems\ndesign/implementation (e.g., layered, modular, etc.) affects the robustness and maintainability of an\noperating system.\n2. Categorize system calls by purpose.\n3. Understand dynamics of invoking a system call (e.g., passing parameters, mode change).\n4. Evaluate whether a function can be implemented in the application layer or can only be\naccomplished by system calls.\n207\n5. Apply OS techniques for isolation, protection, and throughput across OS functions (e.g., starvation\nsimilarities in process scheduling, disk request scheduling, semaphores, etc.) and beyond.\n6. Understand how the separation into kernel and user mode affects safety and performance.\n7. Understand the advantages and disadvantages of using interrupt processing in enabling\nmultiprogramming.\n8. Analyze potential vectors of attack via the operating systems and the security features designed to\nguard against them."
    }
  },
  {
    "title": "OS-Concurrency: Concurrency",
    "CS Core": "1. Thread abstraction relative to concurrency\n2. Race conditions, critical regions (role of interrupts, if needed) (See also: PDC-Programs)\n3. Deadlocks and starvation (See also: PDC-Coordination)\n4. Multiprocessor issues (spin-locks, reentrancy).\n5. Multiprocess concurrency vs multithreading",
    "KA Core": "6. Thread creation, states, structures (See also: SF-Foundations)\n7. Thread APIs\n8. Deadlocks and starvation (necessary conditions/mitigations) (See also: PDC-Coordination)\n9. Implementing thread safe code (semaphores, mutex locks, condition variables). (See also: AR-\nPerformance-Energy, SF-Evaluation, PDC-Evaluation)\n10. Race conditions in shared memory (See also: PDC-Coordination)\nNon-Core:\n11. Managing atomic access to OS objects (e.g., big kernel lock vs many small locks vs lockless data\nstructures like lists)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Understand the advantages and disadvantages of concurrency as inseparable functions within the\noperating system framework.\n2. Understand how architecture level implementation results in concurrency problems including race\nconditions.\n3. Understand concurrency issues in multiprocessor systems.",
      "KA Core": "4. Understand the range of mechanisms that can be employed at the operating system level to realize\nconcurrent systems and describe the benefits of each.\n5. Understand techniques for achieving synchronization in an operating system (e.g., describe how a\nsemaphore can be implemented using OS primitives) including intra-concurrency control and use of\nhardware atomics.\n6. Accurately analyze code to identify race conditions and appropriate solutions for addressing race\nconditions.\n208"
    }
  },
  {
    "title": "OS-Protection: Protection and Safety",
    "CS Core": "1. Overview of operating system security mechanisms (See also: SEC-Foundations)\n2. Attacks and antagonism (scheduling, etc.) (See also: SEC-Foundations)\n3. Review of major vulnerabilities in real operating systems (See also: SEC-Foundations)\n4. Operating systems mitigation strategies such as backups (See also: SF-Reliability)",
    "KA Core": "5. Policy/mechanism separation (See also: SEC-Governance)\n6. Security methods and devices (See also: SEC-Foundations)\nExample concepts:\na. Rings of protection (history from Multics to virtualized x86)\nb. x86_64 rings -1 and -2 (hypervisor and ME/PSP)\n7. Protection, access control, and authentication (See also: SEC-Foundations, SEC-Crypto)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Understand the requirement for protection and security mechanisms in operating systems.\n2. List and describe the attack vectors that leverage OS vulnerabilities.\n3. Understand the mechanisms available in an OS to control access to resources.",
      "KA Core": "4. Summarize the features and limitations of an operating system that impact protection and security."
    }
  },
  {
    "title": "OS-Scheduling: Scheduling",
    "KA Core": "1. Preemptive and non-preemptive scheduling\n2. Schedulers and policies (e.g., first come, first serve, shortest job first, priority, round robin,\nmultilevel) (See also: SF-Resource)\n3. Concepts of Symmetric Multi-Processor (SMP) scheduling and cache coherence (See also: AR-\nMemory)\n4. Timers (e.g., building many timers out of finite hardware timers) (See also: AR-Assembly)\n5. Fairness and starvation\nNon-Core:\n6. Subtopics of operating systems such as energy-aware scheduling and real-time scheduling (See\nalso: AR-Performance-Energy, SPD-Embedded, SPD-Mobile)\n7. Cooperative scheduling, such as Linux futexes and userland scheduling.",
    "Illustrative Learning Outcomes": {
      "KA Core": "209\n1. Compare and contrast the common algorithms used for both preemptive and non-preemptive\nscheduling of tasks in operating systems, such as priority, performance comparison, and fair-share\nschemes.\n2. Explain the relationships between scheduling algorithms and application domains.\n3. Explain the distinctions among types of processor scheduler such as short-term, medium-term,\nlong-term, and I/O.\n4. Evaluate a problem or solution to determine appropriateness for asymmetric and/or symmetric\nmultiprocessing.\n5. Evaluate a problem or solution to determine appropriateness as a process vs threads.\n6. List some contexts benefitting from preemption and deadline scheduling.\nNon-Core:\n7. Explain the ways that the logic embodied in scheduling algorithms are applicable to other operating\nsystems mechanisms, such as first come first serve or priority to disk I/O, network scheduling,\nproject scheduling, and problems beyond computing."
    }
  },
  {
    "title": "OS-Process: Process Model",
    "KA Core": "1. Processes and threads relative to virtualization protected memory, process state, memory\nisolation, etc.\n2. Memory footprint/segmentation (e.g., stack, heap, etc.) (See also: AR-Assembly)\n3. Creating and loading executables, shared libraries, and dynamic linking (See also: FPL-Translation)\n4. Dispatching and context switching (See also: AR-Assembly)\n5. Interprocess communication (e.g., shared memory, message passing, signals, environment\nvariables) (See also: PDC-Communication)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Understand how processes and threads use concurrency features to virtualize control.\n2. Understand reasons for using interrupts, dispatching, and context switching to support concurrency\nand virtualization in an operating system.\n3. Understand the different states that a task may pass through, and the data structures needed to\nsupport the management of many tasks.\n4. Understand the different ways of allocating memory to tasks, citing the relative merits of each.\n5. Apply the appropriate interprocess communication mechanism for a specific purpose in a\nprogrammed software artifact."
    }
  },
  {
    "title": "OS-Memory: Memory Management",
    "KA Core": "1. Review of physical memory, address translation and memory management hardware (See also:\nAR-Memory, MSF-Discrete)\n2. Impact of memory hierarchy including cache concept, cache lookup, and per-CPU caching on\noperating system mechanisms and policy (See also: AR-Memory, SF-Performance)\n210\n3. Logical and physical addressing, address space virtualization (See also: AR-Memory, MSF-\nDiscrete)\n4. Concepts of paging, page replacement, thrashing and allocation of pages and frames\n5. Allocation/deallocation/storage techniques (algorithms and data structure) performance and\nflexibility\nExample concept: Arenas, slab allocators, free lists, size classes, heterogeneously sized pages\n(huge pages)\n6. Memory caching and cache coherence and the effect of flushing the cache to avoid speculative\nexecution vulnerabilities (See also: AR-Organization, AR-Memory, SF-Performance)\n7. Security mechanisms and concepts in memory management including sandboxing, protection,\nisolation, and relevant vectors of attack (See also: SEC-Foundations)\nNon-Core:\n8. Virtual memory: leveraging virtual memory hardware for OS services and efficiency",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Explain memory hierarchy and cost-performance tradeoffs.\n2. Summarize the principles of virtual memory as applied to caching and paging.\n3. Evaluate the tradeoffs in terms of memory size (main memory, cache memory, auxiliary memory)\nand processor speed.\n4. Describe the reason for and use of cache memory (performance and proximity, how caches\ncomplicate isolation and virtual machine abstraction).\n5. Code/Develop efficient programs that consider the effects of page replacement and frame allocation\non the performance of a process and the system in which it executes.\nNon-Core:\n6. Explain how hardware is utilized for efficient virtualization"
    }
  },
  {
    "title": "OS-Devices: Device management",
    "KA Core": "1. Buffering strategies (See also: AR-IO)\n2. Direct Memory Access (DMA) and polled I/O, Memory-mapped I/O (See also: AR-IO)\nExample concept: DMA communication protocols (e.g., ring buffers etc.)\n3. Historical and contextual - Persistent storage device management (e.g., magnetic, Solid State\nDevice (SSD)) (See also: SEP-History)\nNon-Core:\n4. Device interface abstractions, hardware abstraction layer\n5. Device driver purpose, abstraction, implementation, and testing challenges\n6. High-level fault tolerance in device communication",
    "Illustrative Learning Outcomes": {
      "KA Core": "211\n1. Explain architecture level device control implementation and link relevant operating system\nmechanisms and policy (e.g., buffering strategies, direct memory access).\n2. Explain OS device management layers and the architecture (e.g., device controller, device driver,\ndevice abstraction).\n3. Explain the relationship between the physical hardware and the virtual devices maintained by the\noperating system.\n4. Explain I/O data buffering and describe strategies for implementing it.\n5. Describe the advantages and disadvantages of direct memory access and discuss the\ncircumstances in which its use is warranted.\nNon-Core:\n6. Describe the complexity and best practices for the creation of device drivers."
    }
  },
  {
    "title": "OS-Files: File Systems API and Implementation",
    "KA Core": "1. Concept of a file including data, metadata, operations, and access-mode\n2. File system mounting\n3. File access control\n4. File sharing\n5. Basic file allocation methods, including linked allocation table\n6. File system structures comprising file allocation including various directory structures and methods\nfor uniquely identifying files (e.g., name, identified or metadata storage location)\n7. Allocation/deallocation/storage techniques (algorithms and data structure) impact on performance\nand flexibility (i.e., internal and external fragmentation and compaction)\n8. Free space management such as using bit tables vs linking\n9. Implementation of directories to segment and track file location",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Explain the choices to be made in designing file systems.\n2. Evaluate different approaches to file organization, recognizing the strengths and weaknesses of\neach.\n3. Apply software constructs appropriately given knowledge of the file system implementation."
    }
  },
  {
    "title": "OS-Advanced-Files: Advanced File systems",
    "KA Core": "1. File systems: partitioning, mount/unmount, virtual file systems\n2. In-depth implementation techniques\n3. Memory-mapped files (See also: AR-IO )\n4. Special-purpose file systems\n5. Naming, searching, access, backups\n6. Journaling and log-structured file systems (See also: SF-Reliability)\n212\nNon-Core: (including emerging topics)\n1. Distributed file systems\n2. Encrypted file systems\n3. Fault tolerance",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Explain how hardware developments have led to changes in the priorities for the design and the\nmanagement of file systems.\n2. Map file abstractions to a list of relevant devices and interfaces.\n3. Identify and categorize different mount types.\n4. Explain specific file systems requirements and the specialized file systems features that meet those\nrequirements.\n5. Explain the use of journaling and how log-structured file systems enhance fault tolerance.\nNon-Core:\n6. Explain purpose and complexity of distributed file systems.\n7. List examples of distributed file systems protocols.\n8. Explain mechanisms in file systems to improve fault tolerance."
    }
  },
  {
    "title": "OS-Virtualization: Virtualization",
    "KA Core": "1. Using virtualization and isolation to achieve protection and predictable performance. (See also: SF-\nPerformance)\n2. Advanced paging and virtual memory. (See also: SF-Performance)\n3. Virtual file systems and virtual devices.\n4. Containers and their comparison to virtual machines.\n5. Thrashing (e.g., Popek and Goldberg requirements for recursively virtualizable systems).",
    "Non-core": "6. Types of virtualizations (including hardware/software, OS, server, service, network). (See also: SF-\nPerformance)\n7. Portable virtualization; emulation vs isolation. (See also: SF-Performance)\n8. Cost of virtualization. (See also: SF-Performance)\n9. Virtual machines and container escapes, dangers from a security perspective. (See also: SEC-\nEngineering)\n10. Hypervisors- hardware virtual machine extensions, hosts with kernel support, QEMU KVM",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Explain how hardware architecture provides support and efficiencies for virtualization.\n2. Explain the difference between emulation and isolation.\n3. Evaluate virtualization tradeoffs.\n213\nNon-Core:\n4. Explain hypervisors and the need for them in conjunction with different types of hypervisors."
    }
  },
  {
    "title": "OS-Real-time: Real-time and Embedded Systems",
    "KA Core": "1. Process and task scheduling.\n2. Deadlines and real-time issues. (See also: SPD-Embedded)\n3. Low-latency vs ”soft real-time\" vs \"hard real time.\" (See also: SPD-Embedded, FPL-Event-Driven)\nNon-Core:\n4. Memory/disk management requirements in a real-time environment.\n5. Failures, risks, and recovery.\n6. Special concerns in real-time systems (safety).",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Explain what makes a system a real-time system.\n2. Explain latency and its sources in software systems and its characteristics.\n3. Explain special concerns that real-time systems present, including risk, and how these concerns are\naddressed.\nNon-Core:\n4. Explain specific real time operating systems features and mechanisms."
    }
  },
  {
    "title": "OS-Faults: Fault tolerance",
    "KA Core": "1. Reliable and available systems. (See also: SF-Reliability)\n2. Software and hardware approaches to address tolerance (RAID). (See also: SF-Reliability)\nNon-Core:\n3. Spatial and temporal redundancy. (See also: SF-Reliability)\n4. Methods used to implement fault tolerance. (See also: SF-Reliability)\n5. Error identification and correction mechanisms, checksums of volatile memory in RAM. (See also:\nAR-Memory)\n6. File system consistency check and recovery.\n7. Journaling and log-structured file systems. (See also: SF-Reliability)\n8. Use-cases for fault-tolerance (databases, safety-critical). (See also: SF-Reliability)\n9. Examples of OS mechanisms for detection, recovery, restart to implement fault tolerance, use of\nthese techniques for the OS’s own services. (See also: SF-Reliability)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Explain how operating systems can facilitate fault tolerance, reliability, and availability.\n214\n2. Explain the range of methods for implementing fault tolerance in an operating system.\n3. Explain how an operating system can continue functioning after a fault occurs.\n4. Explain the performance and flexibility tradeoffs that impact using fault tolerance.\nNon-Core:\n5. Describe operating systems fault tolerance issues and mechanisms in detail."
    }
  },
  {
    "title": "OS-SEP: Society, Ethics, and the Profession",
    "KA Core": "1. Open source in operating systems. (See also: SEP-IP)\nExample concepts:\na. Identification of vulnerabilities in open-source kernels,\nb. Open-source guest operating systems,\nc. Open-source host operating systems, and\nd. Changes in monetization (paid vs free upgrades).\n2. End-of-life issues with sunsetting operating systems.\nExample concept: Privacy implications of using proprietary operating systems/operating\nenvironments, including telemetry, automated scanning of personal data, built-in advertising, and\nautomatic cloud integration.",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Explain advantages and disadvantages of finding and addressing bugs in open-source kernels.\n2. Contextualize history and positive and negative impact of Linux as an open-source product.\n3. List complications with reliance on operating systems past end-of-life.\n4. Understand differences in finding and addressing bugs for various operating systems payment\nmodels.\nProfessional Dispositions\n● Proactive: Students must anticipate the security and performance implications of how operating\nsystems components are used.\n● Meticulous: Students must carefully analyze the implications of operating system mechanisms on\nany project.\nMathematics Requirements\nRequired:\n● MSF-Discrete\nCourse Packaging Suggestions\nIntroductory Course to include the following:\n215\n● OS-Purpose (3 hours)\n● OS-Principles (3 hours)\n● OS-Concurrency (7 hours)\n● OS-Scheduling (3 hours)\n● OS-Process (3 hours)\n● OS-Memory (4 hours)\n● OS-Protection (4 hours)\n● OS-Devices (2 hours)\n● OS-Files (2 hours)\n● OS-Virtualization (3 hours)\n● OS-Advanced-Files (2 hours)\n● OS-Real-time (1 hour)\n● OS-Faults (1 hour)\n● OS-SEP (4 hours)\nPrerequisites:\n● AR-Assembly\n● AR-Memory\n● AR-Reliability\n● AR-IO\n● AR-Organization\n● MSF-Discrete\nCourse objectives: Students should understand the impact and implications of operating system\nresource management in terms of performance and security. They should understand and implement\ninter-process communication mechanisms safely. They should be able to differentiate between the use\nand evaluation of open-source and/or proprietary operating systems. They should understand\nvirtualization as a feature of safe modern operating system implementation.\nCommittee\nChair: Monica D. Anderson, University of Alabama, Tuscaloosa, AL, USA\nMembers:\n● Qiao Xiang, Xiamen University, Xiamen, China\n● Mikey Goldweber, Denison University, Granville, OH, USA\n● Marcelo Pias, Federal University of Rio Grande (FURG), Rio Grande, RS, Brazil\n● Avi Silberschatz, Yale University, New Haven, CT, USA\n● Renzo Davoli, University of Bologna, Bologna, Italy\n216\nParallel and Distributed Computing (PDC)\nPreamble\nParallel and distributed programming arranges, coordinates, and controls multiple computations\noccurring at the same time across different places. The ubiquity of parallelism and distribution are\ninevitable consequences of increasing numbers of gates in processors, processors in computers, and\ncomputers everywhere that may be used to improve performance compared to sequential programs,\nwhile also coping with the intrinsic interconnectedness of the world, and the possibility that some\ncomponents or connections fail or behave maliciously. Parallel and distributed programming removes\nthe restrictions of sequential programming that require computational steps to occur in a serial order in\na single place, revealing further distinctions, techniques, and analyses applying at each layer of\ncomputing systems.\nIn most conventional usage, “parallel” programming focuses on establishing and coordinating multiple\nactivities that may occur at the same time, “distributed” programming focuses on establishing and\ncoordinating activities that may occur in different places, and “concurrent” programming focuses on\ninteractions of ongoing activities with each other and the environment. However, all three terms may\napply in most contexts. Parallelism generally implies some form of distribution because multiple\nactivities occurring without sequential ordering constraints happen in multiple physical places (unless\nthey rely on context-switching or quantum effects). Conversely, actions in different places need not\nbear any specific sequential ordering with respect to each other in the absence of communication\nconstraints.\nParallel, distributed, and concurrent programming techniques form the core of High Performance\nComputing (HPC), distributed systems, and increasingly, nearly every computing application. The PDC\nknowledge area has evolved from a diverse set of advanced topics into a central body of knowledge\nand practice, permeating almost every other aspect of computing. Growth of the field has occurred\nirregularly across different subfields of computing, sometimes with different goals, terminology, and\npractices, masking the considerable overlap of basic ideas and skills that are the primary focus of this\nknowledge area. Nearly every problem with a sequential solution also admits parallel and/or distributed\nsolutions; additional problems and solutions arise only in the context of concurrency. Nearly every\napplication domain of parallel and distributed computing is a well-developed area of study and/or\nengineering too large to enumerate.\nChanges since CS2013\nThis knowledge area has been refactored to focus on commonalities across different forms of parallel\nand distributed computing, also enabling more flexibility in KA Core coverage, with more guidance on\ncoverage options.\nOverview\nThis knowledge area is divided into five knowledge units, each with CS Core and KA Core topics that\nextend but do not overlap CS Core coverage that appears in other knowledge areas. The five\n217\nknowledge units cover: The nature of parallel and distributed Programs and their execution;\nCommunication (via channels, memory, or shared data stores), Coordination among parallel\nactivities to achieve common outcomes; Evaluation with respect to specifications, and Algorithms\nacross multiple application domains.\nCS Core topics span approaches to parallel and distributed computing but restrict coverage to those\nthat apply to nearly all of them. Learning outcomes include developing small programs (in a choice of\nseveral styles) with multiple activities and analyzing basic properties. The topics and hours do not\ninclude coverage of specific languages, tools, frameworks, systems, and platforms needed as a basis\nfor implementing and evaluating concepts and skills. The topics also avoid reliance on specifics that\nmay vary widely (for example GPU programming vs cloud container deployment scripts), Prerequisites\nfor CS Core coverage include the following.\n● SDF-Fundamentals: programs, executions, specifications, implementations, variables, arrays,\nsequential control flow, procedural abstraction and invocation, Input/Output.\n● SF-Overview: Layered systems, state machines, reliability.\n● AR-Assembly, AR-Memory: von Neumann architecture, memory hierarchy.\n● MSF-Discrete: Discrete structures including directed graphs.\nAdditionally, Foundations of Programming Languages (FPL) may be treated as a prerequisite,\ndepending on other curricular choices. CS Core requires familiarity with languages and platforms that\nenable construction of parallel and distributed programs. Also, PDC includes definitions of safety,\nliveness, and related concepts that are covered with respect to language properties and semantics in\nFPL. Similarly, PDC CS Core includes concepts that are further developed in the context of network\nprotocols in Networking and Communication (NC), Operating Systems (OS), and Security (SEC), that\ncould be covered in any order.\nKA Core topics in each unit are of the form “one or more of the following” for a la carte topics extending\nassociated core topics. Any selection of KA-core topics meeting the KA Core hour requirement\nconstitutes fulfillment of the KA Core. This structure permits variation in coverage depending on the\nfocus of any given course (see below for examples). Depth of coverage of any KA Core subtopic is\nexpected to vary according to course goals. For example, shared-memory coordination is a central\ntopic in multicore programming, but much less so in most heterogeneous systems, and conversely for\nbulk data transfer. Similarly, fault tolerance is central to the design of distributed information systems,\nbut much less so in most data-parallel applications.\nCore Hours\nKnowledge Unit CS Core hours KA Core hours\nPrograms 2 2\nCommunication 2 6\nCoordination 2 6\n218\nEvaluation 1 3\nAlgorithms 2 9\nSociety, Ethics, and the Profession Included in SEP hours\nTotal 9 26\nKnowledge Units"
    }
  },
  {
    "title": "PDC-Programs: Programs",
    "CS Core": "1. Graphically show (as a Directed Acyclic Graph (DAG)) how to parallelize a compound numerical\nexpression; for example, a = (b + c) * (d + e).\n2. Explain why the concepts of consistency and fault tolerance do not arise in purely sequential\nprograms.",
    "KA Core": "3. Write a function that efficiently counts events such as networking packet receptions.\n4. Write a filter/map/reduce program in multiple styles.\n5. Write a service that creates a thread (or other procedural form of activation) to return a requested\nweb page to each new client."
  },
  {
    "title": "PDC-Communication: Communication",
    "CS Core": "1. Media\na. Varieties: channels (message passing or I/O), shared memory, heterogeneous, data stores\nb. Reliance on the availability and nature of underlying hardware, connectivity, and protocols;\nlanguage support, emulation (See also: AR-IO)\n2. Channels\na. Explicit (usually named) party-to-party communication media\nb. APIs: Sockets, architectural, language-based, and toolkit constructs, such as Message\nPassing Interface (MPI), and layered constructs such as Remote Procedure Call (RPC) (See\nalso: NC-Fundamentals)\nc. I/O channel APIs\n3. Memory\n220\na. Shared memory architectures in which parties directly communicate only with memory at\ngiven addresses, with extensions to heterogeneous memory supporting multiple memory\nstores with explicit data transfer across them; for example, GPU local and shared memory,\nDirect Memory Access (DMA)\nb. Memory hierarchies: Multiple layers of sharing domains, scopes, and caches; locality:\nlatency, false-sharing\nc. Consistency properties: Bitwise atomicity limits, coherence, local ordering\n4. Data Stores\na. Cooperatively maintained data structures implementing maps and related ADTs\nb. Varieties: Owned, shared, sharded, replicated, immutable, versioned",
    "KA Core": "5. One or more of the following properties and extensions\na. Topologies: Unicast, Multicast, Mailboxes, Switches; Routing via hardware and software\ninterconnection networks\nb. Media concurrency properties: Ordering, consistency, idempotency, overlapping\ncommunication with computation\nc. Media performance: Latency, bandwidth (throughput) contention (congestion),\nresponsiveness (liveness), reliability (error and drop rates), protocol-based progress (acks,\ntimeouts, mediation)\nd. Media security properties: integrity, privacy, authentication, authorization (See also: SEC-\nSecure Coding)\ne. Data formats: Marshaling, validation, encryption, compression\nf. Channel policies: Endpoints, sessions, buffering, saturation response (waiting vs dropping),\nrate control\ng. Multiplexing and demultiplexing many relatively slow I/O devices or parties; completion-\nbased and scheduler-based techniques; async-await, select and polling APIs\nh. Formalization and analysis of channel communication; for example, CSP\ni. Applications of queuing theory to model and predict performance.\nj. Memory models: sequential and release/acquire consistency\nk. Memory management; including reclamation of shared data; reference counts and\nalternatives\nl. Bulk data placement and transfer; reducing message traffic and improving locality;\noverlapping data transfer and computation; impact of data layout such as array-of-structs vs\nstruct-of-arrays\nm. Emulating shared memory: distributed shared memory, Remote Direct Memory Access\n(RDMA)\nn. Data store consistency: Atomicity, linearizability, transactionality, coherence, causal\nordering, conflict resolution, eventual consistency, blockchains\no. Faults, partitioning, and partial failures; voting; protocols such as Paxos and Raft.\np. Design tradeoffs among consistency, availability, partition (fault) tolerance; impossibility of\nmeeting all at once\nq. Security and trust: Byzantine failures, proof of work and alternatives\n221",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Explain the similarities and differences among: (1) Party A sends a message on channel X with\ncontents 1 received by party B (2) A sets shared variable X to 1, read by B (3) A sets “X=1’ in a\ndistributed shared map accessed by B.",
      "KA Core": "2. Write a program that distributes different segments of a data set to multiple workers, and collects\nresults (for the simplest example, summing segments of an array).\n3. Write a parallel program that requests data from multiple sites and summarizes them using some\nform of reduction.\n4. Compare the performance of buffered versus unbuffered versions of a producer-consumer\nprogram.\n5. Determine whether a given communication scheme provides sufficient security properties for a\ngiven usage.\n6. Give an example of an ordering of accesses among concurrent activities (e.g., program with a data\nrace) that is not sequentially consistent.\n7. Give an example of a scenario in which blocking message sends can deadlock.\n8. Describe at least one design technique for avoiding liveness failures in programs using multiple\nlocks.\n9. Write a program that illustrates memory-access or message reordering.\n10. Describe the relative merits of optimistic versus conservative concurrency control under different\nrates of contention among updates.\n11. Give an example of a scenario in which an attempted optimistic update may never complete.\n12. Modify a concurrent system to use a more scalable, reliable, or available data store.\n13. Using an existing platform supporting replicated data stores, write a program that maintains a key-\nvalue mapping even when one or more hosts fail."
    }
  },
  {
    "title": "PDC-Coordination: Coordination",
    "CS Core": "1. Dependencies\na. Initiation or progress of one activity may be dependent on other activities, so as to avoid\nrace conditions, ensure termination, or meet other requirements\nb. Ensuring progress by avoiding dependency cycles, using monotonic conditions, removing\ninessential dependencies\n2. Control constructs and design patterns\na. Completion-based: Barriers, joins, including termination control\nb. Data-enabled: Queues, producer-consumer designs\nc. Condition-based: Polling, retrying, backoffs, helping, suspension, signaling, timeouts\nd. Reactive: Enabling and triggering continuations\n3. Atomicity\na. Atomic instructions, enforced local access orderings\nb. Locks and mutual exclusion; lock granularity\nc. Using locks in a specific language; maintaining liveness without introducing races\n222\nd. Deadlock avoidance: Ordering, coarsening, randomized retries; backoffs, encapsulation via\nlock managers\ne. Common errors: Failing to lock or unlock when necessary, holding locks while invoking\nunknown operations\nf. Avoiding locks: replication, read-only, ownership, and non-blocking constructions",
    "KA Core": "4. One or more of the following properties and extensions\na. Progress properties including lock-free, wait-free, fairness, priority scheduling, interactions\nwith consistency, reliability\nb. Performance with respect to contention, granularity, convoying, scaling\nc. Non-blocking data structures and algorithms\nd. Ownership and resource control\ne. Lock variants and alternatives: sequence locks, read-write locks; Read-Copy-Update (RCU),\nreentrancy; tickets; controlling spinning versus blocking\nf. Transaction-based control: Optimistic and conservative\ng. Distributed locking: reliability\nh. Alternatives to barriers: Clocks; counters, virtual clocks; dataflow and continuations; futures\nand RPC; consensus-based, gathering results with reducers and collectors\ni. Speculation, selection, cancellation; observability and security consequences\nj. Resource control using semaphores and condition variables\nk. Control flow: Scheduling computations, series-parallel loops with (possibly elected) leaders,\npipelines and streams, nested parallelism\nl. Exceptions and failures. Handlers, detection, timeouts, fault tolerance, voting",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Show how to avoid or repair a race error in a given program.\n2. Show how to ensure that a program correctly terminates when all of a set of concurrent tasks\nhave completed.",
      "KA Core": "3. Write a function that efficiently counts events such as sensor inputs or networking packet\nreceptions.\n4. Write a filter/map/reduce program in multiple styles.\n5. Write a program in which the termination of one set of parallel actions is followed by another.\n6. Write a program that speculatively searches for a solution by multiple activities, terminating\nothers when one is found.\n7. Write a program in which a numerical exception (such as divide by zero) in one activity causes\ntermination of others.\n8. Write a program for multiple parties to agree upon the current time of day; discuss its limitations\ncompared to protocols such as network transfer protocol (NTP).\n9. Write a service that creates a thread (or other procedural form of activation) to return a\nrequested web page to each new client.\n223"
    }
  },
  {
    "title": "PDC-Evaluation: Evaluation",
    "CS Core": "1. Safety and liveness requirements in terms of temporal logic constructs to express “always” and\n“eventually” (See also: FPL-Parallel)\n2. Identifying, testing for, and repairing violations, including common forms of errors such as failure to\nensure necessary ordering (race errors), atomicity (including check-then-act errors), and\ntermination (livelock)\n3. Performance requirements metrics for throughput, responsiveness, latency, availability, energy\nconsumption, scalability, resource usage, communication costs, waiting and rate control, fairness;\nservice level agreements (See also: SF-Performance)\n4. Performance impact of design and implementation choices, including granularity, overhead,\nconsensus costs, and energy consumption (See also: SEP-Sustainability)\n5. Estimating scalability limitations, for example using Amdahl’s Law or Universal Scalability Law (See\nalso: SF-Evaluation)",
    "KA Core": "6. One or more of the following methods and tools:\na. Extensions to formal sequential requirements such as linearizability\nb. Protocol, session, and transactional specifications\nc. Use of tools such as Unified Modelling Language (UML), Temporal Logic of Actions (TLA),\nprogram logics\nd. Security analysis: safety and liveness in the presence of hostile or buggy behaviors by other\nparties; required properties of communication mechanisms (for example lack of cross-layer\nleakage), input screening, rate limiting (See also: SEC-Foundations)\ne. Static analysis applied to correctness, throughput, latency, resources, energy (See also:\nSEP-Sustainability)\nf. Directed Acyclic Graph (DAG) model analysis of algorithmic efficiency (work, span, critical\npaths)\ng. Testing and debugging; tools such as race detectors, fuzzers, lock dependency checkers,\nunit/stress/torture tests, visualizations, continuous integration, continuous deployment, and\ntest generators\nh. Measuring and comparing throughput, overhead, waiting, contention, communication, data\nmovement, locality, resource usage, behavior in the presence of excessive numbers of\nevents, clients, or threads (See also: SF-Evaluation)\ni. Application domain specific analyses and evaluation techniques",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Revise a specification to enable parallelism and distribution without violating other essential\nproperties or features.\n2. Explain how concurrent notions of safety and liveness extend their sequential counterparts.\n3. Specify a set of invariants that must hold at each bulk-parallel step of a computation.\n224\n4. Write a test program that can reveal a data race error; for example, missing an update when two\nactivities both try to increment a variable.\n5. In a given context, explain the extent to which introducing parallelism in an otherwise sequential\nprogram would be expected to improve throughput and/or reduce latency, and how it may impact\nenergy efficiency.\n6. Show how scaling and efficiency change for sample problems without and with the assumption of\nproblem size changing with the number of processors; further explain whether and how scalability\nwould change under relaxations of sequential dependencies.",
      "KA Core": "7. Specify and measure behavior when a service is requested by unexpectedly many clients.\n8. Identify and repair a performance problem due to sequential bottlenecks.\n9. Empirically compare throughput of two implementations of a common design (perhaps using an\nexisting test harness framework).\n10. Identify and repair a performance problem due to communication or data latency.\n11. Identify and repair a performance problem due to communication or data latency.\n12. Identify and repair a performance problem due to resource management overhead.\n13. Identify and repair a reliability or availability problem."
    }
  },
  {
    "title": "PDC-Algorithms: Algorithms",
    "CS Core": "1. Expressing and implementing algorithms in given languages and frameworks, to initiate activities\n(for example threads), use shared memory constructs, and channel, socket, and/or remote\nprocedure call APIs. (See also: FPL-Parallel).\na. Data parallel examples including map/reduce.\nb. Using channel, socket, and/or RPC APIs in a given language, with program control for\nsending (usually procedural) vs receiving. (usually reactive or RPC-based).\nc. Using locks, barriers, and/or synchronizers to maintain liveness without introducing races.\n2. Survey of common application domains across multicore, reactive, data parallel, cluster, cloud,\nopen distributed systems, and frameworks (with reference to the following table).\nCategory Typical Typical Typical Typical\nExecution agents Communication Algorithmic Engineering\nmechanisms domains goals\nMulticore Threads Shared memory, Resource Throughput,\nAtomics, locks management, latency,\ndata processing energy\nReactive Handlers, threads I/O Channels Services, real- Latency\ntime\nData parallel GPU, SIMD, Heterogeneous Linear algebra, Throughput,\n225\naccelerators, memory graphics, data energy\nhybrid analysis\nCluster Managed hosts Sockets, channels Simulation, data Throughput\nanalysis\nCloud Provisioned hosts Service APIs Web Scalability\napplications\nOpen Autonomous hosts Sockets, Data Fault tolerant Reliability\ndistributed stores data stores and\nservices",
    "KA Core": "3. One of more of the following algorithmic domains. (See also: AL-Strategies):\na. Linear algebra: Vector and matrix operations, numerical precision/stability, applications in\ndata analytics and machine learning.\nb. Data processing: sorting, searching and retrieval, concurrent data structures.\nc. Graphs, search, and combinatorics: Marking, edge-parallelization, bounding, speculation,\nnetwork-based analytics.\nd. Modeling and simulation: differential equations; randomization, N-body problems, genetic\nalgorithms.\ne. Computational logic: satisfiability (SAT), concurrent logic programming.\nf. Graphics and computational geometry: Transforms, rendering, ray-tracing.\ng. Resource management: Allocating, placing, recycling and scheduling processors, memory,\nchannels, and hosts; exclusive vs shared resources; static, dynamic and elastic algorithms;\nReal-time constraints; Batching, prioritization, partitioning; decentralization via work-stealing\nand related techniques.\nh. Services: Implementing web APIs, electronic currency, transaction systems, multiplayer\ngames.",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Implement a parallel/distributed component based on a known algorithm.\n2. Write a data-parallel program that for example computes the average of an array of numbers.\n3. Write a producer-consumer program in which one component generates numbers, and another\ncomputes their average. Measure speedups when the numbers are small scalars versus large\nmulti-precision values.\n4. Extend an event-driven sequential program by establishing a new activity in an event handler (for\nexample a new thread in a GUI action handler).\n5. Improve the performance of a sequential component by introducing parallelism and/or distribution.\n6. Choose among different parallel/distributed designs for components of a given system.",
      "KA Core": "226\n7. Design, implement, analyze, and evaluate a component or application for X operating in a given\ncontext, where X is in one of the listed domains, for example, a genetic algorithm for factory floor\ndesign.\n8. Critique the design and implementation of an existing component or application, or one developed\nby classmates.\n9. Compare the performance and energy efficiency of multiple implementations of a similar design, for\nexample, multicore versus clustered versus GPU.\nProfessional Dispositions\n● Meticulous: Students’ attention to detail is essential when applying constructs with non-obvious\ncorrectness conditions.\n● Persistent: Students must be prepared to try alternative approaches when solutions are not self-\nevident.\nMathematics Requirements\nRequired:\n● MSF-Discrete – Logic, discrete structures including directed graphs.\nDesired:\n● MSF-Linear\n● MSF-Calculus – Differential equations\nCourse Packaging Suggestions\nThe CS Core requirements need not be provided by a single course. They may be included across\ncourses primarily devoted to software development, programming languages, systems, data\nmanagement, networking, computer architecture, and/or algorithms.\nAlternatively, the CS Core provides a basis for courses focusing on parallel and/or distributed\ncomputing. At one extreme, it is possible to offer a single broadly constructed course covering all PDC\nKA Core topics to varying depths. At the other extreme, it is possible to infuse PDC KA Core coverage\nacross the curriculum with courses that cover parallel and distributed approaches alongside sequential\nones for nearly every topic in computing. More conventional choices include courses that focus on one\nor a few categories (such as multicore or cluster), and algorithmic domains (such as linear algebra, or\nresource management). Such courses may go into further depth than listed in one or more KUs, and\ninclude additional software development experience, but include only CS-Core-level coverage of other\ntopics.\nAs an example, a course mainly focusing on multicores could extend CS Core topics as follows.\n1. Programs: KA Core on threads, tasks, instruction-level parallelism.\n2. Communication: KA Core on multicore architectures, memory, concurrent data stores.\n227\n3. Coordination: KA Core on blocking and non-blocking synchronization, speculation, cancellation,\nfutures, and divide-and-conquer data parallelism.\n4. Evaluation: KA Core on performance analysis.\n5. Algorithms: project-based KA Core coverage of data processing and resource management.\nMore extensive examples and guidance for courses focusing on HPC are provided by the NSF/IEEE-\nTCPP Curriculum Initiative on Parallel and Distributed Computing [1].\nCommittee\nChair: Doug Lea, State University of New York at Oswego, Oswego, NY, USA\nMembers:\n● Sherif Aly, American University of Cairo, Cairo, Egypt\n● Michael Oudshoorn, High Point University, High Point, NC, USA\n● Qiao Xiang, Xiamen University, Xiamen, China\n● Dan Grossman, University of Washington, Seattle, WA, USA\n● Sebastian Burckhardt, Microsoft Research, Redmond WA, USA\n● Vivek Sarkar, Georgia Tech, Atlanta, GA, USA\n● Maurice Herlihy, Brown University, Providence, RI, USA\n● Sheikh Ghafoor, Tennessee Tech, Cookeville, TN, USA\n● Chip Weems, University of Massachusetts, Amherst, MA, USA\nContributors:\n● Paul McKenney, Meta, Beaverton, OR, USA\n● Peter Buhr, University of Waterloo, Waterloo, Ontario, Canada\nReferences\n1. Prasad, S. K., Estrada, T., Ghafoor, S., Gupta, A., Kant, K., Stunkel, C., Sussman, A.,\nVaidyanathan, R., Weems, C., Agrawal, K., Barnas, M., Brown, D. W., Bryant, R., Bunde, D. P.,\nBusch, C., Deb, D., Freudenthal, E., Jaja, J., Parashar, M., Phillips, C., Robey, B., Rosenberg, A.,\nSaule, E., Shen, C. 2020. NSF/IEEE-TCPP Curriculum Initiative on Parallel and Distributed\nComputing - Core Topics for Undergraduates, Version II-beta,\nOnline: http://tcpp.cs.gsu.edu/curriculum/, 53 pages. Accessed March 2024.\n228\nSoftware Development Fundamentals (SDF)\nPreamble\nFluency in the process of software development is fundamental to the study of computer science. To\nuse computers to solve problems most effectively, students must be competent at reading and writing\nprograms. Beyond programming skills, however, they must be able to select and use appropriate data\nstructures and algorithms and use modern development and testing tools.\nThe SDF knowledge area brings together fundamental concepts and skills related to software\ndevelopment, focusing on concepts and skills that should be taught early in a computer science\nprogram, typically in the first year. This includes fundamental programming concepts and their effective\nuse in writing programs, use of fundamental data structures which may be provided by the\nprogramming language, basics of programming practices for writing good quality programs, reading,\nand understanding programs, and some understanding of the impact of algorithms on the performance\nof the programs. The 43 hours of material in this knowledge area may be augmented with core material\nfrom other knowledge areas as students progress to mid- and upper-level courses.\nThis knowledge area assumes a contemporary programming language with built-in support for common\ndata types including associative data types like dictionaries/maps as the vehicle for introducing\nstudents to programming (e.g., Python, Java). However, this is not to discourage the use of older or\nlower-level languages for SDF — the knowledge units below can be suitably adapted for the actual\nlanguage used.\nThe emergence of generative AI and Large Language Models (LLMs), which can generate programs\nfor many programming tasks, will undoubtedly affect the programming profession and consequently the\nteaching of many CS topics. However, to be able to effectively use generative AI in programming tasks,\na programmer must have a good understanding of programs, and hence must still learn the foundations\nof programming and develop basic programming skills - which is the aim of SDF. Consequently, we feel\nthat the desired outcomes for SDF should remain the same, though different instructors may now give\nmore emphasis to program understanding, documenting, specifications, analysis, and testing. (This is\nlike teaching students multiplication, addition, etc. even though calculators can be used to do them).\nChanges since CS 2013\nThe main change from 2013 is a stronger emphasis on developing fundamental programming skills and\neffective use of in-built data structures (which many contemporary languages provide) for problem\nsolving.\nOverview\nThis Knowledge Area has five knowledge units which follow.\n1. SDF-Fundamentals: Fundamental Programming Concepts and Practices – This knowledge unit\naims to develop an understanding of basic concepts, and the ability to fluently use basic language\n229\nconstructs as well as modularity constructs. It also aims to familiarize students with the concept of\ncommon libraries and frameworks, including those to facilitate API-based access to resources.\n2. SDF-Data-Structures: Fundamental Data Structures – This knowledge unit aims to develop core\nconcepts relating to Data Structures and associated operations. Students should understand the\nimportant data structures available in the programming language or as libraries, and how to use\nthem effectively, including choosing appropriate data structures while designing solutions for a\ngiven problem.\n3. SDF-Algorithms: Algorithms – This knowledge unit aims to develop the foundations of algorithms\nand their analysis. The KU should also empower students in selecting suitable algorithms for\nbuilding modest-complexity applications.\n4. SDF-Practices: Software Development Practices – This knowledge unit develops the core\nconcepts relating to modern software development practices. It aims to develop student\nunderstanding and basic competencies in program testing, enhancing the readability of programs,\nand using modern methods and tools including some general-purpose IDE.\n5. SDF-SEP: Society, Ethics, and the Profession – This knowledge unit aims to develop an initial\nunderstanding of some of the ethical issues related to programming, professional values\nprogrammers need to have, and the responsibility to society that programmers have. This\nknowledge unit is a part of the SEP Knowledge Area.\nCore Hours\nKnowledge Unit CS Core KA Core\nFundamental Programming Concepts 20\nand Practices\nFundamental Data Structures 6 + 6 (AL)\nAlgorithms 3 + 3 (AL)\nSoftware Development Practices 5\nSociety, Ethics and the Profession Included in SEP hours\nTotal 43\nNote: The CS Core hours include 9 hours shared with AL, but counted here.\nKnowledge Units"
    }
  },
  {
    "title": "SDF-Fundamentals: Fundamental Programming Concepts and Practices",
    "CS Core": "1. Basic concepts such as variables, primitive data types, expressions, and their evaluation\n230\n2. How imperative programs work: state and state transitions on execution of statements, flow of\ncontrol\n3. Basic constructs such as assignment statements, conditional and iterative statements, basic I/O\n4. Key modularity constructs such as functions (and methods and classes, if supported in the\nlanguage) and related concepts like parameter passing, scope, abstraction, data encapsulation\n(See also: FPL-OOP)\n5. Input and output using files and APIs\n6. Structured data types available in the chosen programming language like sequences (e.g., arrays,\nlists), associative containers (e.g., dictionaries, maps), others (e.g., sets, tuples) and when and how\nto use them (See also: AL-Foundational)\n7. Libraries and frameworks provided by the language (when/where applicable)\n8. Recursion\n9. Dealing with runtime errors in programs (e.g., exception handling).\n10. Basic concepts of programming errors, testing, and debugging (See also: SE-Construction, SEC-\nCoding)\n11. Documenting/commenting code at the program and module level.(See also: SE-Construction)\n12. Develop a security mindset. (See also: SEC-Foundations)",
    "Illustrative Learning Outcomes": {
      "CS Core": "In these learning outcomes, the term \"develop\" means \"design, write, test, and debug.\"\n1. Develop programs that use the fundamental programming constructs: assignment and expressions,\nbasic I/O, conditional and iterative statements.\n2. Develop programs using functions with parameter passing.\n3. Develop programs that effectively use the different structured data types provided in the language\nlike arrays/lists, dictionaries, and sets.\n4. Develop programs that use file I/O to provide data persistence across multiple executions.\n5. Develop programs that use language-provided libraries and frameworks (where applicable).\n6. Develop programs that use APIs to access or update data (e.g., from the web).\n7. Develop programs that create simple classes and instantiate objects of those classes (if supported\nby the language).\n8. Explain the concept of recursion and identify when and how to use it effectively.\n9. Develop recursive functions.\n10. Develop programs that can handle runtime errors.\n11. Read a given program and explain what it does.\n12. Write comments for a program or a module specifying what it does.\n13. Trace the flow of control during the execution of a program.\n14. Use appropriate terminology to identify elements of a program (e.g., identifier, operator, operand)."
    }
  },
  {
    "title": "SDF-Data-Structures: Fundamental Data Structures",
    "CS Core: (See also: AL-Foundational)": "1. Standard abstract data types such as lists, stacks, queues, sets, and maps/dictionaries, including\noperations on them.\n231\n2. Selecting and using appropriate data structures.\n3. Performance implications of choice of data structure(s).\n4. Strings and string processing.",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Write programs that use each of the key abstract data types provided in the language (e.g., arrays,\ntuples/records/structs, lists, stacks, queues, and associative data types like sets,\ndictionaries/maps).\n2. Select the appropriate data structure for a given problem.\n3. Explain how the performance of a program may change when using different data structures or\noperations.\n4. Write programs that work with text by using string processing capabilities provided by the language."
    }
  },
  {
    "title": "SDF-Algorithms: Algorithms",
    "CS Core: (See also: AL-Foundational, AL-Complexity)": "1. Concept of algorithm and notion of algorithm efficiency\n2. Some common algorithms (e.g., sorting, searching, tree traversal, graph traversal)\n3. Impact of algorithms on time-space efficiency of programs",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Explain the role of algorithms for writing programs.\n2. Demonstrate how a problem may be solved by different algorithms, each with different properties.\n3. Explain some common algorithms (e.g., sorting, searching, tree traversal, graph traversal).\n4. Explain the impact on space/time performance of some algorithms."
    }
  },
  {
    "title": "SDF-Practices: Software Development Practices",
    "CS Core: (See also: SE-Construction)": "1. Basic testing, including test case design\n2. Use of a general-purpose IDE, including its debugger\n3. Programming style that improves readability\n4. Specifying functionality of a module in a natural language.",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Develop tests for modules and apply a variety of strategies to design test cases.\n2. Explain some limitations of testing programs.\n3. Build, execute, and debug programs using a modern IDE and associated tools such as visual\ndebuggers.\n232\n4. Apply basic programming style guidelines to aid readability of programs such as comments,\nindentation, proper naming of variables, etc.\n5. Write specifications of a module as module comment describing its functionality."
    }
  },
  {
    "title": "SDF-SEP: Society, Ethics, and the Profession",
    "CS Core": "1. Intellectual property rights of programmers for programs they develop.\n2. Plagiarism and academic integrity.\n3. Responsibility and liability of programmers regarding code they develop for solutions. (See also:\nSEC-Foundations)\n4. Basic professional work ethics of programmers.",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Explain/understand some of the intellectual property issues relating to programs.\n2. Explain/understand when code developed by others can be used and proper ways of disclosing\ntheir use.\n3. Explain/understand the responsibility of programmers when developing code for an overall solution\n(which may be developed by a team).\n4. Explain/understand one or more codes of conduct applicable to programmers.\nProfessional Dispositions\n● Self-Directed: Students must seek out solutions to issues on their own (e.g., using technical\nforums, FAQs, discussions). Resolving issues is an important part of becoming proficient in\nprogramming.\n● Experimental: Students must experiment with language features to understand them and to quickly\nprototype solutions. This helps in learning about programming language features.\n● Technical curiosity: Students must develop interest in understanding how programs are executed,\nhow programs and data are stored in memory, etc. This will help build better mental models of the\nunderlying execution system on which programs run.\n● Adaptable: Students must be willing to learn and use different tools and technologies that facilitate\nsoftware development. Tools are commonly used while programming and new tools often emerge –\nusing tools effectively and learning the use of new tools will help.\n● Persistent: Students must continue efforts until, for example, a bug is identified, a program is made\nrobust and handles all situations, etc. This will help as programming requires effort and ability to\npersevere till a program works satisfactorily.\n● Meticulous: Students must pay attention to detail and use orderly processes while programming.\nThe underlying machine is unforgiving and there is no room for even small errors in the programs\nas they can cause major failures.\n233\nMathematics Requirements\nAs SDF focuses on the first year and is foundational, it assumes only basic mathematical knowledge\nthat students acquire in school, in particular Sets, Relations, Functions, and Logic. (See also: MSF-\nDiscrete)\nCourse Packaging Suggestions\nThe SDF KA will generally be covered in introductory courses, often called CS1 and CS2. How much of\nthe SDF KA can be covered in CS1 and how much is to be left for CS2 is likely to depend on the choice\nof programming language for CS1. For languages like Python or Java, CS1 can cover all the\nProgramming Concepts and Development Methods KAs, and some of the Data Structures KA. It is\ndesirable that they be further strengthened in CS2. The topics under algorithms KA and some topics\nunder data structures KA can be covered in CS2. In case CS1 uses a language with fewer in-built data\nstructures, then much of the Data Structures KA and some aspects of the programming KA may also\nneed to be covered in CS2. With the former approach, the introductory course in programming can\ninclude the following:\n1. SDF-Fundamentals (20 hours)\n2. SDF-Data-Structures (12 hours)\n3. SDF-Algorithms (6 hours)\n4. SDF-Practices (5 hours)\n5. SDF-SEP\nPrerequisites: High school mathematics, specifically Sets, Relations, Functions, and Logic. (See also:\nMSF-Discrete)\nCourse objectives: At the end of the course, students should be able to:\n● Design, code, test, and debug a modest sized program that effectively uses functional\nabstraction.\n● Select and use the appropriate language-provided data structure for a given problem (like\narrays, tuples/records/structs, lists, stacks, queues, and associative data types like sets,\ndictionaries/maps.)\n● Design, code, test, and debug a modest-sized object-oriented program using classes and\nobjects.\n● Design, code, test, and debug a modest-sized program that uses language provided libraries\nand frameworks (including accessing data from the web through APIs).\n● Read and explain given code including tracing the flow of control during execution.\n● Write specifications of a program or a module in natural language explaining what it does.\n● Build, execute and debug programs using a modern IDE and associated tools such as visual\ndebuggers.\n● Explain the key concepts relating to programming like parameter passing, recursion, runtime\nexceptions and exception handling.\n234\nCommittee\nChair: Pankaj Jalote, Chair, IIIT-Delhi, Delhi, India\nMembers:\n● Brett A. Becker, University College Dublin, Dublin, Ireland\n● Titus Winters, Google, New York City, NY, USA\n● Andrew Luxton-Reilly, University of Auckland, Auckland, New Zealand\n● Christian Servin, El Paso Community College, El Paso, TX, USA\n● Karen Reid, University of Toronto, Toronto, Canada\n● Adrienne Decker, University at Buffalo, Buffalo, NY, USA\n235\n236\nSoftware Engineering (SE)\nPreamble\nAs far back as the early 1970s, British computer scientist Brian Randell allegedly said, “Software\nengineering is the multi-person construction of multi-version programs.” This is an essential insight:\nwhile programming is the skill that governs our ability to write a program, software engineering is\ndistinct in two dimensions: time and people.\nFirst, a software engineering project is a team endeavor; being a solitary programming expert is\ninsufficient. Skilled software engineers must demonstrate expertise in communication and collaboration.\nProgramming may be an individual activity, but software engineering is a collaborative one, deeply tied\nto issues of professionalism, teamwork, and communication.\nSecond, a software engineering project is usually “multi-version.” It has an expected lifespan; it needs\nto function properly for months, years, or decades. Features may be added or removed to meet product\nrequirements. The engineering team itself will likely change. The technological context will shift, as our\ncomputing platforms evolve, programming languages change, dependencies upgrade, etc. This\nexposure to matters of time and change is novel when compared to a programming project: it isn’t\nenough to build a thing that works, instead it must work and stay working. Many of the most challenging\ntopics in tech share “time will lead to change” as a root cause: backward compatibility, version skew,\ndependency management, schema changes, protocol evolution.\nSoftware engineering presents a particularly difficult challenge for learning in an academic setting.\nGiven that the major differences between programming and software engineering are time and\nteamwork, it is hard to generate lessons that require successful teamwork and that faithfully present the\nchallenges of time. Additionally, some topics in software engineering will be more authentic and more\nrelevant if our learners experience collaborative and long-term software engineering projects in vivo\nrather than in the classroom. Regardless of whether that happens as an internship, involvement in an\nopen-source project, or full-time engineering role, a month of full-time hands-on experience has more\navailable hours than the average software engineering course.\nThus, a software engineering curriculum must focus on concepts needed by most new-graduate hires,\nand that either are novel for those who are trained primarily as programmers, or that are abstract\nconcepts that may not get explicitly stated/shared on the job. Such topics include, but are not limited to:\n● Testing\n● Teamwork, collaboration\n● Communication\n● Design\n● Maintenance and evolution\n● Software engineering tools\nSome such material is reasonably suited to a standard lecture or lecture + lab course. Discussing\ntheoretical underpinnings of version control systems, or branching strategies in such systems, can be\nan effective way to familiarize students with those ideas. Similarly, a theoretical discussion can highlight\n237\nthe difference between static and dynamic analysis tools or may motivate discussion of diamond\ndependency problems in dependency networks.\nOn the other hand, many of the fundamental topics of software engineering are best experienced in a\nhands-on fashion. Historically, project-oriented courses have been a common vehicle for such learning.\nWe believe that such experience is valuable but also bears some interesting risks: students may form\nerroneous notions about the difficulty/complexity of collaboration if their only exposure is a single\nproject with teams formed of other novice software engineers. It falls to instructors to decide on the right\nbalance between theoretical material and hands-on projects – neither is a perfect vehicle for this\nchallenging material. We strongly encourage instructors of project courses to aim for iteration and fast\nfeedback – a few simple tasks repeated, as in an Agile-structured project, is better than singular high-\nfriction introductions to many types of tasks. Projects with real-world industry partners and clients are\nalso especially encouraged. If long-running project courses are not an option, anything that can expose\nlearners to the collaborative and long-term aspects of software engineering is valuable – adding\nfeatures to an existing codebase, collaborating on distinct parts of a larger whole, pairing up to write an\nencoder and decoder, etc.\nAll evidence suggests that the role of software in our society will continue to grow for the foreseeable\nfuture. Additionally, the era of “two programmers in a garage” seems to have drawn to a close. Most\nimportant software these days is a team effort, building on existing code and leveraging existing\nfunctionality. The study of software engineering skills is a deeply important counterpoint to the everyday\nexperience of computing students – we must impress on them the reality that few software projects are\nmanaged by writing from scratch as a solo endeavor. Communication, teamwork, planning, testing, and\ntooling are far more important as our students move on from the classroom and make their mark on the\nwider world.\nAlthough most CS graduates will go on to an industry position that requires this material, the CS Core\ntopics presented here are of value regardless of whether graduates go on to industry or academia.\nChanges since CS 2013\nThis document shifts the focus of the Software Engineering knowledge area in a few ways compared to\nthe goals of CS2013. The common reason behind most of these changes is to focus on material that\nlearners would not pick up elsewhere in the curriculum, and that will be relevant immediately upon\ngraduation, rather than at some future point in their careers.\n● More explicit focus on the software workflow (version control, testing, code review, tooling).\n● Less focus on team leadership and project management.\n● More focus on team participation, communication, and collaboration.\nOverview\n1. SE-Teamwork: Because of the nature of learning programming, most students in introductory SE\nhave little or no exposure to the collaborative nature of SE. Practice (for instance in project work)\nmay help, but lecture and discussion time spent on the value of clear, effective, and efficient\ncommunication and collaboration is essential for Software Engineering.\n238\n2. SE-Tools: Industry reliance on SE tools has exploded in the past generation, with version control\nbecoming ubiquitous, testing frameworks growing in popularity, increased reliance on static and\ndynamic analysis in practice, and the near-ubiquitous use of continuous integration systems.\nIncreasingly powerful IDEs provide code searching and indexing capabilities, as well as small scale\nrefactoring tools and integration with other SE tools. An understanding of the nature of these tools is\nbroadly valuable - especially version control systems.\n3. SE-Requirements: Knowing how to build something is of little help if we do not know what to build.\nProduct Requirements (aka Requirements Engineering, Product Design, Product Requirements\nsolicitation, Product Requirements Documents, etc.) introduces students to the processes\nsurrounding the specification of the broad requirements governing development of a new product or\nfeature.\n4. SE-Design: While Product Requirements focus on the user-facing functionality of a software\nsystem, Software Design focuses on the engineer-facing design of internal software components.\nThis encompasses large design concerns such as software architecture, as well as small-scale\ndesign choices like API design.\n5. SE-Construction: Software Construction focuses on practices that influence the direct production\nof software: use of tests, test driven development, coding style. More advanced topics extend into\nsecure coding, dependency injection, work prioritization, etc.\n6. SE-Validation: Software Verification and Validation focuses on how to improve the value of testing\n– understand the role of testing, failure modes, and differences between good tests and poor ones.\n7. SE-Refactoring: Refactoring and Code Evolution focuses on refactoring and maintenance\nstrategies, incorporating code health, use of tools, and backwards compatibility considerations.\n8. SE-Reliability: Software Reliability aims to improve understanding of and attention to error cases,\nfailure modes, redundancy, and reasoning about fault tolerance.\n9. SE-Formal: Formal Methods provides mathematically rigorous mechanisms to apply to software,\nfrom specification to verification. (Prerequisites: Substantial dependence on core material from the\nDiscrete Structures area, particularly knowledge units DS/Basic Logic and DS/Proof Techniques.)\nCore Hours\nKnowledge Unit CS Core KA Core\nTeamwork 2 + 3 (SEP) 2\nTools and Environments 1 3 + 1 (SDF)\nProduct Requirements 0 + 3 (SEP) 2\nSoftware Design 1 4 + 2 (DM)\nSoftware Construction 1 + 3 (SDF) 3 + 1 (SDF)\nSoftware Verification and Validation 1 3\n239\nRefactoring and Code Evolution 2\nSoftware Reliability 2\nFormal Methods\nTotal 6 21\nNote: We have specifically highlighted Teamwork and Product Requirements as two knowledge units\nwhere SEP lessons are most directly obvious and applicable. Issues like impact on society, interaction\nwith others, and social power disparities are pervasive in Software Engineering and should be woven\ninto as many practical lessons as possible.\nKnowledge Units"
    }
  },
  {
    "title": "SE-Teamwork: Teamwork",
    "CS Core": "1. Effective communication, including oral and written, as well as formal (email, docs, comments,\npresentations) and informal (team chat, meetings). (See also: SEP-Communication)\n2. Common causes of team conflict, and approaches for conflict resolution.\n3. Cooperative programming:\na. Pair programming or Swarming\nb. Code review\nc. Collaboration through version control\n4. Roles and responsibilities in a software team: (See also: SEP-Professional-Ethics)\na. Advantages of teamwork\nb. Risks and complexity of such collaboration\n5. Team processes – responsibilities for tasks, effort estimation, meeting structure, work schedule\n6. Importance of team diversity and inclusivity. (See also: SEP-Communication)",
    "KA Core": "7. Interfacing with stakeholders, as a team:\na. Management & other non-technical teams\nb. Customers\nc. Users\n8. Risks associated with physical, distributed, hybrid, and virtual teams – including communication,\nperception, structure, points of failure, mitigation, and recovery, etc.",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Follow effective team communication practices.\n2. Articulate the sources of, hazards of, and potential benefits of team conflict – especially focusing on\nthe value of disagreeing about ideas or proposals without insulting people.\n240\n3. Facilitate a conflict-resolution and problem-solving strategy in a team setting.\n4. Collaborate effectively in cooperative development/programming.\n5. Propose and delegate necessary roles and responsibilities in a software development team.\n6. Compose and follow an agenda for a team meeting.\n7. Facilitate through involvement in a team project, the central elements of team building, establishing\nhealthy team culture, and team management including creating and executing a team work plan.\n8. Promote the importance of and benefits that diversity and inclusivity brings to a software\ndevelopment team.",
      "KA Core": "9. Reference, as a team, the importance of, and strategies to interface with stakeholders outside the\nteam on both technical and non-technical levels.\n10. Enumerate the risks associated with physical, distributed, hybrid, and virtual teams and possible\npoints of failure and how to mitigate against and recover/learn from failures."
    }
  },
  {
    "title": "SE-Tools: Tools and Environments",
    "CS Core": "1. Software configuration management and version control: (See also: SDF-Practices)\na. Configuration in version control, reproducible builds/configuration.\nb. Version control branching strategies. Development branches vs release branches. Trunk-based\ndevelopment.\nc. Merging/rebasing strategies, when relevant.",
    "KA Core": "2. Release management.\n3. Testing tools including static and dynamic analysis tools. (See also: SDF-Practices, SEC-Coding)\n4. Software process automation:\na. Build systems – the value of fast, hermetic, reproducible builds, compare/contrast approaches\nto building a project.\nb. Continuous Integration (CI) – the use of automation and automated tests to do preliminary\nvalidation that the current head/trunk revision builds and passes (basic) tests.\nc. Dependency management – updating external/upstream dependencies, package management,\nSemVer.\n5. Design and communication tools (docs, diagrams, common forms of design diagrams like UML).\n6. Tool integration concepts and mechanisms. (See also: SDF-Practices)\n7. Use of modern IDE facilities – debugging, refactoring, searching/indexing, ML-powered code\nassistants, etc. (See also: SDF-Practices)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Describe the difference between centralized and distributed software configuration management.\n2. Describe how version control can be used to help manage software release management.\n3. Identify configuration items and use a source code control tool in a small team-based project.\n241",
      "KA Core": "4. Describe how available static and dynamic test tools can be integrated into the software\ndevelopment environment.\n5. Understand the use of CI systems as a ground-truth for the state of the team’s shared code (build\nand test success).\n6. Describe the issues that are important in selecting a set of tools for the development of a specific\nsoftware system, including tools for requirements tracking, design modeling, implementation, build\nautomation, and testing.\n7. Demonstrate the capability to use software tools in support of the development of a software\nproduct of medium size."
    }
  },
  {
    "title": "SE-Requirements: Product Requirements",
    "KA Core": "1. Describe functional requirements using, for example, use cases or user stories.\na. Using at least one method of documenting and structuring functional requirements.\nb. Understanding how the method supports design and implementation.\nc. Strengths and weaknesses of using a specific approach.\n2. Properties of requirements including consistency, validity, completeness, and feasibility.\n3. Requirements elicitation.\na. Sources of requirements, for example, users, administrators, or support personnel.\nb. Methods of requirement gathering, for example, surveys, interviews, or behavioral analysis.\n4. Non-functional requirements, for example, security, usability, or performance, also called as Quality\nAttributes. (See also: SEP-Sustainability)\n5. Risk identification and management, including ethical considerations surrounding the proposed\nproduct. (See also: SEP-Professional-Ethics)\n6. Communicating and/or formalizing requirement specifications.",
    "Non-core": "7. Prototyping a tool for both eliciting and validating/confirming requirements.\n8. Product evolution: when requirements change, how to understand what effect that has and what\nchanges need to be made.\n9. Effort estimation:\na. Learning techniques for better estimating the effort required to complete a task;\nb. Practicing estimation and comparing it to how long tasks take;\nc. Effort estimation is quite difficult, so students are likely to be way off in many cases, but seeing\nthe process play out with their own work is valuable.",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Compare different methods of eliciting requirements along multiple axes.\n2. Identify differences between two methods of describing functional requirements (e.g., customer\ninterviews, user studies) and the situations where each would be preferred.\n3. Identify which behaviors are required, allowed, or barred from a given set of requirements and a list\nof candidate behaviors.\n242\n4. Collect a set of requirements for a simple software system.\n5. Identify areas of a software system that need to be changed, given a description of the system and\na set of new requirements to be implemented.\n6. Identify the functional and non-functional requirements in a set of requirements.",
      "Non-core": "7. Create a prototype of a software system to validate a set of requirements – building a mock-up,\nMVP, etc.\n8. Estimate the time to complete a set of tasks, then compare estimates to the actual time taken.\n9. Determine an implementation sequence for a set of tasks, adhering to dependencies between\nthem, with a goal to retire risk as early as possible.\n10. Write a requirement specification for a simple software system."
    }
  },
  {
    "title": "SE-Design: Software Design",
    "CS Core": "1. System design principles. (See also: SF-Reliability)\na. Levels of abstraction (e.g., architectural design and detailed design)\nb. Separation of concerns\nc. Information hiding\nd. Coupling and cohesion\n2. Software architecture. (See also: SF-Reliability)\na. Design paradigms\ni. Top-down functional decomposition/layered design\nii. Data-oriented architecture\niii. Object-oriented analysis and design\niv. Event-driven design\nb. Standard architectures (e.g., client-server and microservice architectures including REST\ndiscussions, n-layer, pipes-and-filters, Model View Controller)\nc. Identifying component boundaries and dependencies\n3. Programming in the large vs programming in the small. (See also: SF-Reliability)\n4. Code smells and other indications of code quality, distinct from correctness. (See also: SEC-\nEngineering)",
    "KA Core": "5. API design principles\na. Consistency\ni. Consistent APIs are easier to learn and less error-prone\nii. Consistency is both internal (between different portions of the API) and external (following\ncommon API patterns)\nb. Composability\nc. Documenting contracts\ni. API operations should describe their effect on the system, but not generally their\nimplementation\nii. Preconditions, postconditions, and invariants\n243\nd. Expandability\ne. Error reporting\ni. Errors should be clear, predictable, and actionable\nii. Input that does not match the contract should produce an error\niii. Errors that can be reliably managed without reporting should be managed\n6. Identifying and codifying data invariants and time invariants\n7. Structural and behavioral models of software designs\n8. Data design (See also: DM-Modeling)\na. Data structures\nb. Storage systems\n9. Requirement traceability\na. Understanding which requirements are satisfied by a design\nNon-Core:\n10. Design modeling, for instance with class diagrams, entity relationship diagrams, or sequence\ndiagrams\n11. Measurement and analysis of design quality\n12. Principles of secure design and coding (See also: SEC-Engineering)\na. Principle of least privilege\nb. Principle of fail-safe defaults\nc. Principle of psychological acceptability\n13. Evaluating design tradeoffs (e.g., efficiency vs reliability, security vs usability)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Identify the standard software architecture of a given high-level design.\n2. Select and use an appropriate design paradigm to design a simple software system and explain\nhow system design principles have been applied in this design.\n3. Adapt a flawed system design to better follow principles such as separation of concerns or\ninformation hiding.\n4. Identify the dependencies among a set of software components in an architectural design.",
      "KA Core": "5. Design an API for a single component of a large software system, including identifying and\ndocumenting each operation’s invariants, contract, and error conditions.\n6. Evaluate an API description in terms of consistency, composability, and expandability.\n7. Expand an existing design to include a new piece of functionality.\n8. Design a set of data structures to implement a provided API surface.\n9. Identify which requirements are satisfied by a provided software design.\nNon-Core:\n10. Translate a natural language software design into class diagrams.\n11. Adapt a flawed system design to better follow the principles of least privilege and fail-safe defaults.\n12. Contrast two software designs across different qualities, such as efficiency or usability.\n244"
    }
  },
  {
    "title": "SE-Construction: Software Construction",
    "CS Core": "1. Practical small-scale testing (See also: SDF-Practices)\na. Unit testing\nb. Test-driven development – This is particularly valuable for students psychologically, as it is far\neasier to engage constructively with the challenge of identifying challenging inputs for a given\nAPI (edge cases, corner cases) a priori. If they implement first, the instinct is often to avoid\ntrying to crash their new creation, while a test-first approach gives them the intellectual\nsatisfaction of spotting the problem cases and then watching as more tests pass during the\ndevelopment process.\n2. Documentation (See also: SDF-Practices)\na. Interface documentation – describe interface requirements, potentially including (formal or\ninformal) contracts, pre and post conditions, invariants.\nb. Implementation documentation should focus on tricky and non-obvious pieces of code, whether\nbecause the code is using advanced language features, or the behavior of the code is complex.\n(Do not add comments that re-state common/obvious operations and simple language features.)\ni. Clarify dataflow, computation, etc., focusing on what the code is.\nii. Identify subtle/tricky pieces of code and refactor to be self-explanatory if possible or provide\nappropriate comments to clarify.",
    "KA Core": "3. Coding style (See also: SDF-Practices)\na. Style guides\nb. Commenting\nc. Naming\n4. “Best Practices” for coding: techniques, idioms/patterns, mechanisms for building quality programs\n(See also: SEC-Coding, SDF-Practices)\na. Defensive coding practices\nb. Secure coding practices and principles\nc. Using exception handling mechanisms to make programs more robust, fault-tolerant\n5. Debugging (See also: SDF-Practices)\n6. Logging\n7. Use of libraries and frameworks developed by others (See also: SDF-Practices)\nNon-Core:\n8. Larger-scale testing\na. Test doubles (stubs, mocks, fakes)\nb. Dependency injection\n9. Work sequencing, including dependency identification, milestones, and risk retirement\na. Dependency identification: Identifying the dependencies between different tasks\nb. Milestones: A collection of tasks that serve as a marker of progress when completed. Ideally,\nthe milestone encompasses a useful unit of functionality.\nc. Risk retirement: Identifying what elements of a project are risky and prioritizing completing tasks\nthat address those risks.\n10. Potential security problems in programs (See also: SEC-Coding)\n245\na. Buffer and other types of overflows\nb. Race conditions\nc. Improper initialization, including choice of privileges\nd. Input validation\n11. Documentation (autogenerated)\n12. Development context: “green field” vs existing code base\na. Change impact analysis\nb. Change actualization\n13. Release management\n14. DevOps practices",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Write appropriate unit tests for a small component (several functions, a single type, etc.).\n2. Write appropriate interface and (if needed) implementation comments for a small component.",
      "KA Core": "3. Describe techniques, coding idioms and mechanisms for implementing designs to achieve desired\nproperties such as reliability, efficiency, and robustness.\n4. Write robust code using exception handling mechanisms.\n5. Describe secure coding and defensive coding practices.\n6. Select and use a defined coding standard in a small software project.\n7. Compare and contrast integration strategies including top-down, bottom-up, and sandwich\nintegration.\n8. Describe the process of analyzing and implementing changes to code base developed for a specific\nproject.\n9. Describe the process of analyzing and implementing changes to a large existing code base.\nNon-Core:\n10. Rewrite a simple program to remove common vulnerabilities, such as buffer overflows, integer\noverflows and race conditions.\n11. Write a software component that performs some non-trivial task and is resilient to input and run-\ntime errors."
    }
  },
  {
    "title": "SE-Validation: Software Verification and Validation",
    "CS Core": "1. Verification and validation concepts\na. Verification: Are we building the thing right?\nb. Validation: Did we build the right thing?\n2. Why testing matters: Does the component remain functional as the code evolves?\n3. Testing objectives\na. Usability\nb. Reliability\nc. Conformance to specification\n246\nd. Performance\ne. Security\n4. Test kinds\na. Unit\nb. Integration\nc. Validation\nd. System\n5. Stylistic differences between tests and production code: DAMP vs DRY – more duplication is\nwarranted in test code.",
    "KA Core": "6. Test planning and generation\na. Test case generation, from formal models, specifications, etc.\nb. Test coverage\ni. Test matrices\nii. Code coverage – how much of the code is tested?\niii. Environment coverage – how many hardware architectures, operating systems, browsers,\netc. are tested?\nc. Test data and inputs\n7. Test development\na. Test-driven development\nb. Object oriented testing, mocking, and dependency injection\nc. Opaque-box (previously, black-box) and transparent-box (previously, white-box) testing\ntechniques\nd. Test tooling, including code coverage, static analysis, and fuzzing\n8. Verification and validation in the development cycle\na. Code reviews\nb. Test automation, including automation of tooling\nc. Pre-commit and post-commit testing\nd. Tradeoffs between test coverage and throughput/latency of testing\ne. Defect tracking and prioritization: reproducibility of reported defects\n9. Domain specific verification and validation challenges\na. Performance testing and benchmarking\nb. Asynchrony, parallelism, and concurrency\nc. Safety-critical\nd. Numeric\nNon-Core:\n10. Verification and validation tooling and automation\na. Static analysis\nb. Code coverage\nc. Fuzzing\nd. Dynamic analysis and fault containment (sanitizers, etc.)\ne. Fault logging and fault tracking\n11. Test planning and generation\n247\na. Fault estimation and testing termination including defect seeding\nb. Use of random and pseudo random numbers in testing\n12. Performance testing and benchmarking\na. Throughput and latency\nb. Degradation under load (stress testing, FIFO vs LIFO handling of requests)\nc. Speedup and scaling\ni. Amdahl’s law\nii. Gustafson's law\niii. Soft and weak scaling\nd. Identifying and measuring figures of merits\ne. Common performance bottlenecks\ni. Compute-bound\nii. Memory-bandwidth bound\niii. Latency-bound\nf. Statistical methods and best practices for benchmarking\ni. Estimation of uncertainty\nii. Confidence intervals\ng. Analysis and presentation (graphs, etc.)\nh. Timing techniques\n13. Testing asynchronous, parallel, and concurrent systems\n14. Verification and validation of non-code artifacts (documentation, training materials)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Explain why testing is important.\n2. Distinguish between program validation and verification.\n3. Describe different objectives of testing.\n4. Compare and contrast the different types and levels of testing (regression, unit, integration,\nsystems, and acceptance).",
      "KA Core": "5. Describe techniques for creating a test plan and generating test cases.\n6. Create a test plan for a medium-size code segment which includes a test matrix and generation of\ntest data and inputs.\n7. Implement a test plan for a medium-size code segment.\n8. Identify the fundamental principles of test-driven development methods and explain the role of\nautomated testing in these methods.\n9. Discuss issues involving the testing of object-oriented software.\n10. Describe mocking and dependency injection and their application.\n11. Undertake, as part of a team activity, a code review of a medium-size code segment.\n12. Describe the role that tools can play in the validation of software.\n13. Automate the testing in a small software project.\n14. Explain the roles, pros, and cons of pre-commit and post-commit testing.\n15. Discuss the tradeoffs between test coverage and test throughput/latency and how this can impact\nverification.\n248\n16. Use a defect tracking tool to manage software defects in a small software project.\n17. Discuss the limitations of testing in certain domains.\nNon-Core:\n18. Describe and compare different tools for verification and validation.\n19. Automate the use of different tools in a small software project.\n20. Explain how and when random numbers should be used in testing.\n21. Describe approaches for fault estimation.\n22. Estimate the number of faults in a small software application based on fault density and fault\nseeding.\n23. Describe throughput and latency and provide examples of each.\n24. Explain speedup and the different forms of scaling and how they are computed.\n25. Describe common performance bottlenecks.\n26. Describe statistical methods and best practices for benchmarking software.\n27. Explain techniques for and challenges with measuring time when constructing a benchmark.\n28. Identify the figures of merit, construct and run a benchmark, and statistically analyze and visualize\nthe results for a small software project.\n29. Describe techniques and issues with testing asynchronous, concurrent, and parallel software.\n30. Create a test plan for a medium-size code segment which contains asynchronous, concurrent,\nand/or parallel code, including a test matrix and generation of test data and inputs.\n31. Describe techniques for the verification and validation of non-code artifacts."
    }
  },
  {
    "title": "SE-Refactoring: Refactoring and Code Evolution",
    "KA Core": "1. Hyrum’s Law/The Law of Implicit Interfaces\n2. Backward compatibility\na. Compatibility is not a property of a single entity, it’s a property of a relationship.\nb. Backward compatibility needs to be evaluated in terms of provider + consumer(s) or with a well-\nspecified model of what forms of compatibility a provider aspires to/promises.\n3. Refactoring\na. Standard refactoring patterns (rename, inline, outline, etc.)\nb. Use of refactoring tools in IDE\nc. Application of static-analysis tools (to identify code in need of refactoring, generate changes,\netc.)\nd. Value of refactoring as a remedy for technical debt\n4. Versioning\na. Semantic Versioning (SemVer)\nb. Trunk-based development\nNon-Core:\n5. “Large Scale” Refactoring – techniques when a refactoring change is too large to commit safely\n(large projects), or when it is impossible to synchronize change between provider + all consumers\n(multiple repositories, consumers with private code).\na. Express both old and new APIs so that they can co-exist.\nb. Minimize the size of behavior changes.\n249\nc. Why these techniques are required, (e.g., “API consumers I can see” vs “consumers I can’t\nsee”).",
    "Illustrative Learning Outcomes": "KA-Core:\n1. Identify both explicit and implicit behavior of an interface and identify potential risks from Hyrum’s\nLaw.\n2. Consider inputs from static analysis tools and/or Software Design principles to identify code in need\nof refactoring.\n3. Identify changes that can be broadly considered “backward compatible,” potentially with explicit\nstatements about what usage is or is not supported.\n4. Refactor the implementation of an interface to improve design, clarity, etc. with minimal/zero impact\non existing users.\n5. Evaluate whether a proposed change is sufficiently safe given the versioning methodology in use\nfor a given project.\nNon-Core:\n6. Plan a complex multi-step refactoring to change default behavior of an API safely."
  },
  {
    "title": "SE-Reliability: Software Reliability",
    "KA Core": "1. Concept of reliability as probability of failure or mean time between failures, and faults as cause of\nfailures\n2. Identifying reliability requirements for different kinds of software\n3. Software failures caused by defects/bugs, and so for high reliability the goal is to have minimum\ndefects – by injecting fewer defects (better training, education, planning), and by removing most of\nthe injected defects (testing, code review, etc.)\n4. Software reliability, system reliability and failure behavior\n5. Defect injection and removal cycle, and different approaches for defect removal\n6. Compare the “error budget” approach to reliability with the “error-free” approach and identify\ndomains where each is relevant.\nNon-Core:\n7. Software reliability models\n8. Software fault tolerance techniques and models\na. Contextual differences in fault tolerance (e.g., crashing a flight critical system is strongly\navoided, crashing a data processing system before corrupt data is written to storage is highly\nvaluable)\n9. Software reliability engineering practices – including reviews, testing, practical model checking\n10. Identification of dependent and independent failure domains, and their impact on system reliability\n11. Measurement-based analysis of software reliability – telemetry, monitoring and alerting,\ndashboards, release qualification metrics, etc.\n250",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe how to determine the level of reliability required by a software system.\n2. Explain the problems that exist in achieving very high levels of reliability.\n3. Understand approaches to minimizing faults that can be applied at each stage of the software\nlifecycle.\nNon-Core:\n4. Demonstrate the ability to apply multiple methods to develop reliability estimates for a software\nsystem.\n5. Identify methods that will lead to the realization of a software architecture that achieves a specified\nlevel of reliability.\n6. Identify ways to apply redundancy to achieve fault tolerance.\n7. Identify single-point-of-failure (SPF) dependencies in a system design."
    }
  },
  {
    "title": "SE-Formal: Formal Methods",
    "Illustrative Learning Outcomes": "1. Describe the role formal specification and analysis techniques can play in the development of\ncomplex software and compare their use as validation and verification techniques with testing.\n2. Apply formal specification and analysis techniques to software designs and programs with low\ncomplexity.\n3. Explain the potential benefits and drawbacks of using formal specification languages.\nProfessional Dispositions\n● Collaborative: Software engineering is increasingly described as a “team sport” – successful\nsoftware engineers are able to work with others effectively. Humility, respect, and trust underpin\nthe collaborative relationships that are essential to success in this field.\n251\n● Professional: Software engineering produces technology that has the chance to influence\nliterally billions of people. Awareness of our role in society, strong ethical behavior, and\ncommitment to respectful day-to-day behavior outside of one’s team are essential.\n● Communicative: No single software engineer on a project is likely to know all the project\ndetails. Successful software projects depend on engineers communicating clearly and regularly\nto coordinate effectively.\n● Meticulous: Software engineering requires attention to detail and consistent behavior from\neveryone on the team. Success in this field is clearly influenced by a meticulous approach -\ncomprehensive understanding, proper procedures, and a solid avoidance of cutting corners.\n● Responsible: The collaborative aspects of software engineering also highlight the value of\nbeing responsible. Failing to take responsibility, failing to follow through, and failing to keep\nothers informed are all classic causes of team friction and bad project outcomes.\nMathematics Requirements\nDesirable:\n● Introductory statistics (performance comparisons, evaluating experiments, interpreting survey\nresults, etc.). (See also CS-Core requirements for MSF-Statistics)\nCourse Packaging Suggestions\nAdvanced Course to include at least the following:\n● SE-Teamwork (4 hours)\n● SE-Tools (4 hours)\n● SE-Requirements (2 hours)\n● SE-Design (5 hours)\n● SE-Construction (4 hours)\n● SE-Validation (4 hours)\n● SE-Refactoring (2 hours)\n● SE-Reliability (2 hours)\n● SEP-Professional-Ethics (7 hours)\nPrerequisites:\n● SDF-Fundamentals\nCourse objectives: Students should be able to perform good quality code review for colleagues\n(especially focusing on professional communication and teamwork needs), read and write unit tests,\nuse basic software tools (IDEs, version control, static analysis tools) and perform basic activities\nexpected of a new hire on a software team.\nCommittee\nChair: Titus Winters, Google, New York City, NY, USA\n252\nMembers:\n● Brett A. Becker, University College Dublin, Dublin, Ireland\n● Adam Vartanian, Cord, London, UK\n● Bryce Adelstein Lelbach, NVIDIA, New York City, NY, USA\n● Patrick Servello, CIWRO, Norman, OK, USA\n● Pankaj Jalote, IIIT-Delhi, Delhi, India\n● Christian Servin, El Paso Community College, El Paso, TX, USA\nContributors:\n● Hyrum Wright, Google, Pittsburgh, PA, USA\n● Olivier Giroux, Apple, Cupertino, CA, USA\n● Gennadiy Civil, Google, New York City, NY, USA\n253\n254\nSecurity (SEC)\nPreamble\nComputing supports nearly every facet of modern critical infrastructure: transportation, communication,\nhealthcare, education, energy generation and distribution, to name a few. With rampant attacks on and\nbreaches of this infrastructure, computer science graduates have an important role in designing,\nimplementing, and operating software systems that are robust, safe, and secure.\nThe Security (SEC) knowledge area focuses on developing a security mindset into the overall ethos of\ncomputer science graduates so that security is embedded in all their work products. Computer science\nstudents need to learn about system vulnerabilities and understand threats against computer systems.\nThe Security title choice was intentional to serve as a one-word umbrella term for this knowledge area,\nwhich also includes concepts to support privacy, cryptography, secure systems, secure data, and\nsecure code.\nThe SEC knowledge area relies on shared concepts pervasive in all the other areas of CS2023. It\nidentifies seven crosscutting concepts of cybersecurity: confidentiality, integrity, availability, risk\nassessment, systems thinking, adversarial thinking, and human-centered thinking. The seventh\nconcept, human-centered thinking, is additional to the six crosscutting concepts originally defined in the\nCybersecurity Curricula 2017 (CSEC2017) [1]. This addition reinforces to students that humans are\nalso a link in the overall chain of security, a theme that is also covered in knowledge areas such as\nHCI. Principles of protecting systems (also in the DM, OS, SDF, SE and SF knowledge areas) include\nsecurity-by-design, privacy-by-design, defense-in-depth, and zero-trust.\nAnother concept is the notion of assurance, which is an attestation that security mechanisms need to\ncomply with the security policies that have been defined for data, processes, and systems. Assurance\nis tied in with the concepts of verification and validation in the SE knowledge area. Considerations of\ndata privacy and security are shared with the DM (technical aspects) and SEP knowledge areas.\nThe SEC knowledge area thus sits atop several of the other CS2023 knowledge areas, while including\nadditional concepts that are not present in those knowledge areas. The specific dependence on other\nknowledge areas is stated below, starting with the Core Hours table. CS2023 treats security as a\ncrucial component of the skillset of any CS graduate, and the hours needed for security preparation\ncome from all the other 16 CS2023 knowledge areas.\nChanges since CS2013\nThe Security knowledge area is an updated name for CS2013’s Information Assurance and Security\n(IAS) knowledge area. Since 2013, Information Assurance and Security has been rebranded as\nCybersecurity, which has become a new computing discipline, with its own curricular guidelines (CSEC\n2017) developed by a Joint Task Force of the ACM, IEEE Computer Society, AIS and IFIP in 2017.\nMoreover, since 2013, other curricular recommendations for cybersecurity beyond CS2013 and CSEC\n2017 have been made. In the US, the National Security Agency recognizes institutions as Centers of\n255\nAcademic Excellence (CAE) in Cyber Defense and/or Cyber Operations if their cybersecurity programs\nmeet the respective CAE curriculum requirements. Additionally, the National Initiative for Cybersecurity\nEducation (NICE) of the US National Institute for Standards and Technologies (NIST) has developed\nand revised the Workforce Framework for Cybersecurity (NICE Workforce Framework), which identifies\ncompetencies (knowledge and skills) needed to perform tasks relevant to cybersecurity work roles. The\nEuropean Cybersecurity Skills Framework (ECSF) includes a standard ontology to describe\ncybersecurity tasks and roles, as well as addressing the cybersecurity personnel shortage in EU\nmember countries. Similarities and differences of these cybersecurity guidelines, viewed from the CS\nperspective, also informed the SEC knowledge area.\nBuilding on CS2013’s recognition of the pervasiveness of security in computer science, the CS2023\nSEC knowledge area focuses on ensuring that students develop a security mindset so that they are\nprepared for the continual changes occurring in computing. One useful addition is the knowledge unit\nfor security analysis, design, and engineering to support the concepts of security-by-design and\nprivacy-by-design.\nThe importance of computer science in ensuring the protection of future computing systems and\nsocietal critical infrastructure will continue to grow. Consequently, it is imperative that faculty teaching\ncomputer science incorporate the latest advances in security and privacy approaches to keep their\ncurriculum current.\nDifferences between CS2023 Security knowledge area and Cybersecurity\nCS2023’s SEC knowledge area focuses on those aspects of security, privacy, and related concepts\nimportant for computer science students. In comparison, CSEC 2017 characterizes similarities and\ndifferences in the cybersecurity book of knowledge using the disciplinary lenses of computer science,\ncomputer engineering, software engineering, information systems, information technology, and other\ndisciplines. In short, the major goal of the SEC knowledge area is to ensure that computer science\ngraduates can design and develop more secure code, ensure data security and privacy, and apply a\nsecurity mindset to their daily activities.\nProtecting what happens within the perimeter of a networked computer system is a core competency of\ncomputer science graduates. Although the computer science and cybersecurity knowledge units\noverlap, the demands upon cybersecurity graduates typically are to protect the perimeter. CSEC 2017\ndefines cybersecurity as a highly interdisciplinary field of study that covers eight areas (data, software,\ncomponent, connection, system, human, organizational, and societal security) and prepares its\nstudents for both technical and managerial roles in cybersecurity.\nThe first five CSEC 2017 areas are technical and have overlaps with the CS2023 SEC knowledge area,\nbut the intent of coverage is substantively different as computer science students bring to bear the core\ncompetencies described in all the 17 CS2023 knowledge areas. For instance, consider the SEC\nknowledge area’s Secure Coding knowledge unit. The computer science student will need to view this\nknowledge unit from a computer science lens, as an extension of the material covered in the SDF, SE,\nand PDC knowledge areas, while the Cybersecurity student will need to view software security in the\noverall context of diverse cybersecurity goals. These viewpoints are not totally distinct and have\n256\noverlaps, but thFFe lenses used to examine and present the content are different. There are similar\ncommonalities aii nd differences among CS2023 SEC knowledge units and corresponding CSEC 2017\ngg\nknowledge units.\nuu\nrr\nCore Hours\nee\n..\nDD\nKnowledgaae Unit CS Core KA Core\ntt\nFoundatioaan al Security 1 + 7 (DM, FPL, PDC, SDF, 7\nSS\nSE, OS)\nee\ncc\nSociety, Ethics, and the Profession 1 + 4 (SEP) 2\nuu\nrr\nSecure Coding 2 + 6 (FPL, SDF, SE) 5\nii\ntt\nCryptograyyp hy 1 + 8 (MSF) 4\n––\nSecurity ACCnalysis, Design, and Engineering 1 + 4 (MSF, SE) 8\nyy\nDigital Fobbrensics 0 6\nee\nSecurity Grrovernance 0 3\nss\nee\nTotal hours 6 35\ncc\nuu\nrr\nii\nThe SEC knowledge area requires approximately 28 hours of CS Core hours from the other knowledge\ntt\nareas, either to yyp rovide the basis or to complement its content. Of these, MSF-Discrete, MSF-\nProbability, andvv MSF-Statistics are likely to be relied upon extensively in all the SEC knowledge units,\nas are SDF-Funeedamentals, SDF-Algorithms, and SDF-Practices. The others are mentioned within each\nrr\nof the SEC knowledge units described below.\nss\nuu\nKnowledgess Units\nCC\nSS"
  },
  {
    "title": "SEC-Foundations: Foundational Security",
    "CS Core": "22\n1. Developing a security mindset incorporating crosscutting concepts: confidentiality, integrity,\n33\navailability, SSrisk assessment, systems thinking, adversarial thinking, human-centered thinking\n2. Basic conceEEpts of authentication and authorization/access control\nCC\n3. Vulnerabilities, threats, attack surfaces, and attack vectors (See also: OS-Protection)\n..\n4. Denial of Service (DoS) and Distributed Denial of Service (DDoS) (See also: OS-Protection)\n((\n5. Principles aOOnd practices of protection, e.g., least privilege, open design, fail-safe defaults, defense\nin depth, anttd zero trust; and how they can be implemented (See also: OS-Principles, OS-\nhh\nProtection, SE-Construction, SEP-Security)\nee\nrr\nkk 257\nnn\noo\nww\nll\nee\n6. Optimization considerations between security, privacy, performance, and other design goals (See\nalso: SDF-Practices, SE-Validation, HCI-Design)\n7. Impact of AI on security and privacy: using AI to bolster defenses as well as address increased\nadversarial capabilities due to AI (See also: AI-SEP, HCI-Design, HCI-SEP)",
    "KA Core": "8. Access control models (e.g., discretionary, mandatory, role-based, and attribute-based)\n9. Security controls\n10. Concepts of trust and trustworthiness\n11. Applications of a security mindset: web, cloud, and mobile devices (See also: SF-System Design,\nSPD-Common)\n12. Protecting embedded and cyber-physical systems (See also: SPD-Embedded)\n13. Principles of usable security and human-centered computing (See also: HCI-Design, SEP-Security)\n14. Security and trust in AI/machine learning systems, e.g., fit for purpose, ethical operating\nboundaries, authoritative knowledge sources, verified training data, repeatable system evaluation\ntests, system attestation, independent validation/certification; unintended consequences from:\nadverse effect (See also: AI-Introduction, AI-ML, AI-SEP, SEP-Security)\n15. Security risks in building and operating AI/machine learning systems (e.g., algorithm bias,\nknowledge corpus bias, training corpus bias, copyright violation) (See also: AI-Introduction, AI-ML,\nAI-SEP)\n16. Hardware considerations in security, e.g., principles of secure hardware, secure processor\narchitectures, cryptographic acceleration, compartmentalization, software-hardware interaction (See\nalso: AR-Assembly, AR-Representation, OS-Purpose)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Evaluate a system for possible attacks that can be launched by an adversary.\n2. Design and develop approaches to protect a system from a set of identified threats.",
      "KA Core": "3. Describe how harm to user privacy can be avoided.\n4. Develop a system that incorporates various principles of security and privacy.\n5. Compare the different access control models in terms of functionality and performance.\n6. Show how an adversary could use machine learning algorithms to reduce the security of a system.\n7. Show how a developer could improve the security of a system using machine learning algorithms.\n8. Describe hardware (especially CPU) vulnerabilities that can impact software."
    }
  },
  {
    "title": "SEC-SEP: Society, Ethics, and the Profession",
    "CS Core": "1. Principles and practices of privacy (See also: SEP-Security)\n2. Societal impacts on breakdowns in security and privacy (See also: SEP-Context, SEP-Privacy,\nSEP-Security)\n3. Applicability of laws and regulations on security and privacy (See also: SEP-Security)\n4. Professional ethical considerations when designing secure systems and maintaining privacy; ethical\nhacking (See also: SEP-Professional-Ethics, SEP-Privacy, SEP-Security)\nKA-Core:\n258\n5. Security by design (See also: SF-Security, SF-Design)\n6. Privacy by design and privacy engineering (See also: SEP-Privacy, SEP-Security)\n7. Security and privacy implications of malicious AI/machine learning actors, e.g., identifying deep\nfakes (See also: AI-Introduction, AI-ML, SEP-Privacy, SEP-Security)\n8. Societal impacts of Internet of Things (IoT) devices and other emerging technologies on security\nand privacy (See also: SEP-Privacy, SEP-Security)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Calculate the impact of a breakdown in security of a given system.\n2. Construct a system that conforms to security laws.\n3. Apply a set of privacy regulations to design a system that protects privacy.",
      "KA Core": "4. Evaluate the legal ramifications of a system not corresponding to applicable laws and regulations.\n5. Construct a system that is designed to avoid harm to user privacy."
    }
  },
  {
    "title": "SEC-Coding: Secure Coding",
    "CS Core": "1. Common vulnerabilities and weaknesses\n2. SQL injection and other injection attacks\n3. Cross-site scripting techniques and mitigations\n4. Input validation and data sanitization (See also: OS-Protection, SDF-Fundamentals, SE-Validation)\n5. Type safety and type-safe languages (See also: FPL-Types, FPL-Systems, OS-Protection, SDF-\nFundamentals, SE-Validation)\n6. Buffer overflows, stack smashing, and integer overflows (See also: AR-Assembly, FPL-Systems,\nOS-Protection)\n7. Security issues due to race conditions (See also: FPL-Parallel, PDC-Evaluation)",
    "KA Core": "8. Principles of noninterference and nondeducibility\n9. Preventing information flow attacks\n10. Offensive security techniques as a defense\n11. AI-assisted malware detection techniques\n12. Ransomware: creation, prevention, and mitigation\n13. Secure use of third-party components (See also: SE-Construction, SE-Validation)\n14. Malware: varieties, creation, reverse engineering, and defense against them (See also: FPL-\nSystems, FPL-Translation)\n15. Assurance: testing (including fuzzing and penetration testing), verification, and validation (See also:\nOS-Protection, SDF-Fundamentals, SE-Construction, SE-Validation)\n16. Static and dynamic analyses (See also: FPL-Analysis, MSF-Protection, PDC-Evaluation, SE-\nValidation)\n17. Secure compilers and secure code generation (See also: FPL-Runtime, FPL-Translation)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Identify underlying problems in given examples of an enumeration of common weaknesses and\nexplain how they can be circumvented.\n2. Apply input validation and data sanitization techniques to enhance security of a program.\n3. Describe how the selection of a programming language can impact the security of the system being\nconstructed.\n4. Rewrite a program in a type-safe language (e.g., Java or Rust) originally written in an unsafe\nprogramming language (e.g., C/C++).\n5. Evaluate a program for possible buffer overflow attacks and rewrite to prevent such attacks.\n6. Evaluate a set of related programs for possible race conditions and prevent an adversary from\nexploiting them.\n7. Evaluate and prevent SQL injections attacks on a database application.\n8. Evaluate and prevent cross-site scripting attacks against a website.",
      "KA Core": "9. Describe different kinds of malicious software.\n10. Construct a program that tests for all input handling errors.\n11. Explain the risks of misusing interfaces with third-party code and how to correctly use third-party\ncode.\n12. Discuss the need to update software to fix security vulnerabilities and the lifecycle management of\nthe fix.\n13. Construct a system that is protected from unauthorized information flows.\n14. Apply static and dynamic tools to identify programming faults.\n15. Evaluate a system for the existence of malware and remove it.\n16. Implement preventive techniques to reduce the occurrence of ransomware."
    }
  },
  {
    "title": "SEC-Crypto: Cryptography",
    "CS Core": "1. Differences between algorithmic, applied, and mathematical views of cryptography\n2. Mathematical preliminaries: modular arithmetic, Euclidean algorithm, probabilistic independence,\nlinear algebra basics, number theory, finite fields, complexity, asymptotic analysis (See also: MSF-\nDiscrete, MSF-Linear)\n3. Basic cryptography: symmetric key and public key cryptography (See also: AL-Foundational, MSF-\nDiscrete)\n4. Basic cryptographic building blocks, including symmetric encryption, asymmetric encryption,\nhashing, and message authentication (See also: MSF-Discrete)\n5. Classical cryptosystems, such as shift, substitution, transposition ciphers, code books, and\nmachines (See also: MSF-Discrete)\n6. Kerckhoff’s principle and use of vetted libraries (See also: SE-Construction)\n7. Usage of cryptography in real-world applications, e.g., electronic cash, secure channels between\nclients and servers, secure electronic mail, entity authentication, device pairing, steganography, and\nvoting systems (See also: NC-Security, GIT-Image)",
    "KA Core": "8. Additional mathematics: primality, factoring, and elliptic curve cryptography (See also: MSF-\nDiscrete)\n260\n9. Private-key cryptosystems: substitution-permutation networks, linear cryptanalysis, differential\ncryptanalysis, DES, and AES (See also: MSF-Discrete, NC-Security)\n10. Public-key cryptosystems: Diffie-Hellman and RSA (See also: MSF-Discrete)\n11. Data integrity and authentication: hashing, and digital signatures (See also: MSF-Discrete, DM-\nSecurity)\n12. Cryptographic protocols: challenge-response authentication, zero-knowledge protocols,\ncommitment, oblivious transfer, secure two- or multi-party computation, hash functions, secret\nsharing, and applications (See also: MSF-Discrete)\n13. Attacker capabilities: chosen-message attack (for signatures), birthday attacks, side channel\nattacks, and fault injection attacks (See also: NC-Security)\n14. Quantum cryptography; Post Quantum/Quantum resistant cryptography (See also: AL-\nFoundational, MSF-Discrete)\n15. Blockchain and cryptocurrencies (See also: MSF-Discrete, PDF-Communication)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Explain the role of cryptography in supporting security and privacy.\n2. Discuss the risks of inventing one’s own cryptographic methods.\n3. Discuss the importance of prime numbers in cryptography and explain their use in cryptographic\nalgorithms.\n4. Implement and cryptanalyze classical ciphers.",
      "KA Core": "5. Describe how crypto keys can be managed securely.\n6. Compare the space and time performance of a given set of cryptographic methods.\n7. Discuss how modern private-key cryptosystems work and ways to cryptanalyze them.\n8. Discuss how modern public-key cryptosystems work and ways to cryptanalyze them.\n9. Compare different cryptographic algorithms in terms of security.\n10. Explain key exchange protocols and show approaches to reduce their failure.\n11. Describe real-world applications of cryptographic primitives and protocols.\n12. Discuss how quantum cryptography works and the impact of quantum computing on cryptographic\nalgorithms."
    }
  },
  {
    "title": "SEC-Engineering: Security Analysis, Design, and Engineering",
    "CS Core": "1. Security engineering goals: building systems that remain dependable despite errors, accidents, or\nmalicious adversaries (See also: SE-Construction, SE-Validation, SEP-Security)\n2. Privacy engineering goals: building systems that design, implement, and deploy privacy features\nand controls (See also: SEP-Privacy)\n3. Problem analysis and situational analysis to address system security (See also: SE-Validation)\n4. Engineering tradeoff analysis based on time, cost, risk tolerance, risk acceptance, return on\ninvestment, and so on (See also: PDC-Evaluation, SE-Validation)",
    "KA Core": "261\n5. Security design and engineering, including functional requirements, security subsystems,\ninformation protection, security testing, security assessment, and evaluation (See also: PDC-\nEvaluation, SE-Requirements, SE-Validation)\n6. Security analysis, covering security requirements analysis; security controls analysis; threat\nanalysis; and vulnerability analysis (See also: FPL-Analysis, PDC-Evaluation)\n7. Security attack domains and attack surfaces, e.g., communications and networking, hardware,\nphysical, social engineering, software, and supply chain (See also: NC-Security)\n8. Security attack modes, techniques, and tactics, e.g., authentication abuse; brute force; buffer\nmanipulation; code injection; content insertion; denial of service; eavesdropping; function bypass;\nimpersonation; integrity attack; interception; phishing; protocol analysis; privilege abuse; spoofing;\nand traffic injection (See also: NC-Security, OS-Protection, SE-Validation)\n9. Attestation of software products with respect to their specification and adaptiveness (See also: SE-\nRequirements, SE-Validation)\n10. Design and development of cyber-physical systems\n11. Considerations for trustworthy computing, e.g., tamper resistant packaging, trusted boot, trusted\nkernel, hardware root of trust, software signing and verification, hardware-based cryptography,\nvirtualization, and containers (See also: SE-Construction, SE-Validation)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Create a threat model for a system or system design.\n2. Apply situational analysis to develop secure solutions under a specified scenario.\n3. Evaluate a given scenario for tradeoff analysis for system performance, risk assessment, and costs.",
      "KA Core": "4. Design a set of technical security controls, countermeasures, and information protections to meet\nthe security requirements and security objectives for a system.\n5. Evaluate the effectiveness of security functions, technical controls, and componentry for a system.\n6. Identify and mitigate security vulnerabilities and weaknesses in a system.\n7. Evaluate and predict emergent behavior in areas such as Data Science, AI, and Machine Learning."
    }
  },
  {
    "title": "SEC-Forensics: Digital Forensics",
    "KA Core": "1. Basic principles and methodologies for digital forensics\n2. System design for forensics\n3. Forensics in different situations: operating systems, file systems, application forensics, web\nforensics, network forensics, mobile device forensics, use of database auditing (See also: NC-\nSecurity)\n4. Attacks on forensics and preventing such attacks\n5. Incident handling processes\n6. Rules of evidence – general concepts and differences between jurisdictions (See also: SEP-\nSecurity)\n7. Legal issues: digital evidence protection and management, chains of custody, reporting, serving as\nan expert witness (See also: SEP-Security)\n262",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Explain what a digital investigation is and how it can be implemented (See also: SEP-Security)\n2. Design and implement software to support forensics.\n3. Describe legal requirements for using seized data and its usage. (See also: SEP-Security)\n4. Describe and implement an end-to-end chain of custody from initial digital evidence seizure to\nevidence disposal. (See also: SEP-Privacy, SEP-Security)\n5. Extract data from a hard drive to comply with the law (See also: SEP-Security)\n6. Discuss a person’s professional responsibilities and liabilities when testifying as a forensics expert\n(See also: SEP-Professional-Ethics)\n7. Recover data based on a given search term from an imaged system\n8. Reconstruct data and events from an application history, or a web artifact, or a cloud database, or a\nmobile device. (See also: SPD-Mobile, SPD-Web)\n9. Capture and analyze network traffic. (See also: NC-Security)\n10. Develop approaches to address the challenges associated with mobile device forensics.\n11. Apply forensics tools to investigate security breaches.\n12. Identify and mitigate anti-forensic methods."
    }
  },
  {
    "title": "SEC-Governance: Security Governance",
    "KA Core": "1. Protecting critical assets from threats\n2. Security governance: organizational objectives and general risk assessment\n3. Security management: achieve and maintain appropriate levels of confidentiality, integrity,\navailability, accountability, authenticity, and reliability (See also: SE-Validation)\n4. Security policy: organizational policies, issue-specific policies, system-specific policies\n5. Approaches to identifying and mitigating risks to computing infrastructure\n6. Data lifecycle management policies: data collection, backups, and retention; cloud storage and\nservices; breach disclosure (See also: DM-Security)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe critical assets and how they can be protected.\n2. Differentiate between security governance, management, and controls, giving examples of each.\n3. Describe a technical control and implement it to mitigate specific threats.\n4. Identify and assess risk of programs and database applications causing breaches.\n5. Design and implement appropriate backup strategies conforming to a given policy.\n6. Discuss a breach disclosure policy based on legal requirements and implement the policy.\n7. Identify the risks and benefits of outsourcing to the cloud.\nProfessional Dispositions\n● Meticulous: students need to pay careful attention to details to ensure the protection of real-world\nsoftware systems.\n263\n● Self-directed: students must be ready to deal with the many novel and easily unforeseeable ways\nin which adversaries might launch attacks.\n● Collaborative: students must be ready to collaborate with others, as collective knowledge and skills\nwill be needed to prevent attacks, protect systems and data during attacks, and plan for the future\nafter the immediate attack has been mitigated.\n● Responsible: students need to show responsibility when designing, developing, deploying, and\nmaintaining secure systems, as their enterprise and society is constantly at risk.\n● Accountable: students need to know that as future professionals they will be held accountable if a\nsystem or data breach were to occur, which should strengthen their resolve to prevent such\nbreaches from occurring in the first place.\nMathematics Requirements\nRequired:\n● MSF-Discrete\n● MSF-Probability\n● MSF-Statistics\nDesired:\n● MSF-Linear\nCourse Packaging Suggestions\nThere are two suggestions for course packaging, along with an additional suggestion for a more\nadvanced course.\nThe first suggestion for course packaging is to infuse the CS Core hours of the SEC KA into\nappropriate places in other coursework that covers related security topics in the following knowledge\nunits. As the CS Core Hours of the SEC KA are only 6 hours, coursework covering one or more of the\nfollowing knowledge units could accommodate them.\n● AI-SEP\n● AL-SEP\n● AR-Assembly\n● AR-Memory\n● DM-Security\n● FPL-Translation\n● FPL-Run-Time\n● FPL-Analysis\n● FPL-Types\n● HCI-Design\n● HCI-Accountability\n● HCI-SEP\n264\n● NC-Security\n● OS-Protection\n● PDC-Communication\n● PDC-Coordination\n● PDC-Evaluation\n● SDF-Fundamentals\n● SDF-Practices\n● SE-Validation\n● SEP-Privacy\n● SEP-Security\n● SF-Design\n● SF-Security\n● SPD-Common\n● SPD-Mobile\n● SPD-Web\nThe second approach for course packaging is to create an additional full course focused on security\nthat packages the following, building on the topics already covered in other knowledge areas.\nFundamentals of Computer Security:\n● SEC-Foundations (6 hours)\n● SEC-SEP (4 hours)\n● SEC-Coding (7 hours)\n● SEC-Crypto (5 hours)\n● SEC-Engineering (4 hours)\n● SEC-Forensics (2 hours)\n● SEC-Governance (1 hour)\n● AI-SEP (1 hour)\n● AR-Assembly (1 hour)\n● AR-Memory (1 hour)\n● DM-Security (3 hours)\n● FPL-Translation (1 hour)\n● FPL-Run-Time (1 hour)\n● FPL-Analysis (1 hour)\n● FPL-Types (2 hours)\n● HCI-Design (1 hour)\n● HCI-Accountability (1 hour)\n● HCI-SEP (1 hour)\n● NC-Security (2 hours)\n● OS-Protection (1 hour)\n● PDC-Communication (1 hour)\n● PDC-Coordination (1 hour)\n● PDC-Evaluation (1 hour)\n● SDF-Fundamentals (1 hour)\n265\n● SDF-Practices (1 hour)\n● SE-Validation: (2 hours)\n● SEP-Privacy (1 hour)\n● SEP-Security (2 hours)\n● SF-Design (2 hours)\n● SF-Security (2 hours)\n● SPD-Common (2 hours)\n● SPD-Mobile (2 hours)\n● SPD-Web: Web Platforms (2 hours)\nThe coverage exceeds 45 lecture hours, and so, in a typical course, instructors would need to decide\nwhat topics to emphasize and what not to cover without losing the perspective that the course should\nhelp students develop a security mindset.\nPrerequisites: Depends on the selected topics, but appropriate coursework covering MSF, SDF, and\nSE knowledge areas is needed.\nCourse objectives: Students should develop a security mindset and be ready to apply this mindset to\nsecuring data, software, systems, and applications.\nA third suggested packaging is to create an advanced course that develops a security\narchitect/engineer’s view by including the following:\nSecurity Engineering:\n● SEC-Foundations (6 hours)\n● SEC-SEP (4 hours)\n● SEC-Coding (6 hours)\n● SEC-Crypto (2 hours)\n● SEC-Engineering (10 hours)\n● SEC-Forensics (2 hours)\n● SEC-Governance (1 hour)\n● DM-Security (2 hours)\n● NC-Security (3 hours)\n● OS-Protection (2 hours)\n● PDC-Evaluation (2 hours)\n● SDF-Fundamentals (1 hour)\n● SDF-Practices (1 hour)\n● SE-Validation (2 hours)\n● SEP-Privacy (1 hour)\n● SEP-Security (1 hour)\n● SF-Design (2 hours)\n● SF-Security (2 hours)\n● SPD-Mobile (2 hours)\n● SPD-Web (2 hours)\n266\nThe coverage for all topics is over 45 lecture hours, and so instructors would need to decide what\ntopics to emphasize and what not to cover without losing the perspective that the course should help\nstudents develop the security engineer’s mindset. Laboratory time related to data and network security,\nweb platform, secure coding and validation would be valuable aspects of this course.\nPrerequisites: Depends on the selected topics, either the first or second packaging suggested above\nwould be recommended based on degree program needs.\nCourse objectives: Computer science students should develop the mindset of a security engineer and\nbe ready to apply this mindset to problems in designing and evaluating the security of a range of\ncomputing systems and information services.\nCommittee\nChair: Rajendra K. Raj, Rochester Institute of Technology, Rochester, NY, USA\nMembers:\n● Vijay Anand, University of Missouri – St. Louis, St. Louis, MO, USA\n● Diana Burley, American University, Washington, DC, USA\n● Sherif Hazem, Central Bank of Egypt, Cairo, Egypt\n● Michele Maasberg, United States Naval Academy, Annapolis, MD, USA\n● Bruce McMillin, Missouri University of Science and Technology, Rolla, MO, USA\n● Sumita Mishra, Rochester Institute of Technology, Rochester, NY, USA\n● Nicolas Sklavos, University of Patras, Patras, Greece\n● Blair Taylor, Towson University, Towson, MD, USA\n● Jim Whitmore, Dickinson College, Carlisle, PA, USA\nContributors:\n● Markus Geissler, Cosumnes River College, Sacramento, CA, USA\n● Michael Huang, Rider University, Lawrenceville, NJ, USA\n● Tim Preuss, Minnesota State Community and Technical College, Moorhead, MN, USA\n● Daniel Zappala, Brigham Young University, Provo, UT, USA\nReferences\n1. Joint Task Force on Cybersecurity Education. 2017. Cybersecurity Curricula 2017. ACM, IEEE-CS,\nAIS SIGSEC, and IFIP WG 11.8. https://doi.org/10.1145/3184594\n267\n268\nSociety, Ethics, and the Profession (SEP)\nPreamble\nThe ACM Code of Ethics and Professional Conduct states: “Computing professionals' actions change\nthe world. To act responsibly, they should reflect upon the wider impacts of their work, consistently\nsupporting the public good.” The IEEE Code of Ethics starts by recognizing “the importance of our\ntechnologies in affecting the quality of life throughout the world.” The AAAI Code of Professional Ethics\nand Conduct begins with “Computing professionals, and in particular, AI professionals’ actions change\nthe world. To act responsibly, they should reflect upon the wider impacts of their work, consistently\nsupporting the public good.”\nWhile technical issues dominate the computing curriculum, they do not constitute a complete\neducational program in the broader context. It is more evident today than ever that students must also\nbe exposed to the larger societal context of computing to develop an understanding of the critical and\nrelevant social, ethical, legal, and professional issues and responsibilities at hand. This need to\nincorporate the study of these non-technical issues into the ACM curriculum was formally recognized in\n1991, as articulated in the following excerpt from CS1991 [1].\nUndergraduates also need to understand the basic cultural, social, legal, and ethical issues\ninherent in the discipline of computing. They should understand where the discipline has been,\nwhere it is, and where it is heading. They should also understand their individual roles in this\nprocess, as well as appreciate the philosophical questions, technical problems, and aesthetic\nvalues that play an important part in the development of the discipline.\nStudents also need to develop the ability to ask serious questions about the social impact of\ncomputing and to evaluate proposed answers to those questions. Future practitioners must be\nable to anticipate the impact of introducing a given product into a given environment. Will that\nproduct enhance or degrade the quality of life? What will the impact be upon individuals,\ngroups, and institutions?\nFinally, students need to be aware of the basic legal rights of software and hardware vendors\nand users, and they also need to appreciate the ethical values that are the basis for those\nrights. Future practitioners must understand the responsibility that they will bear, and the\npossible consequences of failure. They must understand their own limitations as well as the\nlimitations of their tools. All practitioners must make a long-term commitment to remaining\ncurrent in their chosen specialties and in the discipline of computing as a whole.\nNonetheless, in recent years myriad high-profile issues affecting society at large have occurred leading\nto the conclusion that computer science professionals are not as prepared as they should be.\nAs technological advances (more specifically, how these advances are used by humans) continue to\nsignificantly impact the way we live and work, the critical importance of social and ethical issues and\nprofessional practice continues to increase in magnitude and consequence. The ways we use\n269\ncomputing products and platforms, while hopefully providing opportunities, also introduce ever more\nchallenging problems. A recent example is the emergence of generative AI, including large language\nmodels that generate code. A 2020 Communications of the ACM article [4] stated: “... because\ncomputing as a discipline is becoming progressively more entangled within the human and social\nlifeworld, computing as an academic discipline must move away from engineering-inspired curricular\nmodels and integrate the analytic lenses supplied by social science theories and methodologies.”\nIn parallel to, and as part of, the heightened awareness of the social consequences computing has on\nthe world, computing communities have become much more aware – and active – in areas of diversity,\nequity, inclusion, and accessibility. These feature in statements and initiatives at ACM [8], IEEE [9], and\nAAAI [10] and in their codes of conduct [1-3]. All students deserve an inclusive, diverse, equitable and\naccessible learning environment. Computing students also have a unique duty to ensure that when put\nto practice, their skills, knowledge, and competencies are applied in ways that work for, and not\nagainst, the principles of diversity, equity, inclusion, and accessibility. These principles are inherently a\npart of computing, and a new knowledge unit “Diversity, Equity, Inclusion and Accessibility” (SEP-DEIA)\nhas been added to this knowledge area.\nComputer science educators may opt to deliver the material in this knowledge area within the contexts\nof traditional technical and theoretical courses, in dedicated courses, and as part of capstone, project,\nand professional practice courses. The material in this knowledge area is best covered through a\ncombination of all the above. It is too commonly held that many topics in this knowledge area may not\nreadily lend themselves to being covered in other more traditional computer science courses. However,\nmany of these topics naturally arise in traditional courses, or can be included with minimal effort. The\nbenefits of exposing students to SEP topics within the context of those traditional courses are\ninvaluable. Nonetheless institutional challenges will present barriers; for instance, some of these\ntraditional courses may not be offered at a given institution and, in such cases, it is difficult to cover\nthese topics appropriately without a dedicated SEP course. If social, ethical, and professional\nconsiderations are covered only in a dedicated course and not in the context of others, it could reinforce\nthe false notion that technical processes are void of these important aspects, or that they are more\nisolated than they are. Because of the broad relevance of these knowledge units, it is important that as\nmany traditional courses as possible include aspects such as case studies, that analyze ethical, legal,\nsocial, and professional considerations in the context of the technical subject matter of those courses.\nCourses in areas such as software engineering, databases, computer graphics, computer networks,\ninformation assurance & security, and introduction to computing, all provide obvious context for\nanalysis of such issues. However, an ethics-related module could be developed for almost any\nprogram. It would be explicitly against the spirit of these recommendations to have only a dedicated\ncourse within a specific computer science curriculum without great practical reason. Further, these\ntopics should be covered in courses starting from year 1. Presenting them as advanced topics in later\ncourses only creates an artificial perception that SEP topics are only important at a certain level or\ncomplexity. While it is true that the importance and consequence of SEP topics increases with level and\ncomplexity, introductory topics are not devoid of SEP topics. Further, many SEP topics are best\npresented early to lay a foundation for more intricate topics later in the curriculum.\n270\nRunning through all the topics in this knowledge area is the need to speak to the computing\npractitioner’s responsibility to proactively address issues through both ethical and technical actions.\nToday it is important not only for the topics in this knowledge area, but for students’ knowledge in\ngeneral, that the ethical issues discussed in any course should be directly related to – and arise\nnaturally from – the subject matter of that course. Examples include a discussion in a database course\nof the SEP aspects of data aggregation or data mining; or a discussion in a software engineering\ncourse of the potential conflicts between obligations to the customer and users as well as all others\naffected by their work. Computing faculty who are unfamiliar with the content and/or pedagogy of\napplied ethics are urged to take advantage of the considerable resources from ACM, IEEE-CS, AAAI,\nSIGCAS (ACM Special Interest Group on Computers and Society), and other organizations.\nAdditionally, it is the educator’s responsibility to impress upon students that this area is just as\nimportant – in ways more important – than technical areas. The societal, ethical, and professional\nknowledge gained in studying topics in this knowledge area will be used throughout one’s career and\nare transferable between projects, jobs, and often even industries, particularly as one’s career\nprogresses into project leadership and management.\nThe ACM Code of Ethics and Professional Conduct [5], the IEEE Code of Ethics [6], and the AAAI\nCode of Professional Ethics and Conduct [7] provide guidance that serve as the basis for the conduct of\nall computing professionals in their work. The ACM Code emphasizes that ethical reasoning is not an\nalgorithm to be followed, and computer professionals are expected to consider how their work impacts\nthe public good as the primary consideration. It falls to computing educators to highlight the domain-\nspecific role of these topics for our students, but computer science programs should certainly be willing\nto lean on complementary courses from the humanities and social sciences.\nMost computing educators are not also moral philosophers. Yet CS2023, along with past CS curricular\nrecommendations, indicate the need for ethical analysis. CS2023 and prior curricular recommendations\nare quite clear on the required mathematical foundations that students are expected to gain which are\noften delivered by mathematics departments. Yet, the same is not true of moral philosophy. No one\nwould expect a student to be able to provide a proof by induction until after having successfully\ncompleted a course in discrete mathematics. Yet, the parallel with respect to ethical analyses is\nsomehow absent. We seemingly do (often) expect our students to perform ethical analysis without\nhaving the appropriate prerequisite knowledge from philosophy. Further, the application of ethical\nanalysis also underlies every other knowledge unit in this knowledge area. We acknowledge that the\nknowledge unit Methods for Ethical Analysis (SEP-Ethical-Analysis) is the only one in this knowledge\narea that does not readily lend itself to being taught in the context of other CS2023 knowledge areas.\nSuggestions in terms of addressing this appear in the Course Packaging Suggestions.\nThe lack of prerequisite training in social, ethical, and professional topics has facilitated graduates\noperating with a certain ethical egoism (e.g., ‘Here is what I believe/think/feel is right’). Regardless of\nhow well intentioned, one might conclude that this is what brought us to a point in history where there\nare frequent occurrences of unintended consequences of technology, serious data breaches, and\nsoftware failures causing economic, emotional. and physical harm. Certainly, computing graduates who\nhave learned how to apply the various ethical frameworks or lenses proposed through the ages would\nonly serve to improve this situation. In retrospect, to ignore the lessons from moral philosophy, which\n271\nhave been debated and refined for millennia – on what it means to act justly, or work for the common\ngood – appears as hubris.\nA computer science student must not graduate without understanding how society and ethics influence\nthe computing profession. Nor should it be possible to complete a computer science degree without\nlearning how computing professionals influence society, the ethical considerations involved in shaping\nthat impact, and the student-turned-graduate’s role in these relationships, as both computing\nprofessionals and members of society.\nChanges Since CS2013\n● The overall number of hours dedicated to this knowledge unit has doubled since CS2013 from 16 to\n32 – CS2013 had 11 ‘Tier 1’ hours and 5 ‘Tier 2’ hours while CS2023 has 18 CS Core hours and 14\nKA Core hours). However, many of these hours are best covered within the context of other\nknowledge areas as discussed in the introduction to CS2023. Additionally:\n○ Several knowledge units that were ‘elective only’ in CS2013 now have CS Core and KA\nCore hours.\n○ The number of hours in most knowledge units has increased.\n● SEP has been re-titled from “Social Issues and Professional Practice” to “Society, Ethics, and the\nProfession.” Our rationale follows.\n○ Professional practice is an important part of being a professional. However, a solid\nunderstanding of the profession in which one is to become a professional is needed –\nindeed it is a prerequisite. Through this lens, professional conduct is part of a profession,\nalong with its history, values, norms, etc. Additionally, “the profession” appears in the ACM\ntagline “Advancing Computing as a Science & Profession”, and the ACM code [5]: “The\nACM Code of Ethics and Professional Conduct …expresses the conscience of the\nprofession.” In a similar way the AAAI Code [7] states that it “...expresses the conscience of\nthe AI profession”, and the IEEE code [6] states: “in accepting a personal obligation to our\nprofession, its members and the communities we serve, do hereby commit ourselves to the\nhighest ethical and professional conduct.” While studying computing, students should not\nonly learn how to become professionals, but also learn about the profession in which they\nwill become professionals.\n● Inclusion of the Diversity, Equity, Inclusion and Accessibility (DEIA) knowledge unit.\n● Changed titles of two knowledge units\n○ Professional Communication -> Communication\n○ Analytical Tools -> Methods for Ethical Analysis\nCore Hours\nKnowledge Unit CS Core KA Core\nSocial Context 3 2\nMethods for Ethical Analysis 2 1\n272\nProfessional Ethics 2 2\nIntellectual Property 1 1\nPrivacy and Civil Liberties 2 1\nCommunication 2 1\nSustainability 1 1\nHistory 1 1\nEconomies of Computing 0 1\nSecurity Policies, Laws, and Computer Crimes 2 1\nDiversity, Equity, Inclusion and Accessibility 2 2\nTotal 18 14\nKnowledge Units"
    }
  },
  {
    "title": "SEP-Context: Social Context",
    "CS Core": "1. Social implications (e.g., political and cultural ideologies) in a hyper-networked world where the\ncapabilities and impact of social media, artificial intelligence, and computing in general are rapidly\nevolving.\n2. Impact of computing applications (e.g., social media, artificial intelligence applications) on individual\nwell-being, and safety of all kinds (e.g., physical, emotional, economic).\n3. Consequences of involving computing technologies, particularly artificial intelligence, biometric\ntechnologies, and algorithmic decision-making systems, in civic life (e.g., facial recognition\ntechnology, biometric tags, resource distribution algorithms, policing software) and how human\nagency and oversight is crucial.\n273\n4. How deficits in diversity and accessibility in computing affect society and what steps can be taken to\nimprove equity in computing.",
    "KA Core": "5. Growth and control of the internet, data, computing, and artificial intelligence\n6. Often referred to as the digital divide, differences in access to digital technology resources and its\nresulting ramifications for gender, class, ethnicity, geography, and/or developing countries,\nincluding consideration of responsibility to those who might be less wealthy, under threat, or who\nwould struggle to have their voices heard.\n7. Accessibility issues, including legal requirements such as Web Content Accessibility Guidelines\n(www.w3.org/TR/WCAG21)\n8. Context-aware computing",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Describe the different ways that computer technology (networks, mobile computing, artificial\nintelligence) mediates social interaction at the personal and collective levels.\n2. Identify developers’ assumptions and values embedded in hardware and software design,\nespecially as they pertain to usability for diverse populations including under-served and those with\ndisabilities.\n3. Interpret the social context of a given design and its implementation.\n4. Analyze the efficacy of a given design and implementation using empirical data.\n5. Understand the implications of technology use (e.g., social media) for different identities, cultures,\nand communities.",
      "KA Core": "6. Describe the internet’s role in facilitating communication between citizens, governments, and each\nother.\n7. Analyze the effects of reliance on computing in the implementation of democracy (e.g., delivery of\nsocial services, electronic voting).\n8. Describe the impact of a lack of appropriate representation of people from historically minoritized\npopulations in the computing profession (e.g., industry culture, product diversity).\n9. Discuss the implications of context awareness in ubiquitous computing systems.\n10. Express how access to the internet and computing technologies affect different societies.\n11. Identify why/how internet access can be viewed as a human right."
    }
  },
  {
    "title": "SEP-Ethical-Analysis: Methods for Ethical Analysis",
    "CS Core": "1. Avoiding fallacies and misrepresentation in argumentation\n2. Ethical theories and decision-making (philosophical and social frameworks, e.g. [1])\n3. Recognition of the role culture plays in our understanding, adoption, design, and use of computing\ntechnology\n4. Why ethics is important in computing, and how ethics is similar to, and different from, laws and\nsocial norms",
    "KA Core": "5. Professional checklists\n6. Evaluation rubrics\n7. Stakeholder analysis\n8. Standpoint theory\n9. Introduction to ethical frameworks (e.g., consequentialism such as utilitarianism, non-\nconsequentialism such as duty, rights, or justice, agent-centered such as virtue or feminism,\ncontractarianism, ethics of care) and their use for analyzing an ethical dilemma",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Describe how a given cultural context impacts decision making.\n2. Express the use of example and analogy in ethical argument.\n3. Analyze (and avoid) basic logical fallacies in an argument.\n4. Analyze an argument to identify premises and conclusion.\n5. Evaluate how and why ethics is so important in computing and how it relates to cultural norms,\nvalues, and law.\n6. Justify a decision made on ethical grounds.",
      "KA Core": "7. Distinguish all stakeholder positions in relation to their cultural context in a given situation.\n8. Analyze the potential for introducing or perpetuating ethical debt (deferred consideration of ethical\nimpacts or implications) in technical decisions.\n9. Discuss the advantages and disadvantages of traditional ethical frameworks.\n275\n10. Analyze ethical dilemmas related to the creation and use of technology from multiple perspectives\nusing ethical frameworks."
    }
  },
  {
    "title": "SEP-Professional-Ethics: Professional Ethics",
    "CS Core": "1. Community values and the laws by which we live\n2. The nature of being a professional including care, attention, discipline, fiduciary responsibility, and\nmentoring\n3. Keeping up to date as a computing professional in terms of familiarity, tools, skills, legal and\nprofessional frameworks as well as the ability and responsibility to self-assess and progress in the\ncomputing field\n4. Professional certification, codes of ethics, conduct, and practice, such as the ACM, IEEE, AAAI,\nand other international societies\n5. Accountability, responsibility, and liability (e.g., software correctness, reliability and safety,\nwarranty, negligence, strict liability, ethical approaches to security vulnerability disclosures)\nincluding whether a product/service should be built, not just doing so because it is technically\npossible.\n6. Introduction to theories describing the human creation and use of technology including\ninstrumentalism, sociology of technological systems, disability justice, neutrality thesis,\npragmatism, and decolonial models, including developing and using technology to right wrongs and\ndo good\n7. Strategies for recognizing and reporting designs, systems, software, and professional conduct (or\ntheir outcomes) that may violate law or professional codes of ethics",
    "KA Core": "8. The role of the computing professional and professional societies in public policy\n9. Maintaining awareness of consequences\n10. Ethical dissent and whistleblowing\n11. The relationship between regional culture and ethical dilemmas\n12. Dealing with harassment and discrimination\n13. Forms of professional credentialing\n14. Ergonomics and healthy computing environments\n15. Time-to-market and cost considerations versus quality professional standards",
    "Illustrative Learning Outcomes": {
      "CS Core": "276\n1. Identify ethical issues that arise in software design, development practices, and software\ndeployment.\n2. Discuss how to address ethical issues in specific situations.\n3. Express the ethical responsibility of ensuring software correctness, reliability and safety including\nfrom where this responsibility arises (e.g., ACM/IEEE/AAAI Codes of Ethics, laws and regulations,\norganizational policies).\n4. Describe the mechanisms that typically exist for a professional to keep up to date in ethical\nmatters.\n5. Describe the strengths and weaknesses of relevant professional codes as expressions of being a\nprofessional and guides to decision-making.\n6. Analyze a global computing issue, observing the role of professionals and government officials in\nmanaging this problem.",
      "KA Core": "7. Describe ways in which professionals and professional organizations may contribute to public\npolicy.\n8. Describe the consequences of inappropriate professional behavior.\n9. Be familiar with whistleblowing and have access to knowledge to guide one through an incident.\n10. Identify examples of how regional culture interplays with ethical dilemmas.\n11. Describe forms of harassment and discrimination and avenues of assistance.\n12. Assess various forms of professional credentialing.\n13. State the relationship between ergonomics in computing environments and people’s health.\n14. Describe issues associated with industries’ push to focus on time-to-market versus enforcing\nquality professional standards."
    }
  },
  {
    "title": "SEP-IP: Intellectual Property",
    "CS Core": "1. Intellectual property rights\n2. Intangible digital intellectual property (IDIP)\n3. Legal foundations for intellectual property protection\n4. Common software licenses (e.g., MIT, GPL and its variants, Apache, Mozilla, Creative Commons)\n5. Plagiarism and authorship",
    "KA Core": "6. Philosophical foundations of intellectual property\n277\n7. Forms of intellectual property (e.g., copyrights, patents, trade secrets, trademarks) and the rights\nthey protect\n8. Limitations on copyright protections, including fair use and the first sale doctrine\n9. Intellectual property laws and treaties that impact the enforcement of copyrights\n10. Software piracy and technical methods for enforcing intellectual property rights, such as digital\nrights management and closed source software as a trade secret\n11. Moral and legal foundations of the open-source movement\n12. Systems that use others’ data (e.g., large language models)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Describe and critique legislation and precedent aimed at digital copyright infringements.\n2. Identify contemporary examples of intangible digital intellectual property.\n3. Select an appropriate software license for a given project.\n4. Defend legal and ethical uses of copyrighted materials.\n5. Interpret the intent and implementation of software licensing.\n6. Discuss whether a use of copyrighted material is likely to be fair use.\n7. Analyze the ethical issues inherent in various plagiarism detection mechanisms.\n8. Identify multiple forms of plagiarism beyond verbatim copying of text or software (e.g., intentional\nparaphrasing, authorship misrepresentation, and improper attribution).",
      "KA Core": "9. Discuss the philosophical bases of intellectual property in an appropriate context (e.g., country).\n10. Distinguish the conflicting issues involved in securing software patents.\n11. Contrast the protections and obligations of copyright, patent, trade secret, and trademarks.\n12. Describe the rationale for the legal protection of intellectual property in the appropriate context\n(e.g., country).\n13. Analyze the use of copyrighted work under the concepts of fair use and the first sale doctrine.\n14. Identify the goals of the open-source movement and its impact on fields beyond computing, such\nas the right-to-repair movement.\n15. Summarize the global nature of software piracy.\n16. Criticize the use of technical measures of digital rights management (e.g., encryption,\nwatermarking, copy restrictions, and region lockouts) from multiple stakeholder perspectives.\n17. Discuss the nature of anti-circumvention laws in the context of copyright protection."
    }
  },
  {
    "title": "SEP-Privacy: Privacy and Civil Liberties",
    "CS Core": "1. Privacy implications of widespread data collection including but not limited to transactional\ndatabases, data warehouses, surveillance systems, cloud computing, and artificial intelligence\n2. Conceptions of anonymity, pseudonymity, and identity\n3. Technology-based solutions for privacy protection (e.g., end-to-end encryption and differential\nprivacy)\n4. Civil liberties, privacy rights, and cultural differences",
    "KA Core": "5. Philosophical and legal conceptions of the nature of privacy including the right to privacy\n6. Legal foundations of privacy protection in relevant jurisdictions (e.g., GDPR in the EU)\n7. Privacy legislation in areas of practice (e.g., HIPAA in the US, AI Act in the EU)\n8. Basic Principles of human-subjects research and principles beyond what the law requires (e.g.,\nBelmont Report, UN Universal Declaration on Human Rights and how this relates to technology)\n9. Freedom of expression and its limitations\n10. User-generated content, content moderation, and liability",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Evaluate solutions to privacy threats in transactional databases and data warehouses.\n2. Describe the role of data collection in the implementation of pervasive surveillance systems (e.g.,\nRFID, face recognition, toll collection, mobile computing).\n3. Distinguish the concepts and goals of anonymity and pseudonymity.\n4. Describe the ramifications of technology-based privacy protections, including differential privacy\nand end-to-end encryption.\n5. Identify cultural differences regarding the nature and necessity of privacy and other civil liberties.",
      "KA Core": "6. Discuss the philosophical basis for the legal protection of personal privacy in an appropriate\ncontext (e.g., country).\n7. Critique the intent, potential value, and implementation of various forms of privacy legislation and\nprinciples beyond what the law requires.\n8. Identify strategies to enable appropriate freedom of expression."
    }
  },
  {
    "title": "SEP-Communication: Communication",
    "CS Core": "1. Oral, written, and electronic team and group communication\n2. Technical communication materials (e.g., source code, and documentation, tutorials, reference\nmaterials, API documentation)\n3. Communicating with different stakeholders such as customers, leadership, or the public\n4. Team collaboration (including tools) and conflict resolution\n5. Accessibility and inclusivity requirements for addressing professional audiences\n6. Cultural competence in communication including considering the impact of difference in natural\nlanguage",
    "KA Core": "7. Tradeoffs in competing factors that affect communication channels and choices\n8. Communicating to solve problems or make recommendations in the workplace, such as raising\nethical concerns or addressing accessibility issues",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Understand the importance of writing concise and accurate technical documents following well-\ndefined standards for format and for including appropriate tables, figures, and references.\n2. Analyze written technical documentation for technical accuracy, concision, lack of ambiguity, and\nawareness of audience.\n3. Compose and deliver an audience-aware, accessible, and organized formal presentation.\n4. Plan interactions (e.g., virtual, face-to-face, shared documents) with others in ways that invite\ninclusive participation, model respectful consideration of others’ contributions, and explicitly value\ndiversity of ideas.\n5. Identify and describe qualities of effective communication (e.g., virtual, face-to-face, intragroup,\nshared documents).\n6. Understand how to communicate effectively and appropriately as a member of a team including\nconflict resolution techniques.\n7. Discuss ways to influence performance and results in diverse and cross-cultural teams.",
      "KA Core": "8. Assess personal strengths and weaknesses to work remotely as part of a team drawing from\ndiverse backgrounds and experiences.\n9. Choose an appropriate way to communicate delicate ethical concerns.\n280"
    }
  },
  {
    "title": "SEP-Sustainability: Sustainability",
    "CS Core": "1. Environmental, social, and cultural impacts of implementation decisions (e.g., sustainability goals,\nalgorithmic bias/outcomes, economic viability, and resource consumption)\n2. Local/regional/global social and environmental impacts of computing systems and their use (e.g.,\ncarbon footprints, resource usage, e-waste) due to hardware (e.g., e-waste, data centers, rare\nelement and resource utilization, recycling) and software (e.g., cloud-based services, blockchain,\nAI model training and use). This includes everyday use of hardware (cheap hardware replaced\nfrequently) and software (web-browsing, email, and other services with hidden/remote\ncomputational demands).\n3. Guidelines for sustainable design standards.",
    "KA Core": "4. Systemic effects of complex computing technologies and phenomena (e.g., generative AI, data\ncenters, social media, offshoring, remote work).\n5. Pervasive computing: Information processing that has been integrated into everyday objects and\nactivities, such as smart energy systems, social networking, and feedback systems to promote\nsustainable behavior, transportation, environmental monitoring, citizen science and activism.\n6. How the sustainability of software systems is interdependent with social systems, including the\nknowledge and skills of its users, organizational processes and policies, and its societal context\n(e.g., market forces, government policies).",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Identify ways to be a sustainable practitioner in a specific area or with a specific project.\n2. Assess the environmental impacts of a given project’s deployment (e.g., energy consumption,\ncontribution to e-waste, impact of manufacturing).\n3. Describe global social and environmental impacts of computer use and disposal.\n4. List the sustainable effects of modern practices and activities (e.g., remote work, e-commerce,\ncryptocurrencies, AI models, data centers).",
      "KA Core": "281\n5. Describe the environmental impacts of design choices within the field of computing that relate to\nalgorithm design, operating system design, networking design, database design, etc.\n6. Analyze the social and environmental impacts of new system designs.\n7. Design guidelines for sustainable IT design or deployment in areas such as smart energy systems,\nsocial networking, transportation, agriculture, supply-chain systems, environmental monitoring, and\ncitizen activism.\n8. Assess computing applications in respect to environmental issues (e.g., energy, pollution, resource\nusage, recycling and reuse, food management and production)."
    }
  },
  {
    "title": "SEP-History: Computing History",
    "CS Core": "1. The history of computing: hardware, software, and human/organizational.\n2. The role of history in the present including within different social contexts, and the relevance of this\nhistory on the future.",
    "KA Core": "3. Age I (Pre-digital): Ancient analog computing (Stonehenge, Antikythera mechanism, Salisbury\nCathedral clock, etc.), human-calculated number tables, Euclid, Lovelace, Babbage, Gödel,\nChurch, Turing, pre-electronic (electro-mechanical and mechanical) hardware\n4. Age II (Early modern computing): ENIAC, UNIVAC, Bombes (Bletchley Park and codebreakers),\ncomputer companies (e.g., IBM), mainframes, etc.\n5. Age III (PC era): PCs, modern computer hardware and software, Moore’s Law\n6. Age IV (Internet): Networking, internet architecture, browsers and their evolution, standards, born-\non-the-internet companies, and services (e.g., Google, Amazon, Microsoft, etc.), distributed\ncomputing\n7. Age V (Mobile & Cloud): Mobile computing and smartphones, cloud computing and models thereof\n(e.g., SaaS), remote servers, security and privacy, social media\n8. Age VI (AI): Decision making systems, recommender systems, generative AI and other machine\nlearning driven tools and technologies",
    "Illustrative Learning Outcomes": {
      "CS Core": "282\n1. Understand the relevance and impact of computing history on recent events, present context, and\npossible future outcomes, from more than one cultural perspective.\n2. Discuss how perspectives held today have been shaped by history, and that alternative\nperspectives exist (e.g., fears of AI replacing human workers vs AI augmenting human work,\nvarious views on Moore’s Law).",
      "KA Core": "3. Identify formative and consequential trends in the history of the computing field.\n4. Identify the contributions of pioneering individuals or organizations (research labs, computer\ncompanies, government offices) in the computing field.\n5. Discuss the historical context for important moments in history of computing, such as the move\nfrom vacuum tubes to transistors (TRADIC), early seminal operating systems (e.g., OS 360), Xerox\nPARC and the first Apple computer with a GUI, the creation of specific programming language\nparadigms, the first computer virus, the creation of the internet, the creation of the WWW, the dot\ncom bubble, Y2K, the introduction of smartphones, etc.\n6. Compare daily life before and after the advent of milestone developments (e.g., personal\ncomputers or the internet)."
    }
  },
  {
    "title": "SEP-Economies: Economies of Computing",
    "KA Core": "1. Economic models: regulated and unregulated, monopolies, network effects, and open market;\nknowledge and attention economies\n2. Pricing and deployment strategies: planned obsolescence, subscriptions, freemium, software\nlicensing, open-source, free software, adware\n3. Impacts of differences in access to computing resources, and the effect of skilled labor supply and\ndemand on the quality of computing products\n4. Automation, AI, and their effects on job markets, developers, and users\n5. Ethical concerns surrounding the attention economy and other economies of computing (e.g.\ninformed consent, data collection, use of verbose legalese in user agreements)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Summarize the social effects of economic models (e.g., the knowledge and attention economies).\n2. Describe the differences and similarities of competing strategies (e.g., subscription vs freemium vs\nfree).\n3. Discuss examples of digital divides.\n4. Understand the effects of automation and AI on society.\n5. Understand the ethical implications of computing economies that rely on attention and data.\n283"
    }
  },
  {
    "title": "SEP-Security: Security Policies, Laws and Computer Crimes",
    "CS Core": "1. Computer crimes, legal redress for computer criminals and impact on victims and society\n2. Social engineering, computing-enabled fraud, identity theft and recovery from these\n3. Cyber terrorism, criminal hacking, and hacktivism\n4. Malware, viruses, worms\n5. Attacks on critical infrastructure such as electrical grids and pipelines\n6. Non-technical fundamentals of security (e.g., human engineering, policy, confidentiality)",
    "KA Core": "7. Benefits and challenges of existing and proposed computer crime laws\n8. Security policies and the challenges of change and compliance\n9. Responsibility for security throughout the computing life cycle\n10. International and local laws and how they intersect",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. List classic examples of computer crimes and social engineering incidents with societal impact.\n2. Identify issues with laws that apply to computer crimes.\n3. Describe the motivation and ramifications of cyber terrorism, data theft, hacktivism, ransomware,\nand other attacks.\n4. Examine the ethical and legal issues surrounding the misuse of access and various breaches of\nsecurity.\n5. Discuss the professional's role in security and the tradeoffs and challenges involved.",
      "KA Core": "6. Investigate measures that can be taken by both individuals and organizations including\ngovernments to prevent or mitigate the undesirable effects of computer crimes.\n7. Design a company-wide security policy, which includes procedures for managing passwords and\nemployee monitoring.\n8. Understand how legislation from one region may affect activities in another (e.g., how EU GDPR\napplies globally, when EU persons are involved).\n284"
    }
  },
  {
    "title": "SEP-DEIA: Diversity, Equity, Inclusion, and Accessibility",
    "CS Core": "1. How identity impacts and is impacted by computing technologies and environments (academic and\nprofessional)\n2. The benefits of diverse development teams and the impacts of teams that are not diverse\n3. Inclusive language and charged terminology, and why their use matters\n4. Inclusive behaviors and why they matter\n5. Designing and developing technology with accessibility in mind\n6. How computing professionals can influence and impact diversity, equity, inclusion and accessibility,\nincluding but not only through the software they create",
    "KA Core": "7. Experts and their practices that reflect the identities of the classroom and the world through\npractical DEIA principles\n8. Historic marginalization due to systemic social mechanisms, technological supremacy and global\ninfrastructure challenges to diversity, equity, inclusion, and accessibility\n9. Cross-cultural differences in, and needs for, diversity, equity, inclusion, and accessibility\n285",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Define and distinguish equity, equality, diversity, inclusion, and accessibility.\n2. Identify language, practices, and behaviors that may make someone feel included in a workplace\nand/or a team, and why is it relevant. Avoid charged terminology - see Words Matter\n(www.acm.org/diversity-inclusion/words-matter) – this includes identifying and accommodating\nusers who are often excluded without thought and not considered at all.\n3. Evaluate the accessibility of your classroom or lab. Evaluate the accessibility of your webpage.\n(See www.w3.org/WAI and www.w3.org/TR/WCAG21).\n4. Demonstrate collegiality and respect when working with team members who do not share your\nidentity. It is not enough to merely assign team projects. Faculty should prepare students for\nteamwork and monitor, mentor, and assess the effectiveness of their student teams throughout a\nproject.\n5. Compare the demographics of your institution’s computer science and STEM majors to the overall\ninstitutional demographics. If they differ, identify factors that contribute to inequitable access,\nengagement, and achievement in computer science among marginalized groups. If they do not,\nassess why not.\n6. Identify developers’ assumptions and values embedded in hardware and software design,\nespecially as they pertain to usability by diverse populations.\n7. Identify examples of the benefits that diverse teams can bring to software products, and how a lack\nof diversity has costs.",
      "KA Core": "8. Analyze the work of experts who reflect the identities of the classroom and the world.\n9. Assess the impact of power and privilege in the computing profession as it relates to culture,\nindustry, products, and society.\n10. Develop examples of systemic changes that could positively address diversity, equity, inclusion,\nand accessibility in a familiar context (i.e., in an introductory computing course) and an unfamiliar\ncontext and when these might be different, or the same.\n11. Compare the demographics of your institution to the overall community demographics. If they\ndiffer, identify factors that contribute to inequitable access, engagement, and achievement among\nmarginalized groups. If they do not, assess why not.\nProfessional Dispositions\n● Critically Self-reflective: Students should be able to inspect their own actions, thoughts, biases,\nprivileges, and motives to discover places where professional activity is not up to current standards.\nThey must strive to understand both conscious and unconscious biases and continuously work to\ncounteract them.\n● Responsive: Students must quickly and accurately respond to changes in the field and adapt in a\nprofessional manner, such as shifting from in-person office work to remote work at home. These\nshifts require rethinking one’s entire approach to what is considered “professional”.\n286\n● Proactive: Students must be able to identify areas of importance (e.g., in accessibility and inclusion)\nand understand how to address them for a more professional working environment.\n● Culturally Competent: Students must prioritize cultural competence—the ability to work with people\nfrom cultures different from one’s own – by using inclusive language, watching for, and counteracting\nconscious and unconscious biases, and encouraging honest and open communication.\n● Advocative: Students must think, speak, and act in ways that foster and promote diversity, equity,\ninclusion, and accessibility in all ways including but not limited to teamwork, communication, and\nproduct development (hardware and software).\n● Responsible: Students must act responsibly in all areas of their work toward all users and\nstakeholders including the society at large, colleagues, and their profession in general.\nCourse Packaging Suggestions\nIn computing, societal and ethical considerations arise in all other knowledge areas and therefore\nshould arise in the context of other computing courses, not just siloed in an “SEP course.” These topics\nshould be covered in courses starting from the first year (the only likely exception is SEP-Ethical-\nAnalysis: Methods for Ethical Analysis) although this could be delivered as part of a first-year course or\nvia a seminar or an online independent study.\nPresenting SEP topics as advanced topics only covered in later courses could create the incorrect\nperception that SEP topics are only important at a certain level or complexity. While it is true that the\nimportance and consequence of SEP topics increases with level and complexity, introductory topics are\nnot devoid of SEP topics. Further, many SEP topics are best presented early to lay a foundation for\nmore intricate topics later in the curriculum.\nInstructor choice for some of these topics is complex. When SEP topics arise in other courses these\nare naturally often taught by the instructor teaching that course, although at times bringing in expert\neducators from other disciplines (e.g., law, ethics) could be advantageous. Stand-alone courses in SEP\n– should they be needed – are likely best delivered by an interdisciplinary team. However, this brings\nadditional complexity. Regardless, who teaches SEP topics and/or courses warrants careful\nconsideration.\nAt a minimum the SEP CS Core learning outcomes are best covered in the context of courses\ncovering other knowledge areas – ideally the SEP KA Core hours are also, with the likely\nexception of SEP-Ethical-Analysis. This knowledge unit (KU) underlies every other KU in the SEP\nknowledge area (KA). However, this KU is the only one in the SEP KA that does not readily lend itself\nto being taught in the context of other KAs. Delivering these topics warrants even more careful\nconsideration as to how/where they will be covered, and who will teach them. In conjunction with\ncovering SEP topics as they occur naturally in other KAs, dedicated SEP courses can add value.\nHowever, a sole, stand-alone course in a program where SEP topics are not covered in other courses\nshould be a last resort.\nAt some institutions, an in-depth dedicated course at the mid- or advanced-level may be offered\ncovering all recommended topics in both the CS Core and KA Core KUs in close coordination with\nlearning outcomes best covered in the context of courses covering other KAs. Such a course\ncould include:\n287\n● SEP-Context (5 hours)\n● SEP-Ethical-Analysis (3 hours)\n● SEP-Professional-Ethics (4 hours)\n● SEP-IP (2 hours)\n● SEP-Privacy (3 hours)\n● SEP-Communication (3 hours)\n● SEP-Sustainability (2 hours)\n● SEP-History (2 hours)\n● SEP-Economies (1 hour)\n● SEP-Security (3 hours)\n● SEP-DEIA (4 hours)\nSkill Statement\nA student who completes this course should be able to contribute to systemic change by applying\nsocietal and ethical knowledge using relevant underpinnings and frameworks to their work in the\ncomputing profession in a culturally competent manner including contributing to positive developments\nin inclusion, equity, diversity, and accessibility in computing.\nAt some institutions, a dedicated minimal course may be offered covering the CS Core knowledge\nunits in close coordination with learning outcomes best covered in the context of courses\ncovering other knowledge areas. Such a course could include:\n● SEP-Context (3 hours)\n● SEP-Ethical-Analysis (2 hours)\n● SEP-Professional-Ethics (2 hours)\n● SEP-IP (1 hour)\n● SEP-Privacy (2 hours)\n● SEP-Communication (2 hours)\n● SEP-Sustainability (1 hour)\n● SEP-History (1 hour)\n● SEP-Security (2 hours)\n● SEP-DEIA (2 hours)\nSkill Statement\nA student who completes this course should be able to apply societal and ethical knowledge to their\nwork in the computing profession while fostering and contributing to inclusion, equity, diversity, and\naccessibility in computing.\nSome Exemplary Materials\n● Emanuelle Burton, Judy Goldsmith, Nicholas Mattei, Cory Siler, and Sara-Jo Swiatek. 2023.\nTeaching Computer Science Ethics Using Science Fiction. In Proceedings of the 54th ACM\nTechnical Symposium on Computer Science Education V. 2 (SIGCSE 2023). Association for\nComputing Machinery, New York, NY, USA, 1184. https://doi.org/10.1145/3545947.3569618\n● Randy Connolly. 2020. Why computing belongs within the social sciences. Commun. ACM 63, 8\n(August 2020), 54–59. https://doi.org/10.1145/3383444\n288\n● Casey Fiesler. Tech Ethics Curricula: A Collection of Syllabi Used to Teach Ethics in\nTechnology Across Many Universities\na. https://cfiesler.medium.com/tech-ethics-curricula-a-collection-of-syllabi-3eedfb76be18 ;\naccessed March 12, 2024.\nb. Tech Ethics Curricula; accessed March 12, 2024.\n● Casey Fiesler. Tech Ethics Readings: A Spreadsheet of Readings Used to Teach Ethics in\nTechnology Tech Ethics Class Readings; accessed March 12, 2024.\n● Stanford Embedded EthiCS, Embedding Ethics in Computer Science.\nhttps://embeddedethics.stanford.edu/; accessed March 12, 2024.\n● Jeremy, Weinstein, Rob Reich, and Mehran Sahami. System Error: Where Big Tech Went\nWrong and How We Can Reboot. Hodder Paperbacks, 2023.\n● Baecker, R. Computers in Society: Modern Perspectives, Oxford University Press. (2019).\n● Embedded EthiCS @ Harvard: bringing ethical reasoning into the computer science curriculum.\nhttps://embeddedethics.seas.harvard.edu/about; accessed March 12, 2024.\nCommittee\nChair: Brett A. Becker, University College Dublin, Dublin, Ireland\nMembers:\n● Richard L. Blumenthal, Regis University, Denver, CO, USA\n● Mikey Goldweber, Denison University, Granville, OH, USA\n● James Prather, Abilene Christian University, Abilene, TX, USA\n● Susan Reiser, University of North Carolina Asheville, Asheville, NC, USA\n● Michelle Trim, University of Massachusetts Amherst, Amherst, MA, USA\n● Titus Winters, Google, Inc, New York, NY, USA\nContributors:\n● Jake Baskin, Computer Science Teachers Association, Chicago, IL, USA\n● Johanna Blumenthal, Regis University, Denver, CO, USA\n● Chris Stephenson, Google, Portland, OR, USA\n● MaryAnne Egan, Siena College, Loudonville, NY, USA\n● Catherine Mooney, University College Dublin, Dublin, Ireland\n● Fay Cobb Payton, North Carolina State University, Raleigh, NC, USA\n● Keith Quille, Technological University of Dublin, Dublin, Ireland\n● Mehran Sahami, Stanford University, Stanford, CA, USA\n● Mark Scanlon, University College Dublin, Dublin, Ireland\n● Karren Shorofsky, University of San Francisco School of Law, San Francisco, CA, USA\n● Andreas Stefik, University of Nevada, Las Vegas, Las Vegas, NV, USA\n● Ellen Walker, Hiram College, Cleveland, OH, USA\n289\nReferences\n1. ACM/IEEE-CS Joint Curriculum Task Force. “Computing Curricula 1991.” (New York, USA: ACM\nPress and IEEE Computer Society Press, 1991).\n2. ACM/IEEE-CS Joint Curriculum Task Force. “Computing Curricula 2001 Computer Science.” (New\nYork, USA: ACM Press and IEEE Computer Society Press, 2001).\n3. ACM/IEEE-CS Interim Review Task Force. “Computer Science Curriculum 2008: An interim revision\nof CS 2001.” (New York, USA: ACM Press and IEEE Computer Society Press, 2008).\n4. Randy Connolly. 2020. Why computing belongs within the social sciences. Commun. ACM 63, 8\n(August 2020), 54–59. https://doi.org/10.1145/3383444\n5. ACM Code of Ethics and Professional Conduct. www.acm.org/about/code-of-ethics\n6. IEEE Code of Ethics. https://www.ieee.org/about/corporate/governance/p7-8.html; accessed March\n12, 2024.\n7. AAAI Code of Professional Ethics and Conduct. https://aaai.org/Conferences/code-of-ethics-and-\nconduct.php; accessed March 12, 2024.\n8. Diversity, Equity, and Inclusion - Welcoming All to Computing https://www.acm.org/diversity-\ninclusion; accessed March 12, 2024.\n9. Diversity, Equity & Inclusion at IEEE. https://www.ieee.org/about/diversity-index.html; accessed\nMarch 12, 2024.\n10. AAAI Diversity Statement. https://aaai.org/about-aaai/ethics-and-diversity/#diversity-statement;\naccessed March 12, 2024.\n11. A Framework for Ethical Decision Making. https://www.scu.edu/ethics/ethics-resources/a-\nframework-for-ethical-decision-making/ accessed March 12, 2024.\n12. Sustainability | United Nations. https://www.un.org/en/academic-impact/sustainability; accessed\nMarch 12, 2024.\n13. What is Sustainability? https://www.sustain.ucla.edu/what-is-sustainability; accessed March 12,\n2024.\n290\nSystems Fundamentals (SF)\nPreamble\nA computer system is a set of hardware and software infrastructures upon which applications are\nconstructed. Computer systems have become a pillar of people's daily life. As such, it is essential for\nstudents to learn knowledge about computer systems, grasp the skills to use and design these\nsystems, and understand the fundamental rationale and principles in computer systems. It could equip\nstudents with the necessary competence for a career related to computer science.\nIn the curriculum of computer science, the study of computer systems typically spans multiple\nknowledge areas, including, but not limited to, operating systems, parallel and distributed systems,\ncommunications networks, computer architecture and organization, and software engineering. The\nSystem Fundamentals knowledge area, as suggested by its name, focuses on the fundamental\nconcepts and design principles in computer systems that are shared by these courses within their\nrespective cores. The goal of this knowledge area is to present an integrative view of these\nfundamental concepts and design principles in a unified albeit simplified fashion, providing a common\nfoundation for the different specialized mechanisms and policies appropriate to the specific domain\narea. The fundamental concepts in this knowledge area include an overview of computer systems,\nbasic concepts such as state and state transition, resource allocation and scheduling, and so on.\nMoreover, this knowledge area introduces basic design principles to improve the reliability, availability,\nefficiency, and security of computer systems.\nChanges since CS2013\nCompared to CS2013, the SF knowledge area incorporated significant changes to the knowledge units.\n• Added two new knowledge units: System Security and System Design.\n• Added a new knowledge unit named System Performance, which includes the topics from the\ndeprecated knowledge unit of Proximity and the deprecated knowledge unit of Virtualization and\nIsolation.\n• Added a new knowledge unit named Performance Evaluation, that includes the topics from the\ndeprecated unit of Evaluation and the deprecated unit of Quantitative Evaluation.\n• Renamed the Computational Paradigms knowledge unit to Overview of Computer Systems,\ndeprecated some topics in the unit, and added topics from the deprecated unit of Cross-Layer\nCommunications.\n• Renamed the State and State Machines knowledge unit to Basic Concepts and added topics such\nas finite state machines.\n• Deprecated the Cross-Layer Communications knowledge unit and moved parts of its topics to the\nunit of Overview of Computer Systems.\n• Deprecated the Evaluation and Quantitative Evaluation knowledge units and moved parts of their\ntopics to the unit of Performance Evaluation.\n• Deprecated the Proximity and Virtualization and Isolation knowledge units and moved parts of their\ntopics to the knowledge unit of System Performance.\n291\n• Deprecated the Parallelism knowledge unit and moved parts of its topic to the Basic Concepts\nknowledge unit.\n• Renamed the Reliability through Redundancy knowledge unit to System Reliability.\n• Added the Society, Ethics, and the Profession knowledge unit.\nCore Hours\nKnowledge Unit CS Core KA Core\nOverview of Computer Systems 3 0\nBasic Concepts 4 0\nResource Management 1 1\nSystem Performance 2 2\nPerformance Evaluation 2 2\nSystem Reliability 2 1\nSystem Security 2 1\nSystem Design 2 1\nSociety, Ethics, and Profession Included in SEP hours\nTotal 18 8\nKnowledge Units"
    }
  },
  {
    "title": "SF-Overview: Overview of Computer Systems",
    "CS Core": "1. Basic building blocks and components of a computer (gates, flip-flops, registers, interconnections;\ndatapath + control + memory)\n2. Hardware as a computational paradigm: Fundamental logic building blocks; Logic expressions,\nminimization, sum of product forms (See also: AR-Logic)\n3. Programming abstractions, interfaces, use of libraries (See also: PDC-Programs)\n4. Distinction and interaction between application and OS services, remote procedure call (See also:\nOS-Purpose)\n5. Basic concept of pipelining, overlapped processing stages (See also: AR-Organization)\n6. Basic concept of scaling: performance vs problem size",
    "Illustrative Learning Outcomes": {
      "CS Core": "292\n1. Describe the basic building blocks of computers and their role in the historical development of\ncomputer architecture.\n2. Design a simple logic circuit using the fundamental building blocks of logic design to solve a simple\nproblem (e.g., adder).\n3. Describe how computing systems are constructed of layers upon layers, based on separation of\nconcerns, with well-defined interfaces, hiding details of low layers from the higher layers.\n4. Describe that hardware, OS, VM, and application are additional layers of interpretation/processing.\n5. Describe the mechanisms of how errors are detected, signaled back, and handled through the\nlayers.\n6. Construct a simple program (e.g., a TCP client/server) using methods of layering, error detection\nand recovery, and reflection of error status across layers.\n7. Identify bugs in a layered program by using tools for program tracing, single stepping, and\ndebugging.\n8. Understand the concept of strong vs weak scaling, i.e., how performance is affected by the scale of\nthe problem vs the scale of resources to solve the problem. This can be motivated by simple, real-\nworld examples."
    }
  },
  {
    "title": "SF-Foundations: Basic Concepts",
    "CS Core": "1. Digital vs Analog/Discrete vs Continuous Systems\n2. Simple logic gates, logical expressions, Boolean logic simplification\n3. Clocks, State, Sequencing\n4. State and state transition (e.g., starting state, final state, life cycle of states) (See also: AL-Models)\n5. Finite state machines (e.g., NFA, DFA) (See also: AL-Models)\n6. Combinational Logic, Sequential Logic, Registers, Memories (See also: AR-Logic)\n7. Computers and Network Protocols as examples of State Machines (See also: NC-Fundamentals)\n8. Sequential vs parallel processing. (See also: PDC-Programs, OS-Concurrency)\n9. Application-level sequential processing: single thread (See also: PDC-Programs, OS-Concurrency)\n10. Simple application-level parallel processing: request level (web services/client-server/distributed),\nsingle thread per server, multiple threads with multiple servers, pipelining (See also: PDC-\nPrograms, OS-Concurrency)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Describe the differences between digital and analog systems, and between discrete and continuous\nsystems. Can give real-world examples of these systems.\n2. Describe computations as a system characterized by a known set of configurations with transitions\nfrom one unique configuration (state) to another (state).\n3. Describe the distinction between systems whose output is only a function of their input (stateless)\nand those with memory/history (stateful).\n4. Develop state machine descriptions for simple problem statement solutions (e.g., traffic light\nsequencing, pattern recognizers).\n5. Describe a computer as a state machine that interprets machine instructions.\n293\n6. Explain how a program or network protocol can also be expressed as a state machine and that\nalternative representations for the same computation can exist.\n7. Derive the time-series behavior of a state machine from its state machine representation (e.g., TCP\nconnection management state machine).\n8. Write a simple sequential problem and a simple parallel version of the same program.\n9. Evaluate the performance of simple sequential and parallel versions of a program with different\nproblem sizes and be able to describe the speed-ups achieved.\n10. Describe on an execution timeline how parallelism events and operations can take place\nsimultaneously (i.e., at the same time). Explain how work can be performed in less elapsed time if\nthis can be exploited."
    }
  },
  {
    "title": "SF-Resource: Resource Management",
    "CS Core": "1. Different types of resources (e.g., processor share, memory, disk, net bandwidth) (See also: OS-\nScheduling, OS-Memory, OS-Files, NC-Fundamentals)\n2. Common resource allocation/scheduling algorithms (e.g., first-come-first-serve, priority-based\nscheduling, fair scheduling, and preemptive scheduling) (See also: OS-Scheduling)",
    "KA Core": "3. Advantages and disadvantages of common scheduling algorithms (See also: OS-Scheduling)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Define how finite computer resources (e.g., processor share, memory, storage, and network\nbandwidth) are managed by their careful allocation to existing entities.\n2. Describe how common resource allocation/scheduling algorithms work.\n3. Develop common scheduling algorithms and evaluate their performances.",
      "KA Core": "4. Describe the pros and cons of common scheduling algorithms."
    }
  },
  {
    "title": "SF-Performance: System Performance",
    "CS Core": "1. Latencies in computer systems\na. Speed of light and computers (one foot per nanosecond vs one GHz clocks) (See also: AR-\nOrganization)\nb. Memory vs disk latencies vs across-the-network memory (See also: AR-Memory, AR-\nPerformance-Energy)\n2. Caches and the effects of spatial and temporal locality on performance in processors and systems\n(See also: AR-Memory, AR-Performance-Energy, OS-Memory)\n3. Caches and cache coherency in databases, operating systems, distributed systems, and computer\narchitecture (See also: OS-Memory, AR-Memory, DM-Internals)\n4. Introduction to the processor memory hierarchy (See also: AR-Memory, AR-Performance-Energy)\n294",
    "KA Core": "5. The formula for average memory access time (See also: AR-Memory)\n6. Rationale of virtualization and isolation: protection and predictable performance (See also: OS-\nVirtualization)\n7. Levels of indirection, illustrated by virtual memory for managing physical memory resources (See\nalso: OS-Virtualization)\n8. Methods for implementing virtual memory and virtual machines (See also: OS-Virtualization)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Describe the breakdown of the latency of computer systems in terms of memory, disk, and network.\n2. Explain the importance of locality in determining system performance.\n3. Calculate average memory access time and describe the tradeoffs in memory hierarchy\nperformance in terms of capacity, miss/hit rate, and access time.",
      "KA Core": "4. Explain why it is important to isolate and protect the execution of individual programs and\nenvironments that share common underlying resources.\n5. Describe how the concept of indirection can create the illusion of a dedicated machine and its\nresources even when physically shared among multiple programs and environments.\n6. Evaluate the performance of two application instances running on separate virtual machines and\ndetermine the effect of performance isolation."
    }
  },
  {
    "title": "SF-Evaluation: Performance Evaluation",
    "CS Core": "1. Performance figures of merit (See also: AR-Performance-Energy, PDC-Evaluation)\n2. Workloads and representative benchmarks, and methods of collecting and analyzing performance\nfigures of merit (See also: AR-Performance-Energy, PDC-Evaluation)\n3. CPI (Cycles per Instruction) equation as a tool for understanding tradeoffs in the design of\ninstruction sets, processor pipelines, and memory system organizations (See also: AR-\nPerformance-Energy, PDC-Evaluation)\n4. Amdahl’s Law: the part of the computation that cannot be sped up limits the effect of the parts that\ncan (See also: AR-Performance-Energy, PDC-Evaluation)\n5. Order of magnitude analysis (Big O notation) (See also: AL-Complexity)\n6. Analysis of slow and fast paths of a system (See also: AR-Organization)\n7. Events on their effect on performance (e.g., instruction stalls, cache misses, page faults) (See also:\nOS-Memory, AR-Organization)",
    "KA Core": "7. Analytical tools to guide quantitative evaluation\n8. Understanding layered systems, workloads, and platforms, their implications for performance, and\nthe challenges they represent for evaluation\n9. Microbenchmark pitfalls\n295",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Explain how the components of system architecture contribute to improving its performance.\n2. Explain the circumstances in which a given figure of a system performance metric is useful.\n3. Explain the usage and inadequacies of benchmarks as a measure of system performance.\n4. Describe Amdahl’s law and discuss its limitations.\n5. Apply limit studies or simple calculations to produce order-of-magnitude estimates for a given\nperformance metric in a given context.\n6. Apply software tools to profile and measure program performance.",
      "KA Core": "7. Design and conduct a performance-oriented experiment of a common system (e.g., an OS and\nSpark).\n8. Design a performance experiment on a layered system to determine the effect of a system\nparameter on system performance."
    }
  },
  {
    "title": "SF-Reliability: System Reliability",
    "CS Core": "1. Distinction between bugs, faults, and failures (See also: PDC-Coordination, SE-Reliability)\n2. Reliability vs availability\n3. Reliability through redundancy\na. check and retry (See also: OS-Faults, NC-Reliability)\nb. redundant encoding (error correction codes, CRC, FEC, RAID) (See also: AR-Memory, NC-\nReliability, DM-Distributed)\nc. duplication/mirroring/replicas (See also: DM-Distributed)",
    "KA Core": "4. Other approaches to reliability (e.g., journaling) (See also: OS-Faults, NC-Reliability, SE-Reliability)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Explain the distinction between program errors, system errors, and hardware faults (e.g., corrupted\nmemory) and exceptions (e.g., attempt to divide by zero).\n2. Articulate the distinction between detecting, handling, and recovering from faults and the methods\nfor their implementation.\n3. Describe the role of error correction codes in providing error checking and correction techniques in\nmemories, storage, and networks.\n4. Apply simple algorithms for exploiting redundant information for the purposes of data correction.",
      "KA Core": "5. Compare different error detection and correction methods for their data overhead, implementation\ncomplexity, and relative execution time for encoding, detecting, and correcting errors.\n296"
    }
  },
  {
    "title": "SF-Security: System Security",
    "CS Core": "1. Common system security issues (e.g., viruses, denial-of-service attacks, and eavesdropping) (See\nalso: OS-Protection, NC-Security, SEC-Foundations, SEC-Engineering)\n2. Countermeasures (See also: OS-Principles, OS-Protection, NC-Security)\na. Cryptography (See also: SEC-Crypto)\nb. Security architecture (See also: SEC-Engineering)",
    "KA Core": "3. Representative countermeasure systems\na. Intrusion detection systems, firewalls (See also: NC-Security)\nb. Antivirus systems",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Describe some common system security issues and give examples\n2. Describe some countermeasures against system security issues",
      "KA Core": "3. Describe representative countermeasure systems"
    }
  },
  {
    "title": "SF-Design: System Design",
    "CS Core": "1. Common criteria of system design (e.g., liveness, safety, robustness, scalability, and security) (See\nalso: PDC-Evaluation)",
    "KA Core": "2. Designs of representative systems (e.g., Apache web server, Spark, and Linux)",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. Describe common criteria of system design.\n2. Given the functionality requirements of a system and its key design criteria, provide a high-level\ndesign of this system.",
      "KA Core": "3. Describe the design of some representative systems."
    }
  },
  {
    "title": "SF-SEP: Society, Ethics, and the Profession",
    "KA Core": "1. Intellectual property rights of computer systems (See also: SEP-IP)\n2. Common software licenses (See also: SEP-IP)\n3. Computer crimes (See also: SEP-Security)\n297",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Describe the intellectual property rights of computer systems.\n2. List representative software licenses and compare their differences.\n3. List representative computer crimes.\nProfessional Dispositions\n● Meticulous: Students must pay attention to details of different perspectives when learning about\nand evaluating systems.\n● Adaptive: Students must be flexible and adaptive when designing systems. Different systems have\ndifferent requirements, constraints and working scenarios. As such, they require different designs.\nStudents must be able to make appropriate design decisions correspondingly.\nMathematics Requirements\nRequired:\n● Discrete Mathematics (See also: MSF-Discrete)\no Sets and relations\no Basic graph theory\no Basic logic\n● Linear Algebra (See also: MSF-Linear)\no Basic matrix operations\n● Probability and Statistics (See also: MSF-Probability, MSF-Statistics)\no Random variable\no Bayes theorem\no Expectation and Variation\no Cumulative distribution function and probability density function\nDesirable:\n● Basic queueing theory\n● Basic stochastic process\nCourse Packaging Suggestions\nIntroductory Course to include the following:\n● SF-Overview (2 hours)\n● SF-Foundations (6 hours)\n● SF-Resource (4 hours)\n● SF-Performance (6 hours)\n● SF-Evaluation (6 hours)\n● SF-Reliability (4 hours)\n298\n● SF-Security (5 hours)\n● SF-SEP (1 hour)\n● SF-Design (6 hours)\nPrerequisites:\n● Sets and relations, basic graph theory and basic logic from Discrete Mathematics (See also:\nMSF-Discrete)\n● Basic matrix operations from Linear Algebra (See also: MSF-Linear)\n● Random variable, Bayes theorem, expectation and variation, cumulative distribution function\nand probability density function from Probability and Statistics (See also: MSF-Probability, MSF-\nStatistics)\nCourse objectives: Students should be able to (1) understand the fundamental concepts in computer\nsystems; (2) understand the key design principles, in terms of performance, reliability and security,\nwhen designing computer systems; (3) deploy and evaluate representative complex systems (e.g.,\nMySQL and Spark) based on their documentations, and (4) design and implement simple computer\nsystems (e.g., an interactive program, a simple web server, and a simple data storage system).\nAdvanced Course to include the following:\n● SF-Overview: Overview of Computer Systems (2 hours)\n● SF-Design: System Design (8 hours)\n● OS-Purpose, OS-Principles (2 hours)\n● NC-Fundamentals, NC-Networked-Applications (2 hours)\n● PDC-Programs (2 hours)\n● AR-IO, AR-Performance-Energy (2 hours)\n● SF-Reliability (8 hours)\n● SF-Performance (6 hours)\n● SF-Security (6 hours)\n● SF-SEP: (2 hours)\nPrerequisites:\n● Basic queueing theory and stochastic process (See also: MSF-Probability, MSF-Statistics)\n● Introductory course of the SF knowledge area\nCourse objectives: Students should be able to (1) have a deeper understanding in the key design\nprinciples of computer system design, (2) map such key principles to the designs of classic systems\n(e.g., Linux, SQL and TCP/IP network stack) as well as that of more recent systems (e.g., Hadoop,\nSpark and distributed storage systems), and (3) design and implement more complex computer\nsystems (e.g., a file system and a high-performance web server).\nCommittee\nChair: Qiao Xiang, Xiamen University, Xiamen, China\n299\nMembers:\n● Doug Lea, State University of New York at Oswego, Oswego, NY, USA\n● Monica D. Anderson, University of Alabama, Tuscaloosa, AL, USA\n● Matthias Hauswirth, University of Lugano, Lugano, Switzerland\n● Ennan Zhai, Alibaba Group, Hangzhou, China\n● Yutong Liu, Shanghai JiaoTong University, Shanghai, China\nContributors:\n● Michael S. Kirkpatrick, James Madison University, Harrisonburg, VA, USA\n● Linghe Kong, Shanghai JiaoTong University, Shanghai, China\n300\nSpecialized Platform Development (SPD)\nPreamble\nThe Specialized Platform Development (SPD) knowledge area refers to attributes involving the creation\nof software targeting non-traditional hardware platforms. Developing for each specialized platform, for\nexample, robots, mobile systems, web-based systems, and embedded systems, typically involves\nunique considerations.\nSocietal and industry needs have created a high demand for developers on specialized platforms, such\nas mobile applications, web platforms, robotic platforms, and embedded systems. Some unique\nprofessional abilities relevant to this knowledge area include the following.\n● Creating applications that provide a consistent user experience across various devices, screen\nsizes, and operating systems.\n● Developing application programming interfaces (APIs) to support the functionality of each\nspecialized platform.\n● Managing challenges related to resource constraints such as computation, memory, storage,\nand networking and communication.\n● Applying cross-cutting concerns such as optimization, security, better development practices,\netc.\nChanges since CS2013\nThe assessment of these factors has led to significant modifications from the CS2013 version, including\nthe following.\n• The knowledge area name has been changed to reflect the specialized development platforms\nwhich serve as the target for software development.\n• Reflecting the increased deployment of specialized hardware platforms, the number of CS Core\nhours has been increased.\n• Reflecting modern computing systems, knowledge units in Robotics, Embedded Systems, and\nSociety, Ethics, and the Profession (SEP) have been introduced.\n• Other changes include: 1) renamed Introduction knowledge unit to Common Aspects/Shared\nConcerns and 2) renamed Industrial Platforms to Robot Platforms.\nCore Hours\nKnowledge Unit CS Core KA Core\nCommon Aspects 3 + (1 SE) 2\nWeb Platforms 5 + (1 HCI)\n301\nMobile Platforms 3 + (2 DM) + (1 GIT) + (1 HCI) + (1 NC)\nRobot Platforms 4 + (3 GIT) + (3 AI)\nEmbedded Platforms 4 + (4 AR) + (1 FPL) + (1 GIT) + (3 OS) + (1 SF)\nGame Platforms 4 + (1 AL) + (1 AI) + (4 AR) + (5 GIT) + (2 HCI) +\n(1 SDF) + (1 SE) + (1 MSF)\nInteractive Computing 3 + (1 DM) + (2 GIT) + (1 AR) + (1 FPL)\nPlatforms\nSPD-SEP Included in SEP hours\nTotal 4\nNote: The CS Core hours total includes 1 hour shared with SE.\nKnowledge Units"
    }
  },
  {
    "title": "SPD-Common: Common Aspects/Shared Concerns",
    "CS Core": "1. Overview of development platforms (i.e., web, mobile, game, robotics, embedded, and interactive).\na. Input/sensors/control devices/haptic devices\nb. Resource constraints\ni. Computational\nii. Data storage\niii. Memory\niv. Communication\nc. Requirements – security, uptime availability, fault tolerance (See also: SE-Reliability, SEC-\nEngineering)\nd. Output/actuators/haptic devices\n2. Programming via platform-specific Application Programming Interface (API) vs traditional\napplication construction\n3. Overview of platform Languages (e.g., Python, Swift, Lua, Kotlin)\n4. Programming under platform constraints and requirements (e.g., available development tools,\ndevelopment, security considerations) (See also: SEC-Foundations)\n5. Techniques for learning and mastering a platform-specific programming language",
    "Illustrative Learning Outcomes": {
      "CS Core": "1. List the constraints of mobile programming.\n2. List the characteristics of scripting languages.\n3. Describe the three-tier model of web programming.\n302\n4. Describe how the state is maintained in web programming."
    }
  },
  {
    "title": "SPD-Web: Web Platforms",
    "KA Core": "1. Web programming languages (e.g., HTML5, JavaScript, PHP, CSS)\n2. Web platforms, frameworks, or meta-frameworks\na. Cloud services\nb. API, Web Components\n3. Software as a Service (SaaS)\n4. Web standards such as document object model, accessibility (See also: HCI-Accessibility)\n5. Security and Privacy Considerations (See also: SEP-Security)",
    "Non-core": "6. Analyzing requirements for web applications\n7. Computing services (See also: DM-NoSQL)\na. Cloud Hosting\nb. Scalability (e.g., Autoscaling, Clusters)\nc. Cost estimation for services\n8. Data management (See also: DM-Core)\na. Data residency: where the data is located and what paths can be taken to access it\nb. Data integrity: guaranteeing data is accessible and that data is deleted when required\n9. Architecture\na. Monoliths vs Microservices\nb. Micro-frontends\nc. Event-Driven vs RESTful architectures: advantages and disadvantages\nd. Serverless, cloud computing on demand\n10. Storage solutions (See also: DM-Relational, DM-NoSQL)\na. Relational Databases\nb. NoSQL databases",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Design and implement a web-based application using a microservice architecture design.\n2. Describe the constraints, such as hosting, services, and scalability, related to web platforms.\n3. Compare and contrast web programming with general-purpose programming.\n4. Describe the differences between Software-as-a-Service (SaaS) and traditional software products.\n5. Discuss how web standards impact software development.\n6. Evaluate an existing web application against current web standards."
    }
  },
  {
    "title": "SPD-Mobile: Mobile Platforms",
    "KA Core": "1. Development with\na. Mobile programming languages\n303\nb. Mobile programming environments\n2. Mobile platform constraints\na. User interface design (See also: HCI-User)\nb. Security\n3. Access\na. Accessing data through APIs (See also: DM-Querying)\nb. Designing API endpoints for mobile apps: pitfalls and design considerations\nc. Network and web interfaces (See also: NC-Fundamentals, DM-Modeling)",
    "Non-core": "4. Development\na. Native versus cross-platform development\nb. Software design/architecture patterns for mobile applications (See also: SE-Design)\n5. Mobile platform constraints\na. Responsive user interface design (See also: HCI-Accessibility)\nb. Heterogeneity and mobility of devices\nc. Differences in user experiences (e.g., between mobile and web-based applications)\nd. Power and performance tradeoff\n6. Mobile computing affordances\na. Location-aware applications\nb. Sensor-driven computing (e.g., gyroscope, accelerometer, health data from a watch)\nc. Telephony and instant messaging\nd. Augmented reality (See also: GIT-Immersion)\n7. Specification and testing (See also: SDF-Practices, SE-Validation)\n8. Asynchronous computing (See also: PDC-Algorithms)\na. Difference from traditional synchronous programming\nb. Handling success via callbacks\nc. Handling errors asynchronously\nd. Testing asynchronous code and typical problems in testing",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Compare mobile programming with general-purpose programming.\n2. Develop a location-aware mobile application with data API integration.\n3. Build a sensor-driven mobile application capable of logging data on a remote server.\n4. Create a communication app incorporating telephony and instant messaging.\n5. Evaluate the pros and cons of native and cross-platform mobile application development."
    }
  },
  {
    "title": "SPD-Robot: Robot Platforms",
    "KA Core": "1. Types of robotic platforms and devices (See also: AI-Robotics)\n2. Sensors, embedded computation, and effectors (actuators) (See also: GIT-Physical)\n3. Robot-specific languages and libraries (See also: AI-Robotics)\n4. Robotic software architecture (e.g., using the Robot Operating System (ROS))\n304\n5. Robotic platform constraints and design considerations (See also: AI-Robotics)\n6. Interconnections with physical or simulated systems (See also: GIT-Physical, GIT-Simulation)\n7. Robotic Algorithms (See also: AI-Robotics, GIT-Animation)\na. Forward kinematics\nb. Inverse kinematics\nc. Dynamics\nd. Navigation and path planning\ne. Grasping and manipulation\n8. Safety and interaction considerations (See also: SEP-Professional-Ethics, SEP-Context)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Design and implement an application on a given robotic platform.\n2. Integrate an Arduino-based robot kit and program it to navigate a maze.\n3. Compare robot-specific languages and techniques with those used for general-purpose software\ndevelopment.\n4. Explain the rationale behind the design of the robotic platform and its interconnections with physical\nor simulated systems.\n5. Given a high-level application, design a robot software architecture using ROS specifying all\ncomponents and interconnections (ROS topics) to accomplish that application.\n6. Discuss the constraints a given robotic platform imposes on developers."
    }
  },
  {
    "title": "SPD-Embedded: Embedded Platforms",
    "KA Core": "1. Introduction to the unique characteristics of embedded systems\na. Real-time vs soft real-time and non-real-time systems\nb. Resource constraints, such as memory profiles and deadlines (See also: AR-Memory)\n2. API for custom architectures\na. GPU technology (See also: AR-Heterogeneity, GIT-Shading)\nb. Field Programmable Gate Arrays (FPGA) (See also: AR-Logic)\nc. Cross-platform systems\n3. Embedded Systems\na. Microcontrollers\nb. Interrupts and feedback\nc. Interrupt handlers in high-level languages (See also: SF-Overview)\nd. Hard and soft interrupts and trap-exits (See also: OS-Principles)\ne. Interacting with hardware, actuators, and sensors\nf. Energy efficiency\ng. Loosely timed coding and synchronization\nh. Software adapters\n4. Embedded programming\n5. Hard real-time systems vs soft real-time systems (See also: OS-Real-time)\na. Timeliness\nb. Time synchronization/scheduling\n305\nc. Prioritization\nd. Latency\ne. Compute jitter\n6. Real-time resource management\n7. Memory management\na. Mapping programming construct (variable) to a memory location (See also: AR-Memory)\nb. Shared memory (See also: OS-Memory)\nc. Manual memory management.\nd. Garbage collection (See also: FPL-Translation)\n8. Safety considerations and safety analysis (See also: SEP-Context, SEP-Professional-Ethics)\n9. Sensors and actuators\n10. Analysis and verification\n11. Application design",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Design and implement a small embedded system for a given platform (e.g., a smart alarm clock or a\ndrone).\n2. Describe the unique characteristics of embedded systems versus other systems.\n3. Interface with sensors/actuators.\n4. Debug a problem with an existing embedded platform.\n5. Identify different types of embedded architectures.\n6. Evaluate which architecture is best for a given set of requirements.\n7. Design and develop software to interact with and control hardware.\n8. Design methods for real-time systems.\n9. Evaluate real-time scheduling and schedulability analysis.\n10. Evaluate formal specification and verification of timing constraints and properties."
    }
  },
  {
    "title": "SPD-Game: Game Platforms",
    "KA Core": "1. Historical and contemporary platforms for games (See also: AR-Logic)\na. Evolution of Game Platforms (e.g., Brown Box to Metaverse and beyond; Improvement in\nComputing Architectures (CPU and GPU); Platform Convergence and Mobility)\nb. Typical Game Platforms (e.g., Personal Computer; Home Console; Handheld Console;\nArcade Machine; Interactive Television; Mobile Phone; Tablet; Integrated Head-Mounted\nDisplay; Immersive Installations and Simulators; Internet of Things enabled Devices; CAVE\nSystems; Web Browsers; Cloud-based Streaming Systems)\nc. Characteristics and Constraints of Different Game Platforms (e.g., Features (local storage,\ninternetworking, peripherals); Run-time performance (GPU/CPU frequency, number of\ncores); Chipsets (physics processing units, vector co-processors); Expansion Bandwidth\n(PCIe); Network throughput (Ethernet); Memory types and capacities (DDR/GDDR);\nMaximum stack depth; Power consumption; Thermal design; Endian)\nd. Typical Sensors, Controllers, and Actuators (e.g., distinctive control system designs –\nperipherals (mouse, keypad, joystick), game controllers, wearables, interactive surfaces;\n306\nelectronics and bespoke hardware; computer vision, inside-out tracking, and outside-in\ntracking; IoT-enabled electronics and I/O (See also: GIT-Interaction)\ne. eSports Ecosystems (e.g., evolution of gameplay across platforms; games and eSports;\ngame events such as LAN/arcade tournaments and international events such as the\nOlympic eSports Series; streamed media and spectatorship; multimedia technologies and\nbroadcast management; professional play; data and machine learning for coaching and\ntraining)\n2. Real-time Simulation and Rendering Systems\na. CPU and GPU architectures (e.g., Flynn’s taxonomy; parallelization; instruction sets;\nstandard components – graphics compute array, graphics memory controller, video graphics\narray basic input/output system; bus interface; power management unit; video processing\nunit; display interface) (See also: AR-Heterogeneity)\nb. Pipelines for physical simulations and graphical rendering: (e.g., tile-based, immediate-\nmode). (See also: GIT-Rendering)\nc. Common Contexts for Algorithms, Data Structures, and Mathematical Functions (e.g., game\nloops; spatial partitioning, viewport culling, and level of detail; collision detection and\nresolution; physical simulation; behavior for intelligent agents; procedural content\ngeneration) (See also: MSF-Discrete, AL-Foundational)\nd. Media representations (e.g., I/O, and computation techniques for virtual worlds: audio;\nmusic; sprites; models and textures; text; dialogue; multimedia (e.g., olfaction, tactile) (See\nalso: GIT-Fundamentals)\n3. Game Development Tools and Techniques\na. Programming Languages (e.g., C++; C#; Lua; Python; JavaScript)\nb. Shader Languages (e.g., HLSL, GLSL; Shader Graph)\nc. Graphics Libraries and APIs (e.g., DirectX; SDL; OpenGL; Metal; Vulkan; WebGL). (See\nalso: GIT-Rendering, HCI-Design)\nd. Common Development Tools and Environments (e.g., IDEs; Debuggers; Profilers; Version\nControl Systems including those handling binary assets; Development Kits and\nProduction/Consumer Kits; Emulators) (See also: SDF-Practices, SE-Tools)\n4. Game Engines\na. Open Game Engines (e.g., Unreal; Unity; Godot; CryEngine; Phyre; Source 2; Pygame and\nRen’Py; Phaser; Twine; Spring RTS)\nb. Techniques (e.g., Ideation, Prototyping, Iterative Design and Implementation, Compiling\nExecutable Builds, Development Operations and Quality Assurance – Play Testing and\nTechnical Testing, Profiling; Optimization, Porting; Internationalization and Localization,\nNetworking) (See also: AR-Performance-Energy, SE-Requirements)\n5. Game Design\na. Vocabulary (e.g., game definitions; mechanics-dynamics-aesthetics model; industry\nterminology; experience design; models of experience and emotion)\nb. Design Thinking and User-Centered Experience Design (e.g., methods of designing games;\niteration, incrementing, and the double-diamond; phases of pre- and post-production; quality\nassurance, including alpha and beta testing; stakeholder and customer involvement;\ncommunity management) (See also: SE-Design)\n307\nc. Genres (e.g., adventure; walking simulator; first-person shooter; real-time strategy;\nmultiplayer online battle arena (MOBA); role-playing game (rpg))\nd. Audiences and Player Taxonomies (e.g., people who play games; diversity and broadening\nparticipation; pleasures, player types, and preferences; Bartle, yee) (See also: HCI-User)\ne. Proliferation of digital game technologies to domains beyond entertainment (e.g., Education\nand Training; Serious Games; Virtual Production; eSports; Gamification; Immersive\nExperience Design; Creative Industry Practice; Artistic Practice; Procedural Rhetoric) (See\nalso: AI-SEP)",
    "Illustrative Learning Outcomes": {
      "KA Core": "1. Recall the characteristics of common general-purpose graphics processing architectures.\n2. Identify the key stages of the immediate-mode rendering pipeline.\n3. Describe the key constraints a specific game platform will likely impose on developers.\n4. Explain how eSports are streamed to large audiences over the internet.\n5. Translate complex mathematical functions into performant source code.\n6. Use an industry-standard graphics API to render a 3D model in a virtual scene.\n7. Modify a shader to change a visual effect according to stated requirements.\n8. Implement a game for a particular platform according to the specification.\n9. Optimize a function for processing collision detection in a simulated environment.\n10. Assess a game's run-time and memory performance using an industry-standard tool and\ndevelopment environment.\n11. Compare the interfaces of different game platforms, highlighting their respective implications for\nhuman-computer interaction.\n12. Recommend an appropriate set of development tools and techniques for implementing a game of a\nparticular genre for a given platform.\n13. Discuss the key challenges in making a digital game that is cross-platform compatible.\n14. Express how game developers can enhance the accessibility of a game interface.\n15. Create novel forms of gameplay using frontier game platforms."
    }
  },
  {
    "title": "SPD-Interactive: Interactive Computing Platforms",
    "Non-core": "1. Data Analysis Platforms\na. Jupyter notebooks; Google Colab; R; SPSS; Observable.\nb. Cloud SQL/data analysis platforms (e.g., BigQuery) (See also: DM-Querying)\ni. Apache Spark\nii. Data Visualizations (See also: GIT-Visualization)\nc. Interactive presentations backed by data\nd. Design tools requiring low-latency feedback loops\ni. Rendering tools\nii. Graphic design tools\n2. Prompt programming\na. Generative AI (e.g., OpenAI’s ChatGPT, OpenAI’s Codex, GitHub’s Copilot) and LLMs are\naccessed/interacted\n308\n3. Quantum Platforms (See also: AR-Quantum)\na. Program quantum logic operators in quantum machines.\nb. Use API for available quantum services\nc. Signal analysis/Fourier analysis/Signal processing (for music composition, audio/RF\nanalysis) (See also: GIT-Image)",
    "Illustrative Learning Outcomes": {
      "Non-core": "1. Understand and uphold ethical responsibilities for safeguarding user privacy and data protection in\nmobile applications.\n2. Design mobile applications with accessibility in mind, ensuring effective use by people with\ndisabilities.\n3. Demonstrate proficiency in secure coding practices to mitigate risks associated with various security\nthreats in mobile development.\n4. Analyze the broader social impacts of mobile technology, including its influence on communication\npatterns, relationships, and mental health.\n5. Comprehend the ethical considerations of using AI in mobile applications, ensuring unbiased and\nfair algorithms.\n309"
    }
  },
  {
    "title": "SPD-SEP/Web",
    "Non-core": "1. Privacy concerns with mobile apps\n2. Designing for inclusivity and accessibility\n3. Ethical use of AI in mobile apps\n4. Sustainable app development and server hosting\n5. Avoiding spam or intrusive notifications\n6. Addressing cyberbullying and harassment\n7. Promoting positive online communities\n8. Monetization and advertising\n9. Ethical use of gamification",
    "Illustrative Learning Outcomes": {
      "Non-core": "1. Indicate a framework for accountability in AI model deployment, including clear documentation and\nattribution.\n2. Discuss ethical codes of conduct and professional standards relevant to prompt programming and\nAI development.\n3. Create communication plans and materials to educate the public about AI capabilities, limitations,\nand ethical safeguards.\nProfessional Dispositions\n● Self-Directed: Students should be able to learn new platforms and languages with a growth-\noriented mindset and thrive in dynamic environments, while continually enhancing skills.\n● Inventive: Students should demonstrate excellence in designing software architecture within\nunconventional constraints, emphasizing adaptability and creative problem-solving for innovative\nsolutions.\n● Adaptable: Students should adapt to diverse challenges, showing resilience, open-mindedness,\nand a proactive approach to changing requirements and constraints.\nMathematics Requirements\nRequired:\n● MSF-Discrete\nDesired:\n312\n● MSF-Calculus\n● MSF-Linear\n● MSF-Statistics\nCourse Packaging Suggestions\nIntroduction to Special Platform Development Course to include the following:\n● SPD-Common (10 hours)\n● SPD-Web (4 hours)\n● SPD-Mobile (4 hours)\n● SPD-SEP/Robotics (3 hours)\n● SPD-Embedded (3 hours)\n● SPD-Game (4 hours)\n● SPD-SEP/Interactive (2 hours)\n● SEP-Context (2 hours)\n● SDF-Practices (4 hours)\n● SE-Design (2 hours)\n● FPL-Scripting (2 hours)\nCourse objectives: Students should be able to grasp common aspects of platform development,\nacquire foundational knowledge in web development, and attain proficiency in web techniques. They\nwill apply comprehensive mobile development skills and explore challenges in robotics platforms.\n313\nExpertise in developing platforms for embedded systems, along with skills in game development and\ncreating interactive platforms, will be developed. Students will analyze societal, ethical, and\nprofessional implications of platform development, fostering a well-rounded understanding of this field\nwithin a concise curriculum.\nMobile Development Course to include the following:\n● SPD-Common: Common Aspects (3 hours)\n● SPD-Mobile (25 hours)\n● SDF-Practices: Software Development Practices (2 hours)\n● SE-Design: Software Design (3 hours)\n● SE-Construction: Software Construction (2 hours)\n● SPD-SEP/Mobile (3 hours)\nCourse objectives: Students should be able to design, develop, and deploy cross-platform mobile\napplications using languages like Java, Kotlin, Swift, or React Native. Proficiency in implementing user\nexperience best practices, exploring cross-platform development tools, and utilizing platform-specific\nAPIs for seamless integration is emphasized. The course covers security vulnerability identification,\ntesting methodologies, and distribution/versioning of mobile applications. Students gain insights into\nuser behavior and application performance through analytics tools. Additionally, they learn version\ncontrol, release management, and ethical considerations relevant to mobile development, providing a\nwell-rounded skill set for successful and responsible mobile application development across diverse\nplatforms.\nWeb Development Course to include the following:\n● SPD-Web (19 hours)\n● FPL-OOP (3 hours)\n● SE-Construction (2 hours)\n● DM-Querying (2 hours)\n● SE-Tools (4 hours)\n● SDF-Practices (4 hours)\n● SE-Design (2 hours)\n● FPL-Scripting (2 hours)\n● SPD-SEP/Web (2 hours)\nCourse objectives: Students should be able to gain expertise in designing, developing, and deploying\nmodern web applications. The curriculum covers key concepts, ensuring proficiency in HTML, CSS,\nand JavaScript for responsive and visually appealing pages. Students explore and implement frontend\nframeworks (e.g., React, Angular) for efficient development, understand server-side languages (e.g.,\nNode.js, Python) for dynamic applications, and design effective architectures prioritizing scalability and\nsecurity. They learn version control (e.g., GIT), integrate APIs for enhanced functionality, implement\nresponsive design, optimize for performance, and ensure security through best practices. Testing,\ndebugging, accessibility, deployment, and staying current with industry trends are also emphasized.\nGame Development Course to include the following:\n314\n● SPD-Game (16 hours)\n● SPD-SEP/Game (4 hours)\n● SDF-Practices (4 hours)\n● GIT-Interaction (1 hour)\n● HCI-Design (3 hours)\n● HCI-User (1 hour)\n● SE-Tools (1 hour)\n● AL-Foundational (2 hours)\n● GIT-Rendering (4 hours)\n● SE-Design (4 hours)\nCourse objectives: Students should be able to master designing, developing, and deploying\ninteractive games. The curriculum covers fundamental game design principles, proficiency in languages\nlike C++, C#, or Python, and utilization of popular engines such as Unity or Unreal. Students gain 3D\nmodeling and animation skills, implement physics and simulations for realism, and create AI algorithms\nfor intelligent non-player characters. They design multiplatform games, optimize UI/UX for engagement,\napply game-specific testing and debugging techniques, integrate audio effectively, and explore industry\nmonetization models. The course emphasizes ethical considerations, ensuring students analyze and\naddress content, diversity, and inclusivity in game development.\nCommittee\nChair: Christian Servin, El Paso Community College, El Paso, TX, USA\nMembers:\n● Sherif G. Aly, The American University in Cairo, Cairo, Egypt\n● Yoonsik Cheon, The University of Texas at El Paso, El Paso, TX, USA\n● Eric Eaton, University of Pennsylvania, Philadelphia, PA, USA\n● Claudia L. Guevara, Jochen Schweizer mydays Holding GmbH, Munich, Germany\n● Larry Heimann, Carnegie Mellon University, Pittsburgh, PA, USA\n● Amruth N. Kumar, Ramapo College of New Jersey, Mahwah, NJ, USA\n● R. Tyler Pirtle, Google, USA\n● Michael James Scott, Falmouth University, Falmouth, Cornwall, UK\nContributors:\n● Sean R. Piotrowski, Rider University, Lawrenceville, NJ, USA\n● Mark O’Neil, Blackboard Inc., Newport, NH, USA\n● John DiGennaro, Qwickly, Cleveland, OH, USA\n● Rory K. Summerley, London South Bank University, London, England, UK\n315\n316\nCore Topics Table\nIn the following seventeen tables, CS and KA core topics have been listed, one table per knowledge\narea. For each topic, desired skill levels have been identified and used to estimate the time needed for\nthe instruction of CS Core and KA Core topics. The skill levels should be treated as recommended, not\nprescriptive. The time needed to cover CS Core and KA Core topics is expressed in terms of\ninstructional hours. Instructional hours are hours spent in the classroom imparting knowledge\nregardless of the pedagogy used. Students are expected to spend additional time after class practicing\nrelated skills and exercising professional dispositions.\nFor convenience, the tables have been listed under three competency areas: Software, Systems, and\nApplications. The tables on Society, Ethics, and the Profession (SEP) and Mathematical and Statistical\nFoundations (MSF) are listed last as crosscutting topics that apply to all the competency areas.\nSoftware Competency Area\nThe core topics in Software Development Fundamentals (SDF) and Algorithmic Foundations (AL)\ntypically constitute the introductory course sequence in computer science and have been listed first.\nKnowledge Area Knowledge Units CS Core KA Core\nSDF Software Development Fundamentals 5 43\nAL Algorithmic Foundations 5 32 32\nFPL Foundations of Programming Languages 22 21 19\nSE Software Engineering 9 6 21\nTotal 102 72\nSDF: Software Development Fundamentals\nKU Topic Skill Level Core Hours\nSDF- 1. Basic concepts such as variables, primitive Develop CS 18\nFundamentals data types, and expression evaluation\n2. How imperative programs work: state and\nstate transitions on execution of statements,\nflow of control\n3. Basic constructs such as assignment\nstatements, conditional and iterative\n317\nstatements, basic I/O\n4. Key modularity constructs such as functions\nand related concepts like parameter passing,\nscope, abstraction, data encapsulation, etc.\n5. Input and output using files and APIs\n6. Structured data types available in the chosen\nprogramming language like sequences,\nassociative containers, others and when and\nhow to use them\n7. Libraries and frameworks provided by the\nlanguage (when/where applicable)\n8. Recursion\nSDF- 9. Dealing with runtime errors in programs Evaluate CS 2\nFundamentals 10. Basic concepts of programming errors, testing, Apply\nand debugging\n11. Documenting/commenting code at the\nprogram and module level\nSDF-Data- Standard abstract data types such as lists, stacks, Develop CS 10\nStructures queues, sets, and maps/dictionaries and\noperations on the data types\n4. Strings and string processing\nSDF-Data- Selecting and using appropriate data structures Evaluate CS 2\nStructures Performance implications of choice of data\nstructure(s)\nSDF-Algorithms Concept of algorithm and notion of algorithm Explain CS 6\nefficiency\nSome common algorithms (e.g., sorting,\nsearching, tree traversal, graph traversal)\nImpact of algorithms on time/space efficiency of\nprograms\nSDF-Practices Basic testing including test case design Develop CS 3\nSpecifying functionality of a module in a natural\nlanguage\nSDF-Practices 3. Programming style that improves readability Evaluate CS 1\nSDF-Practices Use of a general-purpose IDE, including its Apply CS 1\ndebugger\n318\nAL: Algorithmic Foundations\nKU Topic Skill Level Core Hours\nAL- 2. Arrays CS 1\nFoundational 1. Abstract Data Types and Operations\nAL- 2b i. Foundational Complexity Classes: Constant\nComplexity\nAL- 11a. Search Algorithms O(n) (e.g., linear array Apply CS 1\nFoundational search)\nAL- 2b iii. Foundational Complexity Classes: Linear Evaluate\nComplexity 1a. Brute Force Explain\nAL-\nStrategies\nAL- 12a. Sorting O(n2), (e.g., selection sort of an array) Apply CS 1\nFoundational 2b v. Foundational Complexity classes: Quadratic Evaluate\nAL- 1a. Brute Force Explain\nComplexity\nAL-\nStrategies\nAL- 11b. Search O(log n), (e.g., Binary search of an Apply CS 1\n2\nFoundational array)\nAL- 2b ii. Foundational Complexity Classes: Logarithmic Evaluate\nComplexity 1b ii. Decrease-and-Conquer Explain\nAL-Strategies\nAL- 12b. Sorting O(n log n), (e.g., Quick, Merge, Tim) Apply CS 1\nFoundational 2b iv. Foundational Complexity Classes: Log Linear Evaluate\nAL- 1c. Divide-and-Conquer Explain\nComplexity\nAL-Strategies\nAL- 4. Linked Lists Explain CS 1\nFoundational 1. Abstract Data Types and Operations Apply\nAL- 11a. Search O(n), (e.g., linear linked list search) Apply\nComplexity 2b iii. Foundational Complexity Classes: Linear Evaluate\nAL-Strategies 1a. Brute Force Explain\nAL- 5. Stacks Explain, CS 1\nFoundational 1. Abstract Data Types and Operations Apply\nAL- 2b i. Foundational complexity classes: Constant\nComplexity 6. Queues and Deques Explain,\nAL- 1. Abstract Data Types and Operations Apply\n319\nFoundational\nAL- 7. Hash Tables/Maps Explain CS 1\nFoundational 7a. Collision resolution and complexity Explain\nAL- 1. Abstract Data Types and Operations Apply\nComplexity 2b i. Foundational complexity classes: Constant Explain\nAL-Strategies 1f. Time vs Space tradeoff Explain 1\nAL- 9. Trees Explain CS 1\nFoundational 1. Abstract Data Types and Operations Apply\n11c. Search Algorithms DFS/BFS Apply\nAL-Strategies 2b. Decrease-and-Conquer Explain\nAL- 9b. Balanced Trees (e.g., AVL, 2-3, Red-Black, Apply 3\nFoundational Heap) Explain\nAL-Strategies 1e ii. Transform-and-Conquer: Representation\nChange (e.g., heapsort)\nAL- 8. Graphs (e.g., [un]directed, [a]cyclic, [un]connected, Explain CS 1\nFoundational [un]weighted)\n8a. Representation: Adjacency List vs Matrix Apply\nAL- 13. Graph Algorithms\nFoundational 13a. Shortest Path (e.g., Dijkstra’s, Floyd’s) Apply 4\n13b. Minimal, spanning tree (e.g., Prim’s,\nKruskal’s)\nAL-Strategies 1d. Greedy\n1e. iv. Dynamic Programming Explain\nAL- 1. Abstract Data Types and Operations Explain CS 1\nFoundational 3. Records/Structures/Tuples and Objects\n10. Sets\nAL-Strategies 1. Paradigms (demonstrated in AL-Foundational) Explain CS 3\n1a. Brute-Force\n1b. Decrease-and-Conquer\n1c. Divide-and-Conquer\n1f. Time-Space Tradeoff\n3. Iteration vs Recursion\nAL-Strategies 1e. Transform-and-Conquer Explain 1\n1e i. Instance Simplification (e.g., pre-sorting)\n1e iii. Problem Reduction (e.g.,\nleast-common-multiple)\nAL-Strategies 2. Handling Exponential Growth Explain 1\n(e.g., heuristic A*, backtracking, ranch-and-bound\nAL-Strategies 1e iv. Dynamic Programming Explain 1\n320\n(e.g., Bellman-Ford, Knapsack, Floyd,\nWarshall)\nAL- 1. Complexity Analysis Framework Explain CS 1\nComplexity 2. Asymptotic Complexity Analysis Explain\n2a. Big O, Big Omega, and Big Theta\n2b. Foundational complexity classes\ndemonstrated by AL-Foundational algorithms (with E v a luate 1\ncomplexity): Constant, Logarithmic, Linear, Log\nLinear, Quadratic, and Cubic\nAL- 4. Tractability and Intractability Explain 2\nComplexity 4a. P, NP, and NP-C complexity classes\n4b. NP-Complete Problems\n(e.g., SAT, Knapsack, TSP)\n4c. Reductions\n1a. Paradigms: Exhaustive brute force Explain 1\nAL-Strategies 1e. iv. Dynamic Programming\n2 vii. Foundational Complexity Classes: Exponential E xplain 1\nAL- 2b viii. Factorial complexity classes: Factorial O(n!)\nComplexity (e.g. All Permutations, Hamiltonian Circuit)\nAL-Models 1. Formal Automata Explain, CS 1\n1a. Finite State Automata Apply\n2a. Regular language, grammar, and expressions\n1b. Pushdown Automata Explain, 1\n2b. Context-Free language and grammar Apply\n1d. Turing Machine Explain 3\n2d. Recursively Enumerable language and Explain\ngrammar\n1c. Linear-Bounded\n2c. Context-Sensitive language and grammar 1\n2. Formal Languages and Grammars Explain 2\n4. Decidability, Computability, Halting problem Explain\n5. The Church-Turing Thesis Explain 1\n6. Algorithmic Correctness\nInvariants (e.g., in iteration, recursion, sorting, Explain\nheaps)\nAL-SEP 1. Social, Ethical, and Secure Algorithms Explain CS In\n2. Algorithmic Fairness (e.g., differential privacy) SEP\n3. Accountability/Transparency Hours\n4. Responsible algorithms\n5. Economic and other impacts of algorithms\n6. Sustainability\n321\nFPL: Foundations of Programming Languages\nKU Topic Skill Core Hours\nLevel\nFPL-OOP 1. Imperative programming as a subset of object- Develop CS 1. 5\noriented programming\n2. Object-oriented design\na. Decomposition into objects carrying state and\nhaving behavior\nb. Class-hierarchy design for modeling\n3. Definition of classes: fields, methods, and\nconstructors\n4. Subclasses, inheritance (including multiple\ninheritance), and method overriding\n5. Dynamic dispatch – definition of method-call\n6. Exception handling\n7. Object-oriented idioms for encapsulation\na. Privacy, data hiding, and visibility of class\nmembers\nb. Interfaces revealing only method signatures\nc. Abstract base classes, traits and mixins\n8. Dynamic vs static properties\n9. Composition vs inheritance\n10. Subtyping\na. Subtype polymorphism; implicit upcasts in typed\nlanguages\nb. Notion of behavioral replacement – subtypes\nacting like supertype\nc. Relationship between subtyping and inheritance\n11. Collection classes, iterators, and other common Develop KA 1\nlibrary components\n12. Metaprogramming and reflection\nFPL- 1. Lambda expressions and evaluation Develop CS 4\nFunctional a. Variable binding and scope rules\nb. Parameter-passing\nc. Nested lambda expressions and reduction order\n2. Effect-free programming\na. Function calls have no side effects, facilitating\ncompositional reasoning.\nb. Immutable variables and data copying vs\nreduction\n322\nc. Use of recursion vs loops vs pipelining\n(map/reduce)\n3. Processing structured data (e.g., trees) via functions\nwith cases for each data variant\na. Functions defined over compound data in terms\nof functions applied to the constituent pieces\nb. Persistent data structures\n4. Using higher-order functions (taking, returning, and\nstoring functions)\n5. Metaprogramming and reflection Explain KA 3\n6. Function closures (functions using variables in the\nenclosing lexical environment)\na. Basic meaning and definition – creating closures\nat run-time by capturing the environment\nb. Canonical idioms: call-backs, arguments to\niterators, reusable code via function arguments\nc. Using a closure to encapsulate data in its\nenvironment\nd. Delayed vs eager evaluation\nFPL-Logic 1. Universal vs existential quantifiers Explain KA 3\n2. First order predicate logic vs higher order logic\n3. Expressing complex relations using logical\nconnectives and simpler relations\n4. Definitions of Horn clause, facts, goals and subgoals\n5. Unification and unification algorithm; unification vs\nassertion vs expression evaluation\n6. Mixing relations with functions\n7. Cuts, backtracking, and non-determinism\n8. Closed-world vs open-world assumptions\nFPL- 1. Error/exception handling Develop CS 2\nScripting 2. Piping\n3. System commands\na. Interface with operating systems\n4. Environment variables\n5. File abstraction and operators\n6. Data structures, such as arrays and lists\n7. Regular expressions\n8. Programs and processes\n9. Workflow\nFPL-Event- 1. Procedural programming vs reactive programming – Develop CS 2\nDriven advantages of reactive programming in capturing\n323\nevents\n2. Components of reactive programming – event-\nsource, event signals, listeners and dispatchers,\nevent objects, adapters, event-handlers\n3. Stateless and state-transition models of event-based\nprogramming\n4. Canonical uses such as GUIs, mobile devices,\nrobots, servers\n5. Using a reactive framework Develop KA 2\na. Defining event handlers/listeners\nb. Parameterization of event senders and event\narguments\nc. Externally generated events and program-\ngenerated events\n6. Separation of model, view, and controller\n7. Event-driven and reactive programs as state-\ntransition systems\nFPL- 1. Safety and liveness Develop CS 3\nParallel a. Race conditions.\nb. Dependencies/preconditions\nc. Fault models\nd. Termination\n2. Programming models: One or more of the following\na. Actor models\nb. Procedural and reactive models\nc. Synchronous/asynchronous programming\nmodels\nd. Data parallelism\n3. Properties\na. Order-based properties\ni. Commutativity\nii. Independence\nb. Consistency-based properties\ni. Atomicity\nii. Consensus\n4. Execution control:\na. Async await\nb. Promises\nc. Threads\n5. Communication and coordination\na. Mutexes\nb. Message-passing\n324\nc. Shared memory\nd. Cobegin-coend\ne. Monitors\nf. Channels\ng. Threads\nh. Guards\n6. Futures Explain KA 2\n7. Language support for data parallelism such as forall,\nloop unrolling, map/reduce\n8. Effect of memory-consistency models on language\nsemantics and correct code generation\n9. Representational State Transfer Application\nProgramming Interfaces (REST APIs)\n10. Technologies and approaches: cloud computing,\nhigh performance computing, quantum computing,\nubiquitous computing\n11. Overheads of message-passing\n12. Granularity of program for efficient exploitation of\nconcurrency\n13. Concurrency and other programming paradigms\n(e.g., functional)\nFPL-Types 1. A type as a set of values together with a set of Develop CS 3\noperations\na. Primitive types (e.g., numbers, Booleans)\nb. Compound types built from other types (e.g.,\nrecords/structs, unions, arrays, lists, functions,\nreferences using set operations)\n2. Association of types to variables, arguments, results,\nand fields\n3. Type safety as an aspect of program correctness\n4. Type safety and errors caused by using values\ninconsistently given their intended types\n5. Goals and limitations of static and dynamic typing\na. Detecting and eliminating errors as early as\npossible\n6. Generic types (parametric polymorphism)\na. Definition and advantages of polymorphism –\nparametric, subtyping, overloading, and coercion\nb. Comparison of monomorphic and polymorphic\ntypes\nc. Comparison with ad-hoc polymorphism\n(overloading) and subtype polymorphism\n325\nd. Generic parameters and typing\ne. Use of generic libraries such as collections\nf. Comparison with ad hoc polymorphism\n(overloading) and subtype polymorphism\ng. Prescriptive vs descriptive polymorphism\nh. Implementation models of polymorphic types\ni. Subtyping\n7. Type equivalence – structural vs name equivalence Develop KA 4\n8. Complementary benefits of static and dynamic typing\na. Errors early vs errors late/avoided\nb. Enforce invariants during code development and\ncode maintenance vs postpone typing decisions\nwhile prototyping and conveniently allow flexible\ncoding patterns such as heterogeneous\ncollections\nc. Typing rules\ni. Rules for function, product, and sum types\nd. Avoid misuse of code vs allow more code reuse\ne. Detect incomplete programs vs allow incomplete\nprograms to run\nf. Relationship to static analysis\ng. Decidability\nFPL- 1. Data structures for translation, execution, translation, Develop CS 3\nSystems and code mobility such as stack, heap, aliasing\n(sharing using pointers), indexed sequence and\nstring\n2. Direct, indirect, and indexed access to memory\nlocation\n3. Run-time representation of data abstractions such as\nvariables, arrays, vectors, records, pointer-based\ndata elements such as linked-lists and trees, and\nobjects\n4. Abstract low-level machine with simple instruction,\nstack, and heap to explain translation and execution\n5. Run-time layout of memory: activation record (with\nvarious pointers), static data, call-stack, heap\na. Translating selection and iterative constructs to\ncontrol-flow diagrams\nb. Translating control-flow diagrams to low level\nabstract code\nc. Implementing loops, recursion, and tail calls\nd. Translating function/procedure calls and return\n326\nfrom calls, including different parameter-passing\nmechanisms using an abstract machine\n6. Memory management\na. Low level allocation and accessing of high-level\ndata structures such as basic data types, n-\ndimensional array, vector, record, and objects\nb. Return from procedure as automatic\ndeallocation mechanism for local data elements\nin the stack\nc. Manual memory management: allocating, de-\nallocating, and reusing heap memory\nd. Automated memory management – garbage\ncollection as an automated technique using the\nnotion of reachability\n7. Green computing\nFPL- 1. Execution models for JIT (Just-In-Time), compiler, Explain CS 2\nTranslation interpreter\n2. Use of intermediate code, e.g., bytecode.\n3. Limitations and benefits of JIT, compiler, and\ninterpreter\n4. Cross compilers/transpilers\n5. BNF and extended BNF representation of context-\nfree grammar\n6. Parse tree using a simple sentence such as\narithmetic expression or if-then-else statement\n7. Execution as native code or within a virtual machine\n8. Language translation pipeline – syntax analysis,\nparsing, optional type-checking, translation/code\ngeneration and optimization, linking, loading,\nexecution\n9. Run-time representation of core language Explain KA 2\nconstructs such as objects (method tables) and\nfunctions that can be passed as parameters to\nand returned from functions (closures)\n10. Secure compiler development\nFPL- 1. BNF and regular expressions Explain KA 3\nAbstraction 2. Programs that take (other) programs as input such\nas interpreters, compilers, type-checkers,\ndocumentation generators\n3. Components of a language\na. Definitions of alphabets, delimiters, sentences,\n327\nsyntax, and semantics\nb. Syntax vs semantics\n4. Program as a set of non-ambiguous meaningful\nsentences\n5. Basic programming abstractions – constants,\nvariables, declarations (including nested\ndeclarations), command, expression, assignment,\nselection, definite and indefinite iteration, iterators,\nfunction, procedure, modules, exception handling\n6. Mutable vs immutable variables: advantages and\ndisadvantages of reusing existing memory location\nvs advantages of copying and keeping old values;\nstoring partial computation vs recomputation\n7. Types of variables – static, local, nonlocal, global;\nneed and issues with nonlocal and global variables\n8. Scope rules – static vs dynamic; visibility of\nvariables; side-effects\n9. Side-effects induced by nonlocal variables, global\nvariables, and aliased variables\nSE: Software Engineering\nKU Topic Skill Core Hours\nLevel\nSE-Teamwork 1. Effective communication\n2. Common causes of team conflict, and approaches\nfor conflict resolution Evaluate CS 2\n3. Cooperative programming\n4. Roles and responsibilities in a software team\n5. Team processes\n6. Importance of team diversity and inclusion\nSE-Teamwork 7. Interfacing with stakeholders, as a team\n8. Risks associated with physical, distributed, hybrid Explain KA 2\nand virtual teams\nSE-Tools 1. Software configuration management and version Evaluate CS 1\ncontrol\nSE-Tools 2. Release management\n3. Testing tools including static and dynamic analysis\ntools\n328\n4. Software process automation Explain KA 3\n5. Design and communication tools (docs, diagrams,\ncommon forms of design diagrams like UML)\n6. Tool integration concepts and mechanisms\n7. Use of modern IDE facilities – debugging,\nrefactoring, searching/indexing, etc.\nSE- 1. Describe functional requirements using, for\nRequirements example, use cases or user stories\n2. Properties of requirements including consistency,\nvalidity, completeness, and feasibility Apply KA 2\n3. Requirements elicitation\n4. Non-functional requirements, for example, security,\nusability, or performance (aka Quality Attributes)\n5. Risk identification and management\n6. Communicating and/or formalizing requirement\nspecifications\nSE-Design 1. System design principles Explain CS 1\n2. Software architecture\n3. Programming in the large vs programming in the\nsmall\n4. Code smells and other indications of code quality,\ndistinct from correctness.\nSE-Design 5. API design principles Apply KA 4\n6. Identifying and codifying data invariants and time\ninvariants\n7. Structural and behavioral models of software\ndesigns\n8. Data design\n9. Requirement traceability\nSE- 1. Practical small-scale testing Apply CS 1\nConstruction 2. Documentation\nSE- 3. Coding Style Apply KA 3\nConstruction 4. “Best Practices” for coding\n5. Debugging\n6. Logging\n7. Use of libraries and frameworks developed by\nothers\nSE-Validation 1. Verification and validation concepts Explain CS 1\n2. Why testing matters\n329\n3. Testing objectives\n4. Test kinds\n5. Stylistic differences between tests and production\ncode\nSE-Validation 6. Test planning and generation Explain KA 4\n7. Test development (see SDF)\n8. Verification and validation in the development cycle\n9. Domain specific verification and validation\nchallenges\nSE- 1. Hyrum’s Law Explain KA 1\nRefactoring 2. Backward Compatibility\n3. Refactoring\n4. Versioning\nSE-Reliability 1. Concept of reliability Explain KA 4\n2. Identifying reliability requirements (see SEP)\n3. Software failures vs defect injection/detection\n4. Software reliability, system reliability and failure\nbehavior (cross-reference SF/Reliability Through\nRedundancy)\n5. Defect injection and removal cycle, and different\napproaches for defect removal\n6. Compare the “error budget” approach to reliability\nwith the “error-free” approach, and identify domains\nwhere each is relevant\nSystems Competency Area\nThe core topics in Architecture and Organization (AR) and Operating Systems (OS) are typically\ncovered early in the curriculum and have been listed first. Data Management (DM) and Security (SEC)\ntopics listed in this section can be applied to all three competency areas.\nKnowledge Area Knowledge Units CS Core KA Core\nAR Architecture and Organization 9 9 16\nOS Operating Systems 14 8 13\nNC Networking and Communication 8 7 24\n330\nPDC Parallel and Distributed Computing 5 9 26\nSF Systems Fundamentals 8 18 8\nDM Data Management 12 10 26\nSEC Security 6 6 35\nTotal 67 148\nAR: Architecture and Organization\nKU Topic Skill Core Hours\nLevel\n1. Combinational vs sequential logic/field Explain\nprogrammable gate arrays (FPGAs)\na. Fundamental combinational\nb. Sequential logic building block\n2. Computer-aided design tools that process Evaluate\nhardware and architectural representations\n3. High-level synthesis\nAR-Logic KA 3\na. Register transfer notation\nb. Hardware description language (e.g.,\nVerilog/VHDL/Chisel)\n4. System-on-chip (SoC) design flow\n5. Physical constraints\na. Gate delays\nb. Fan-in and fan-out\nc. Energy/power\nd. Speed of light\nAR- 1. Overview and history of computer architecture Apply CS 1\nRepresentatio 2. Bits, bytes, and words\nn 3. Unsigned, signed and two’s complement\nrepresentations\n4. Numeric data representation and number bases\na. Fixed-point\nb. Floating-point\n5. Representation of non-numeric data\n6. Representation of records, arrays and UTF data\ntypes\n331\nAR-Assembly 1. von Neumann machine architecture Explain CS 1\n2. Control unit: instruction fetch, decode, and\nexecution\n3. Introduction to SIMD vs MIMD and the Flynn\ntaxonomy\n4. Shared memory multiprocessors/multicore\norganization\nAR-Assembly 5. Instruction set architecture (ISA) (e.g., x86, ARM, Develop KA 2\nand RISC-V)\na. Instruction formats\nb. Data manipulation, control, I/O\nc. Addressing modes\nd. Machine language programming\ne. Assembly language programming\n6. Subroutine call and return mechanisms\n7. I/O and interrupts\n8. Heap, static, stack, and code segments\n1. Memory hierarchy: the importance of temporal and Explain\nspatial locality\n2. Main memory organization and operations\n3. Persistent memory (e.g., SSD, standard disks)\n4. Latency, cycle time, bandwidth, and interleaving\n7. Virtual memory (hardware support)\n8. Fault handling and reliability\n9. Reliability\nAR-Memory a. Error coding\nb. Data compression CS 6\nc. Data integrity\n10. In-Memory Processing (PIM)\n5. Cache memories Evaluate\na. Address mapping\nb. Block size\nc. Replacement and store policy\n6. Multiprocessor cache coherence\n1. I/O fundamentals Explain CS 1\na. Handshaking and buffering\nb. Programmed I/O\nc. Interrupt-driven I/O\n2. Interrupt structures: vectored and prioritized,\ninterrupt acknowledgment\n332\n3. I/O devices (e.g., mouse, keyboard, display,\nAR-IO camera, sensors, actuators)\n4. External storage, physical organization, and drives\n5. Bus fundamentals\na. Bus protocols\nb. Arbitration\nc. Direct-memory access (DMA)\n1. Implementation of simple datapaths, including Develop\ninstruction pipelining, hazard detection, and\nresolution\n2. Control unit\na. Hardwired implementation\nAR- b. Microprogrammed realization\nOrganization KA 2\n3. Instruction pipelining Explain\n4. Introduction to instruction-level parallelism (ILP)\nAR- 1. Performance-energy evaluation (introduction):\nPerformance- performance, power consumption, memory, and\nEnergy communication costs\n2. Branch prediction, speculative execution, out-of- Evaluate KA 2\norder execution, Tomasulo's algorithm\nAR- 3. Enhancements for vector processors and GPUs Explain KA 1\nPerformance- 4. Hardware support for multithreading\nEnergy a. Race conditions\nb. Lock implementations\nc. Point-to-point synchronization\nd. Barrier implementation\n5. Scalability\n6. Alternative architectures, such as VLIW/EPIC,\naccelerators, and other special-purpose processors\n7. Dynamic voltage and frequency scaling (DVFS)\n8. Dark Silicon\nAR- 1. SIMD and MIMD architectures (e.g., General- Explain KA 2\nHeterogeneity Purpose GPUs, TPUs, and NPUs)\n2. Heterogeneous memory system\na. Shared memory versus distributed memory\nb. Volatile vs non-volatile memory\nc. Coherence protocols\n3. Domain-Specific Architectures (DSAs)\na. Machine Learning Accelerator\n333\nb. In-networking computing\nc. Embedded systems for emerging\napplications\nd. Neuromorphic computing\ne. Edge computing devices\n4. Packaging and integration solutions such as 3DIC\nand chiplets\n5. Machine learning in architecture design\na. AI algorithms for workload analysis\nb. Optimization of architecture configurations\nfor performance and power efficiency\nAR-Security 1. Principles of Secure Hardware Explain KA 2\na. Security Risk Analysis, Asset Protection,\nand Threat Model\nb. Cryptographic Acceleration with Hardware\nc. Support for virtualization (e.g., OS isolation)\n2. Roots of trust in hardware, Physically\nUnclonable Functions (PUF)\n3. Hardware Random Number Generators\n4. Memory protection extensions\na. Runtime pointer bounds checking\n(e.g., buffer overflow)\nb. Protection at the microarchitectural\nlevel\nc. Protection at the ISA level\n5. Trusted Execution Environment (TEE)\na. Trusted Computer Base Protections\nb. Protecting virtual machines\nc. Protecting containers\nd. Trusted software modules (Enclaves)\nAR-Quantum 1. Principles Explain KA 2\na. The wave-particle duality principle\nb. The uncertainty principle in the double-slit\nexperiment\nc. What is a Qubit? Superposition and\nmeasurement; Photons as qubits\nd. Systems of two qubits; Entanglement; Bell\nstates; The No-Signaling theorem\n2. Axioms of QM: superposition principle,\nmeasurement axiom, unitary evolution\n3. Single qubit gates for the circuit model of quantum\ncomputation: X, Z, H.\n334\n4. Two qubit gates and tensor products; Working with\nmatrices\n5. The No-Cloning Theorem; The Quantum\nTeleportation protocol\n6. Algorithms\na. Simple quantum algorithms (Bernstein-\nVazirani, Simon’s algorithm)\nb. Implementing Deutsch-Josza with Mach-\nZehnder Interferometers\nc. Quantum factoring (Shor’s Algorithm)\nd. Quantum search (Grover’s Algorithm)\n7. Implementation aspects\na. The physical implementation of qubits\nb. Classical control of a Quantum Processing\nUnit (QPU)\nc. Error mitigation and control. NISQ and\nbeyond.\n8. Emerging Applications\na. Post-quantum encryption\nb. The Quantum Internet\nc. Adiabatic quantum computation (AQC) and\nquantum annealing\nOS: Operating Systems\nKU Topic Skill Core Hours\nLevel\n1. Operating system as mediator between general 2\nOS-Purpose Explain CS\npurpose hardware and application-specific software\n2. Universal operating system functions\n3. Extended and/or specialized operating system\nfunctions\n4. Design issues\n5. Influences of security, networking, multimedia,\nparallel and distributed computing\n6. Overarching concern of security/protection:\nNeglecting to consider security at every layer\ncreates an opportunity to inappropriately access\nresources.\nOS-Principles 1. Operating system software design and approaches CS 2\nExplain\n2. Abstractions, processes, and resources\n335\n3. Concept of system calls and links to application\nprogram interfaces\n4. The evolution of the link between hardware\narchitecture and the operating system functions\n5. Protection of resources means protecting some\nmachine instructions/functions\n6. Leveraging interrupts from hardware level: service\nroutines and implementations\n7. Concept of user/system state and protection,\ntransition to kernel mode using system calls\n8. Mechanism for invoking of system calls, the\ncorresponding mode and context switch and return\nfrom interrupt\n9. Performance costs of context switches and\nassociated cache flushes when performing process\nswitches in Spectre-mitigated environments\nOS- 1. Thread abstraction relative to concurrency Explain CS 2\nConcurrency 2. Race conditions, critical regions (role of interrupts if\nneeded)\n3. Deadlocks and starvation\n4. Multiprocessor issues (spin-locks, reentrancy)\n5. Multiprocess concurrency vs multithreading\n6. Thread creation, states, structures Apply KA 1\n7. Thread APIs\n8. Deadlocks and starvation (necessary\nconditions/mitigations)\n9. Implementing thread safe code (semaphores,\nmutex locks, cond vars)\n10. Race conditions in shared memory\nOS-Protection 1. Overview of operating system security mechanisms Apply CS 2\n2. Attacks and antagonism (scheduling, etc.)\n3. Review of major vulnerabilities in real operating\nsystems\n4. Operating systems mitigation strategies such as\nbackups\n5. Policy/mechanism separation Apply KA 1\n6. Security methods and devices\n7. Protection, access control, and authentication\nOS- 1. Preemptive and non-preemptive scheduling Explain KA 2\nScheduling 2. Schedulers and policies.\n336\n3. Concepts of Symmetric Multi-Processor (SMP)\nmultiprocessor scheduling and cache coherence\n4. Timers (e.g., building many timers out of finite\nhardware timers)\n5. Fairness and starvation\nOS-Process 1. Processes and threads relative to virtualization – Explain KA 2\nProtected memory, process state, memory\nisolation, etc.\n2. Memory footprint/segmentation (stack, heap, etc.)\n3. Creating and loading executables, shared libraries,\nand dynamic linking\n4. Dispatching and context switching\n5. Interprocess communication\nOS-Memory 1. Review of physical memory, address translation Explain KA 2\nand memory management hardware\n2. Impact of memory hierarchy including cache\nconcept, cache lookup, etc. on operating system\nmechanisms and policy\n3. Logical and physical addressing, address space\nvirtualization\n4. Concepts of paging, page replacement, thrashing\nand allocation of pages and frames\n5. Allocation/deallocation/storage techniques\n(algorithms and data structure) performance and\nflexibility\n6. Memory caching and cache coherence and the\neffect of flushing the cache to avoid speculative\nexecution vulnerabilities\n7. Security mechanisms and concepts in memory\nmanagement including sandboxing, protection,\nisolation, and relevant vectors of attack\nOS-Devices 1. Buffering strategies Explain KA 1\n2. Direct Memory Access and Polled I/O, Memory-\nmapped I/O\n3. Historical and contextual - Persistent storage\ndevice management (magnetic, SSD, etc.)\nOS-Files 1. Concept of a file including Data, Metadata, Explain KA 2\nOperations and Access-mode\n2. File system mounting\n3. File access control\n4. File sharing\n337\n5. Basic file allocation methods including linked,\nallocation table, etc.\n6. File system structures comprising file allocation\nincluding various directory structures and methods\nfor uniquely identifying files (name, identified or\nmetadata storage location)\n7. Allocation/deallocation/storage techniques\n(algorithms and data structure) impact on\nperformance and flexibility (i.e. Internal and\nexternal fragmentation and compaction)\n8. Free space management such as using bit tables\nvs linking\n9. Implementation of directories to segment and track\nfile location\nOS- 1. File systems: partitioning, mount/unmount, virtual Explain KA 1\nAdvanced- file systems\nFiles 2. In-depth implementation techniques\n3. Memory-mapped files\n4. Special-purpose file systems\n5. Naming, searching, access, backups\n6. Journaling and log-structured file systems\nOS- 1. Using virtualization and isolation to achieve Explain KA 1\nVirtualization protection and predictable performance\n2. Advanced paging and virtual memory\n3. Virtual file systems and virtual devices\n4. Containers and their comparison to virtual machine\n5. Thrashing\nOS-Real-time 1. Process and task scheduling KA 1\n2. Deadlines and real-time issues Explain\n3. Low-latency vs ”soft real-time\" vs \"hard real time\"\nOS-Faults 1. Reliable and available systems Explain KA 1\n2. Software and hardware approaches to address\ntolerance (RAID)\nOS-SEP 1. Open source in operating systems Explain KA -\n2. End-of-life issues with sunsetting operating\nsystems\n338\nNC: Networking and Communication\nKU Topic Skill Core Hours\nLevel\nNC- 1. Importance of networking in contemporary Explain\nFundamentals computing, and associated challenges\n2. Organization of the Internet Explain\na. Users\nb. Internet Service Providers\nc. Autonomous systems\nd. Content providers\ne. Content delivery networks\n3. Switching techniques Evaluate\na. Circuit Switching\nb. Packet Switching\n4. Layers and their roles Explain\na. Application\nCS 3\nb. Transport\nc. Network\nd. Datalink\ne. Physical\n5. Layering principles Explain\na. Encapsulation\nb. Hourglass model\n6. Network elements Explain\na. Routers\nb. Switches\nc. Hubs\nd. Access points\ne. Hosts\n7. Basic queueing concepts Explain\na. Relationship with latency\nb. Relationship with Congestion\nc. Relationship with Service levels\nNC- 1. Naming and address schemes. Explain\nApplications a. DNS\nb. IP addresses CS 4\n339\nc. Uniform Resource Identifiers\n2. Distributed application paradigms Evaluate\na. Client/server\nb. Peer-to-peer\nc. Cloud\nd. Edge\ne. Fog\n3. Diversity of networked application demands Explain\na. Latency\nb. Bandwidth\nc. Loss tolerance\n4. Application-layer development using one or more Develop\nprotocols:\na. HTTP\nb. SMTP\nc. POP3\n5. Interactions with TCP, UDP, and Socket APIs. Explain\nNC-Reliability 1. Unreliable delivery Explain\na. UDP\nb. Other\n2. Principles of reliability Develop\nKA 6\na. Delivery without loss\nb. Duplication\nc. Out of order\n3. Error control Evaluate\na. Retransmission\nb. Error correction\n4. Flow control Develop\na. Stop and wait\nb. Window based\n5. Congestion control Explain\na. Implicit congestion notification\nb. Explicit congestion notification\n6. TCP and performance issues Evaluate\na. Tahoe\nb. Reno\n340\nc. Vegas\nd. Cubic\ne. QUIC\nNC-Routing 1. Routing paradigms and hierarchy Evaluate\na. Intra/inter domain\nb. Centralized and decentralized\nc. Source routing KA 4\nd. Virtual circuits\ne. QoS\n2. Forwarding methods Apply\na. Forwarding tables\nb. Matching algorithms\n3. IP and Scalability issues Explain\na. NAT\nb. CIDR\nc. BGP\nd. Different versions of IP\nNC-SingleHop 1. Introduction to modulation, bandwidth, and Explain\ncommunication media KA 3\n2. Encoding and Framing. Evaluate\n3. Medium Access Control (MAC) Evaluate\na. Random access\nb. Scheduled access\n4. Ethernet Explain\n5. Switching Apply\n6. Local Area Network Topologies (e.g. data center Explain\nnetworks)\nNC-Security 1. General intro about security Explain\na. Threats\nb. Vulnerabilities\nc. Countermeasures KA 4\n2. Network specific threats and attack types Explain\na. Denial of service\nb. Spoofing\nc. Sniffing\n341\nd. Traffic redirection\ne. Attacker-in-the-middle\nf. Message integrity attacks\ng. Routing attacks\nh. Traffic analysis\n3. Countermeasures [Shared with Security] Explain\na. Cryptography (e.g., SSL,\nsymmetric/asymmetric).\nb. Architectures for secure networks (e.g.,\nsecure channels, secure routing protocols,\nsecure DNS, VPNs, DMZ, Zero Trust\nNetwork Access, hyper network security,\nanonymous communication protocols,\nisolation)\nc. Network monitoring, intrusion detection,\nfirewalls, spoofing and DoS protection,\nhoneypots, tracebacks, BGP Sec.\nNC-Mobility 1. Principles of cellular communication (e.g., 4G, Explain\n5G)\n2. Principles of Wireless LANs (mainly 802.11) Explain\nKA 3\n3. Device to device communication Explain\n4. Multihop wireless networks Explain\n5. Examples (e.g., ad hoc networks, opportunistic, Explain\ndelay tolerant)\nNC-Emerging 1. Middleboxes (e.g., filtering, deep packet Explain\ninspection, load balancing, NAT, CDN) KA 4\n2. Virtualization (e.g. SDN, Data Center Networks) Explain\n3. Quantum Networking (e.g. Intro to the domain, Explain\nteleportation, security, Quantum Internet)\nPDC: Parallel and Distributed Computing\nKU Topic Skill Core Hours\nLevel\n342\nPDC- 1. Parallelism Explain CS 2\nPrograms a. Declarative parallelism – determining which\nactions may, or must not, be performed in\nparallel, at the level of instructions, functions,\nclosures, composite actions, sessions, tasks,\nand services is the main idea underlying PDC\nalgorithms; failing to do so is the main source\nof errors.\nb. Defining order – for example, using happens-\nbefore relations or series/parallel directed\nacyclic graphs representing programs\nc. Independence – determining when ordering\ndoesn’t matter, in terms of commutativity,\ndependencies, preconditions\nd. Ensuring ordering among otherwise parallel\nactions when necessary, including locking,\nsafe publication; and imposing communication\n– sending a message happens before\nreceiving it; conversely relaxing when\nunnecessary\n2. Distribution\na. Defining places as devices executing actions,\nincluding hardware components, remote hosts,\nmay also include external, uncontrolled\ndevices, hosts, and users\nb. One device may time-slice or otherwise\nemulate multiple parallel actions by fewer\nprocessors by scheduling and virtualization.\nc. Naming or identifying places (e.g., device IDs)\nand actions as parties (e.g., thread IDs)\nd. Activities across places may communicate\nacross media\n3. Starting activities\na. Options that enable actions to be performed\n(eventually) at places range from hardwiring to\nconfiguration scripts; also establishing\ncommunication and resource management;\nthese are expressed differently across\nlanguages and contexts, usually relying on\nautomated provisioning and management by\nplatforms\nb. Procedural: Enabling multiple actions to start at\na given program point; for example, starting\n343\nnew threads, possibly scoping, or otherwise\norganizing them in hierarchical groups\nc. Reactive: Enabling upon an event by installing\nan event handler, with less control of when\nactions begin or end\nd. Dependent: Enabling upon completion of\nothers; for example, sequencing sets of parallel\nactions\ne. Granularity: Execution cost of action bodies\nshould outweigh the overhead of arranging.\n4. Execution Properties\na. Nondeterministic execution of unordered\nactions\nb. Consistency – ensuring agreement among\nparties about values and predicates when\nnecessary to avoid races, maintain safety and\natomicity, or arrive at consensus.\nc. Fault tolerance – handling failures in parties or\ncommunication, including (Byzantine)\nmisbehavior due to untrusted parties and\nprotocols, when necessary to maintain\nprogress or availability.\nd. Tradeoffs are one focus of evaluation\n5. One or more of the following mappings and Explain, KA 2\nmechanisms across layered systems Develop\na. CPU data- and instruction-level parallelism.\nb. SIMD and heterogeneous data parallelism\nc. Multicore scheduled concurrency, tasks, actors\nd. Clusters, clouds; elastic provisioning\ne. Networked distributed systems\nf. Emerging technologies such as quantum\ncomputing and molecular computing\nPDC- 1. Media Explain CS 2\nCommunic a. Varieties – channels (message passing or IO),\nation shared memory, heterogeneous, data stores\nb. Reliance on the availability and nature of\nunderlying hardware, connectivity, and\nprotocols; language support, emulation\n2. Channels\na. Explicit (usually named) party-to-party\ncommunication media\n344\nb. APIs: sockets, architectural and language-\nbased constructs, and layered constructs such\nas RPC (remote procedure call)\nc. IO channel APIs\n3. Memory\na. Shared memory architectures in which parties\ndirectly communicate only with memory at\ngiven addresses, with extensions to\nheterogeneous memory supporting multiple\nmemory stores with explicit data transfer\nacross them; for example, GPU local and\nshared memory, Direct Memory Access (DMA)\nb. Memory hierarchies – multiple layers of sharing\ndomains, scopes, and caches; locality: latency,\nfalse-sharing\nc. Consistency properties – bitwise atomicity\nlimits, coherence, local ordering\n4. Data Stores\na. Cooperatively maintained data structures\nimplementing maps and related ADTs.\nb. Varieties – owned, shared, sharded, replicated,\nimmutable, versioned\n5. One or more of the following properties and Explain, KA 6\nextensions Develop\na. Topologies – unicast, multicast, mailboxes,\nswitches; routing via hardware and software\ninterconnection networks\nb. Media concurrency properties – ordering,\nconsistency, idempotency, overlapping\ncommunication with computation\nc. Media performance – latency, bandwidth\n(throughput) contention (congestion),\nresponsiveness (liveness), reliability (error and\ndrop rates), protocol-based progress (acks,\ntimeouts, mediation)\nd. Media security properties – integrity, privacy,\nauthentication, authorization\ne. Data formats – marshaling, validation,\nencryption, compression\nf. Channel policies: Endpoints, Sessions,\nbuffering, saturation response (waiting vs\ndropping), Rate control\n345\ng. Multiplexing and demultiplexing many relatively\nslow I/O devices or parties; completion-based\nand scheduler-based techniques; async-await,\nselect and polling APIs\nh. Formalization and analysis of channel\ncommunication; for example, CSP\ni. Applications of queuing theory to model and\npredict performance\nj. Memory models – sequential and\nrelease/acquire consistency\nk. Memory management, including reclamation of\nshared data; reference counts and alternatives\nl. Bulk data placement and transfer; reducing\nmessage traffic and improving locality;\noverlapping data transfer and computation;\nimpact of data layout such as array-of-structs\nvs struct-of-arrays\nm. Emulating shared memory: distributed shared\nmemory, Remote Direct Memory Access\n(RDMA)\nn. Data store consistency – atomicity,\nlinearizability, transactionality, coherence,\ncausal ordering, conflict resolution, eventual\nconsistency, blockchains\no. Faults, partitioning, and partial failures; voting;\nprotocols such as Paxos and Raft\np. Design tradeoffs among consistency,\navailability, partition (fault) tolerance;\nimpossibility of meeting all at once\nq. Security and trust: Byzantine failures, proof of\nwork and alternatives\nPDC- 1. Dependencies Explain CS 2\nCoordinatio a. Initiation or progress of one activity may be\nn dependent on other activities, so as to avoid\nrace conditions, ensure termination, or meet\nother requirements.\nb. Ensuring progress by avoiding dependency\ncycles, using monotonic conditions, removing\ninessential dependencies\n2. Control constructs and design patterns\na. Completion-based – barriers, joins, including\ntermination control\n346\nb. Data-enabled – queues, producer-consumer\ndesigns\nc. Condition-based – polling, retrying, backoffs,\nhelping, suspension, signaling, timeouts\nd. Reactive: enabling and triggering continuations\n3. Atomicity\na. Atomic instructions enforced local access\norderings\nb. Locks and mutual exclusion; lock granularity\nc. Deadlock avoidance – ordering, coarsening,\nrandomized retries; encapsulation via lock\nmanagers\nd. Common errors: Failing to lock or unlock when\nnecessary, holding locks while invoking\nunknown operations.\ne. Avoiding locks – replication, read-only,\nownership, and non-blocking constructions\n4. One or more of the following properties and Explain, KA 6\nextensions Develop\na. Progress properties including lock-free, wait-\nfree, fairness, priority scheduling, interactions\nwith consistency, reliability\nb. Performance with respect to contention,\ngranularity, convoying, scaling\nc. Non-blocking data structures and algorithms\nd. Ownership and resource control\ne. Lock variants and alternatives: sequence locks,\nread-write locks; Read-Copy-Update (RCU),\nreentrancy; tickets; controlling spinning versus\nblocking\nf. Transaction-based control – optimistic and\nconservative\ng. Distributed locking: reliability\nh. Alternatives to barriers: clocks; counters, virtual\nclocks; dataflow and continuations; futures and\nRPC; consensus-based, gathering results with\nreducers and collectors\ni. Speculation, selection, cancellation;\nobservability and security consequences\nj. Resource control using semaphores and\ncondition variables\n347\nk. Control flow – scheduling computations, series-\nparallel loops with (possibly elected) leaders,\npipelines and streams, nested parallelism.\nl. Exceptions and failures, handlers, detection,\ntimeouts, fault tolerance, voting\nPDC- 1. Safety and liveness requirements in terms of temporal Explain, CS 1\nEvaluation: logic constructs to express “always” and “eventually” Evaluate\n2. Identifying, testing for, and repairing violations,\nincluding common forms of errors such as failure to\nensure necessary ordering (race errors), atomicity\n(including check-then-act errors), and termination\n(livelock)\n3. Performance requirements metrics for throughput,\nresponsiveness, latency, availability, energy\nconsumption, scalability, resource usage,\ncommunication costs, waiting and rate control,\nfairness; service level agreements\n4. Performance impact of design and implementation\nchoices, including granularity, overhead, and energy\nconsumption\n5. Estimating scalability limitations, for example, using\nAmdahl’s Law or Universal Scalability Law\n6. One or more of the following methods and tools Explain, KA 3\na. Extensions to formal sequential requirements Evaluate\nsuch as linearizability\nb. Protocol, session, and transactional\nspecifications\nc. Use of tools such as Unified Modelling\nLanguage (UML), Temporal Logic of Actions\n(TLA), program logics\nd. Security analysis: safety and liveness in the\npresence of hostile or buggy behaviors by\nother parties; required properties of\ncommunication mechanisms (for example lack\nof cross-layer leakage), input screening, rate\nlimiting\ne. Static analysis applied to correctness,\nthroughput, latency, resources, energy\nf. Directed Acyclic Graph (DAG) model analysis\nof algorithmic efficiency (work, span, critical\npaths)\n348\ng. Testing and debugging; tools such as race\ndetectors, fuzzers, lock dependency checkers,\nunit/stress/torture tests, visualizations,\ncontinuous integration, continuous deployment,\nand test generators\nh. Measuring and comparing throughput,\noverhead, waiting, contention, communication,\ndata movement, locality, resource usage,\nbehavior in the presence of excessive numbers\nof events, clients, or threads\ni. Application domain specific analyses and\nevaluation techniques\nPDC- 1. Expressing and implementing algorithms in given Explain, CS 2\nAlgorithms languages and frameworks, to initiate activities (for Develop\nexample threads), use shared memory constructs, and\nchannel, socket, and/or remote procedure call APIs\na. Data parallel examples including map/reduce\nb. Using channel, socket, and/or RPC APIs in a\nspecified language, with program control for\nsending (usually procedural) vs receiving\n(usually reactive or RPC-based)\nc. Using locks, barriers, and/or synchronizers to\nmaintain liveness without introducing races\n2. Survey of common application domains across\nmulticore, reactive, data parallel, cluster, cloud, open\ndistributed systems, and frameworks\n3. One or more of the following algorithmic domains Explain, KA 9\na. Linear algebra – vector and matrix operations, Develop,\nnumerical precision/stability, applications in Evaluate\ndata analytics and machine learning\nb. Data processing – sorting, searching and\nretrieval, concurrent data structures\nc. Graphs, search, and combinatorics – marking,\nedge-parallelization, bounding, speculation,\nnetwork-based analytics\nd. Modeling and simulation – differential\nequations; randomization, N-body problems,\ngenetic algorithms\ne. Computational Logic – satisfiability (SAT),\nconcurrent logic programming\nf. Graphics and computational geometry –\ntransforms, rendering, ray-tracing\n349\ng. Resource management – allocating, placing,\nrecycling and scheduling processors, memory,\nchannels, and hosts; exclusive vs shared\nresources; static, dynamic, and elastic\nalgorithms; real-time constraints; batching,\nprioritization, partitioning; decentralization via\nwork-stealing and related techniques\nh. Services – implementing web APIs, electronic\ncurrency, transaction systems, multiplayer\ngames\nSF: Systems Fundamentals\nKU Topic Skill Core Hours\nLevel\nSF- 1. Basic building blocks and components of a computer\nOverview (gates, flip-flops, registers, interconnections; datapath\n+ control + memory)\n2. Hardware as a computational paradigm –\nfundamental logic building blocks; logic expressions,\nminimization, sum of product forms\n3. Programming abstractions, interfaces, and use of\nlibraries\n4. Distinction and interaction between application and Explain CS 3\nOS services, remote procedure call\n5. Basic concept of pipelining, overlapped processing\nstages\n6. Basic concept of scaling: going faster vs handling\nlarger problems\nSF- 1. Digital vs Analog/Discrete vs Continuous Systems\nFoundations 2. Simple logic gates, logical expressions, Boolean logic\nsimplification Apply CS 4\n3. Clocks, State, Sequencing\n4. State and state transition (e.g., starting state, final\nstate, life cycle of states)\n5. Finite state machines (e.g., NFA, DFA)\n6. Combinational Logic, Sequential Logic, Registers,\nMemories\n7. Computers and Network Protocols as examples of\nState Machines\n350\n8. Sequential vs parallel processing\n9. Application-level sequential processing – single\nthread\n10. Simple application-level parallel processing – request\nlevel (web services/client-server/distributed), single\nthread per server, multiple threads with multiple\nservers, pipelining\nSF- 1. Different types of resources (e.g., processor share, Explain CS 1\nResource memory, disk, net bandwidth)\n2. Common resource allocation/scheduling algorithms\n(e.g., first-come-first-serve, priority-based scheduling,\nfair scheduling, and preemptive scheduling)\n3. Advantages and disadvantages of common Explain KA 1\nscheduling algorithms\nSF- 1. Latencies in computer systems Apply CS 2\nPerformanc a. Speed of light and computers (one foot per\ne nanosecond vs one GHz clocks)\nb. Memory vs disk latencies vs across-the-\nnetwork memory\n2. Caches and the effects of spatial and temporal locality\non performance in processors and systems\n3. Caches and cache coherency in databases, operating\nsystems, distributed systems, and computer\narchitecture\n4. Introduction to the processor memory hierarchy\n5. The formula for average memory access time Apply KA 2\n6. Rationale of virtualization and isolation – protection\nand predictable performance\n7. Levels of indirection, illustrated by virtual memory for\nmanaging physical memory resources\n8. Methods for implementing virtual memory and virtual\nmachines\nSF- 1. Performance figures of merit Evaluate CS 2\nEvaluation 2. Workloads and representative benchmarks, and\nmethods of collecting and analyzing performance\nfigures of merit\n3. CPI (Cycles per Instruction) equation as a tool for\nunderstanding tradeoffs in the design of instruction\n351\nsets, processor pipelines, and memory system\norganizations\n4. Amdahl’s Law: the part of the computation that cannot\nbe sped up limits the effect of the parts that can be\n5. Order of magnitude analysis (Big O notation)\n6. Analysis of slow and fast paths of a system\n7. Events on their effect on performance (e.g.,\ninstruction stalls, cache misses, page faults)\n8. Analytical tools to guide quantitative evaluation Evaluate KA 2\n9. Understanding layered systems, workloads, and\nplatforms, their implications for performance, and the\nchallenges they represent for evaluation\n10. Microbenchmarking pitfalls\nSF- 1. Distinction between bugs and faults Evaluate CS 2\nReliability 2. Reliability vs availability\n3. Reliability through redundancy\na. check and retry\nb. redundant encoding (error correction codes,\nCRC, FEC)\nc. duplication/mirroring/replicas\n4. Other approaches to reliability (e.g., journaling) Evaluate KA 1\nSF-Security 1. Common system security issues (e.g., viruses, denial- Evaluate CS 2\nof-service attacks, and eavesdropping)\n2. Countermeasures\na. Cryptography\nb. Security architecture\n3. Representative countermeasure systems Evaluate KA 1\na. Intrusion detection systems, firewalls\nSF-Design 1. Common criteria of system design (e.g., liveness, Design CS 2\nsafety, robustness, scalability, and security)\n2. Designs of representative systems (e.g., Apache web Design KA 1\nserver, Spark, and Linux)\nDM: Data Management\nTopic Skill Core Hours\nKU Level\n352\nDM-Data 1. The Data Life Cycle Evaluate CS 2\nDM-Core 1. Purpose and advantages of database systems Explain CS 2\n2. Components of database systems\n3. Design of core DBMS functions (e.g., query\nmechanisms, transaction management, buffer\nmanagement, access methods)\n4. Database architecture, data independence, and data\nabstraction\n5. Transaction management\n6. Normalization\n7. Approaches for managing large volumes of data (e.g.,\nNoSQL database systems, use of MapReduce)\n8. How to support CRUD-only applications\n9. Distributed databases/cloud-based systems\n10. Structured, semi-structured, and unstructured\ndatabases\n11. Use of a declarative query language Develop\nDM-Core 12. Systems supporting structured and/or stream content Explain KA 1\nDM- 1. Data modeling Develop CS 2\nModeling 2. Relational data models\nDM- 3. Conceptual models (e.g., entity-relationship, UML Explain KA 3\nModeling diagrams)\n4. Semi-structured data model (expressed using DTD,\nXML, or JSON Schema, for example)\nDM- 1. Entity and referential integrity Explain CS 1\nRelational a. Candidate key, superkeys\n2. Relational database design\nDM- 3. Mapping conceptual schema to a relational schema Develop KA 3\nRelational 4. Physical database design: file and storage structures\n5. Introduction to Functional dependency theory\n6. Normalization theory\na. Decomposition of a schema; lossless-join and\ndependency-preservation properties of a\ndecomposition\nb. Normal forms (BCNF)\nc. Denormalization (for efficiency)\nDM- 1. SQL Query Formation Develop CS 2\n353\nQuerying a. Interactive SQL execution\nb. Programmatic execution of an SQL query\nDM- 2. Relational Algebra Develop KA 4\nQuerying 3. SQL\na. Data definition including integrity and other\nconstraints specification\nb. Update sublanguage\nDM- 1. Page structures Explain KA 4\nProcessing 2. Index structures\na. B+ trees\nb. Hash indices: static and dynamic\nc. Index creation in SQL\n3. File Structures\na. Heap files\nb. Hash files\n4. Algorithms for query operators\na. External Sorting\nb. Selection\nc. Projection; with and without duplicate\nelimination\nd. Natural Joins: Nested loop, Sort-merge, Hash\njoin\ne. Analysis of algorithm efficiency\n5. Query transformations\n6. Query optimization\na. Access paths\nb. Query plan construction\nc. Selectivity estimation\nd. Index-only plans\n7. Parallel Query Processing (e.g., parallel scan, parallel\njoin, parallel aggregation)\n8. Database tuning/performance Develop\na. Index selection\nb. Impact of indices on query performance\nc. Denormalization\nDM- 1. DB Buffer Management Explain KA 4\nInternals 2. Transaction Processing\na. Isolation Levels\nb. ACID\n354\nc. Serializability\nd. Distributed transactions\n3. Concurrency Control:\na. 2-Phase Locking\nb. Deadlocks handling strategies\nc. Quorum-based consistency models\n4. Recovery Manager\na. Relation with Buffer Manager\nDM-NoSQL 1. Why NoSQL? (e.g., Impedance mismatch between Explain KA 2\nApplication [CRUD] and RDBMS)\n2. Key-Value and Document data model\nDM- 1. Exploratory data techniques (motivation, Explain KA 3\nAnalytics representation, descriptive statistics, visualizations)\n2. Data science lifecycle – business understanding, data\nunderstanding, data preparation, modeling,\nevaluation, deployment, and user acceptance\n3. Data mining and machine learning algorithms: e.g.,\nclassification, clustering, association, regression\n4. Data acquisition and governance\n5. Data security and privacy considerations\n6. Data fairness and bias\n7. Data visualization techniques and their use in data\nanalytics\n8. Entity Resolution\nDM-Security 1. Differences between data security and Explain CS 1\ndata privacy\n2. Protecting data and database systems\nfrom attacks, including injection attacks\nsuch as SQL injection\n3. Personally identifying information (PII) and\nits protection\n4. Ethical considerations in ensuring the\nsecurity and privacy of data\nDM-Security 5. Need for, and different approaches to Explain KA 2\nsecuring data at rest, in transit, and during\nprocessing\n6. Database auditing and its role in digital\nforensics\n7. Data inferencing and preventing attacks\n355\n8. Laws and regulations governing data\nsecurity and data privacy\nDM-SEP 1. Issues related to scale Explain CS\n2. Data privacy overall\na. Privacy compliance by design\n3. Data anonymity\n4. Data ownership/custodianship\n5. Intended and unintended applications of stored data\nDM-SEP 6. Reliability of data Explain KA\n7. Provenance, data lineage, and metadata\nmanagement\n8. Data security\nSEC: Security\nKU Topic Skill Core Hours\nLevel\nSEC- 1. Developing a security mindset incorporating Develop CS 1\nFoundations crosscutting concepts: confidentiality, integrity,\navailability, risk assessment, systems thinking,\nadversarial thinking, human-centered thinking\n2. Basic concepts of authentication and\nauthorization/access control\n3. Vulnerabilities, threats, attack surfaces, and attack\nvectors\n4. Denial of Service (DoS) and Distributed Denial of\nService (DDoS)\n5. Principles and practices of protection, e.g., least\nprivilege, open design, fail-safe defaults, defense in\ndepth, and zero trust; and how they can be\nimplemented\n6. Optimization considerations between security,\nprivacy, performance, and other design goals\n7. Impact of AI on security and privacy: using AI to\nbolster defenses as well as address increased\nadversarial capabilities due to AI\nSEC- 8. Access control models (e.g., discretionary, Develop KA 5\nFoundations mandatory, role-based, and attribute-based)\n9. Security controls\n356\n10. Concepts of trust and trustworthiness\n11. Applications of a security mindset: web, cloud, and\nmobile devices\n12. Protecting embedded and cyber-physical systems\n13. Principles of usable security and human-centered\ncomputing\n14. Security and trust in AI/machine learning systems,\ne.g., fit for purpose, ethical operating boundaries,\nauthoritative knowledge sources, verified training\ndata, repeatable system evaluation tests, system\nattestation, independent validation/certification;\nunintended consequences from: adverse effect\n15. Security risks in building and operating AI/machine\nlearning systems, e.g., algorithm bias, knowledge\ncorpus bias, training corpus bias, copyright violation\n16. Hardware considerations in security, e.g., principles of\nsecure hardware, secure processor architectures,\ncryptographic acceleration, compartmentalization,\nsoftware-hardware interaction\nSEC-SEP 1. Principles and practices of privacy Develop CS 1\n2. Societal impacts on breakdowns in security and\nprivacy.\n3. Applicability of laws and regulations on security and\nprivacy\n4. Professional ethical considerations when designing\nsecure systems and maintaining privacy; ethical\nhacking\nSEC-SEP 5. Security by design Develop KA 2\n6. Privacy by design and privacy engineering\n7. Security and privacy implications of malicious\nAI/machine learning actors, e.g., identifying deep\nfakes\n8. Societal impacts of Internet of Things (IoT) devices\nand other emerging technologies on security and\nprivacy\nSEC-Coding 1. Common vulnerabilities and weaknesses Develop CS 2\n2. SQL injection and other injection attacks\n3. Cross-site scripting techniques and mitigations\n4. Input validation and data sanitization\n5. Type safety and type-safe languages\n357\n6. Buffer overflows, stack smashing, and integer\noverflows\n7. Security issues due to race conditions\nSEC- 8. Principles of noninterference and non-deducibility Develop KA 5\nCoding 9. Preventing information flow attacks\n10. Offensive security techniques as a defense\n11. AI-assisted malware detection techniques\n12. Ransomware: creation, prevention, and mitigation.\n13. Secure use of third-party components\n14. Malware: varieties, creation, reverse engineering, and\ndefense against them\n15. Assurance: testing (including fuzzing and penetration\ntesting), verification and validation\n16. Static and dynamic analyses\n17. Secure compilers and secure code generation\nSEC-Crypto 1. Differences between algorithmic, applied, and Evaluate CS 1\nmathematical views of cryptography\n2. Mathematical preliminaries: modular arithmetic,\nEuclidean algorithm, probabilistic independence,\nlinear algebra basics, number theory, finite fields,\ncomplexity, asymptotic analysis.\n3. Basic cryptography – symmetric key and public key\ncryptography\n4. Basic cryptographic building blocks, including\nsymmetric encryption, asymmetric encryption,\nhashing, and message authentication\n5. Classical cryptosystems, such as shift, substitution,\ntransposition ciphers, code books, machines\n6. Kerckhoff’s principle and use of vetted libraries\n7. History and real-world applications, e.g., electronic\ncash, secure channels between clients and servers,\nsecure electronic mail, entity authentication, device\npairing, voting systems\nSEC-Crypto 8. Additional mathematics – primality and factoring; Develop KA 4\nelliptic curve cryptography\n9. Private-key cryptosystems – substitution-permutation\nnetworks, linear cryptanalysis, differential\ncryptanalysis, DES, AES\n10. Public-key cryptosystems – Diffie-Hellman, RSA\n11. Data integrity and authentication – hashing, digital\nsignatures\n358\n12. Cryptographic protocols – challenge-response\nauthentication, zero-knowledge protocols,\ncommitment, oblivious transfer, secure two- or multi-\nparty computation, hash functions, secret sharing, and\napplications\n13. Attacker capabilities – chosen-message attack (for\nsignatures), birthday attacks, side channel attacks,\nfault injection attacks\n14. Quantum cryptography – Post Quantum/Quantum\nresistant cryptography\n15. Blockchain and cryptocurrencies\nSEC- 1. Security engineering goals – building systems that Develop CS 1\nEngineering remain dependable despite errors, accidents, or\nmalicious adversaries\n2. Privacy engineering goals – building systems that\ndesign, implement, and deploy privacy features and\ncontrols\n3. Problem analysis and situational analysis to address\nsystem security\n4. Engineering tradeoff analysis based on time, cost, risk\ntolerance, risk acceptance, return on investment, and\nso on\nSEC- 5. Security design and engineering, including functional Develop KA 8\nEngineering requirements, security subsystems, information\nprotection, security testing, security assessment, and\nevaluation\n6. Security analysis, covering security requirements\nanalysis; security controls analysis; threat analysis;\nand vulnerability analysis\n7. Security attack domains and attack surfaces, e.g.,\ncommunications and networking, hardware, physical,\nsocial engineering, software, and supply chain\n8. Security attack modes, techniques, and tactics, e.g.,\nauthentication abuse; brute force; buffer manipulation;\ncode injection; content insertion; denial of service;\neavesdropping; function bypass; impersonation;\nintegrity attack; interception; phishing; protocol\nanalysis; privilege abuse; spoofing; and traffic\ninjection\n9. Attestation of software products with respect to their\nspecification and adaptiveness\n10. Design and development of cyber-physical systems\n359\n11. Considerations for trustworthy computing, e.g.,\ntamper resistant packaging, trusted boot, trusted\nkernel, hardware root of trust, software signing and\nverification, hardware-based cryptography,\nvirtualization, and containers\nSEC- 1. Basic principles and methodologies for digital Develop KA 6\nForensics forensics\n2. System design for forensics\n3. Forensics in different situations – operating systems,\nfile systems, application forensics, web forensics,\nnetwork forensics, mobile device forensics, use of\ndatabase auditing\n4. Attacks on forensics and preventing such attacks\n5. Incident handling processes\n6. Rules of evidence – general concepts and differences\nbetween jurisdictions\n7. Legal issues – digital evidence protection and\nmanagement, chains of custody, reporting, serving as\nan expert witness.\nSEC- 1. Protecting critical assets from threats Develop KA 3\nGovernance 2. Security governance – organizational objectives and\ngeneral risk assessment\n3. Security management – achieve and maintain\nappropriate levels of confidentiality, integrity,\navailability, accountability, authenticity, and reliability\n4. Security policy – Organizational policies, issue-\nspecific policies, system-specific policies\n5. Approaches to identifying and mitigating risks to\ncomputing infrastructure\n6. Data lifecycle management policies: data collection,\nbackups, and retention; cloud storage and services;\nbreach disclosure\nApplications Competency Area\nThe core topics listed in this section are typically covered in advanced, often elective courses. Effort\nshould be made to include the CS Core topics in earlier required courses in the curriculum.\nKnowledge Area Knowledge Units CS Core KA Core\n360\nAI Artificial Intelligence 12 12 18\nGIT Graphics and Interactive Techniques 11 4 70\nHCI Human-Computer Interaction 6 8 16\nSPD Specialized Platform Development 8 4 68\nTotal 28 N/A\nAI: Artificial Intelligence\nKU Topic Skill Core Hours\nLevel\nAI- 1. Overview of AI problems, examples of successful Explain CS 2\nIntroduction recent AI applications\n2. Definitions of agents with examples (e.g., reactive,\ndeliberative)\n3. What is intelligent behavior?\na. The Turing test and its flaws\nb. Multimodal input and output\nc. Simulation of intelligent behavior\nd. Rational vs non-rational reasoning\n4. Problem characteristics Evaluate\na. Fully versus partially observable\nb. Single vs multi-agent\nc. Deterministic versus stochastic\nd. Static vs dynamic\ne. Discrete versus continuous\n5. Nature of agents\na. Autonomous, semi-autonomous, mixed-\ninitiative autonomy\nb. Reflexive, goal-based, and utility-based\nc. Decision making under uncertainty and with\nincomplete information\nd. The importance of perception and\nenvironmental interactions\ne. Learning-based agents\nf. Embodied agents\ni. sensors, dynamics, effectors\n361\n6. AI Applications, growth, and Impact (economic, Explain\nsocietal, ethics)\nAI- 7. Practice identifying problem characteristics in Evaluate KA 1\nIntroduction example environments\n8. Additional depth on nature of agents with examples\n9. Additional depth on AI Applications, growth, and\nImpact (economic, societal, ethics)\nAI-Search 1. State space representation of a problem Explain\na. Specifying states, goals, and operators\nb. Factoring states into representations\n(hypothesis spaces)\nc. Problem solving by graph search\ni. e.g., Graphs as a space, and tree\ntraversals as exploration of that space\nAL- ii. Dynamic construction of the graph (not\nFoundationa given upfront)\nl\n2. Uninformed graph search for problem solving Develop,\nCS 5\na. Breadth-first search Apply\nb. Depth-first search\ni. With iterative deepening\nc. Uniform cost search\n3. Heuristic graph search for problem solving Develop,\na. Heuristic construction and admissibility Apply\nb. Hill-climbing\nc. Local minima and the search landscape\ni. Local vs global solutions\nd. Greedy best-first search\ne. A* search\n4. Space and time complexities of graph search Evaluate\nalgorithms\nAI-Search 5. Bidirectional search\n6. Beam search\n7. Two-player adversarial games Develop, KA 6\na. Minimax search Apply\nb. Alpha-beta pruning\ni. Ply cutoff\n8. Implementation of A* search\n9. Constraint Satisfaction\n362\nAI-KRR 1. Types of representations Explain CS 2\na. Symbolic, logical\ni. Creating a representation from a\nnatural language problem statement\nb. Learned subsymbolic representations\nc. Graphical models (e.g., naive Bayes, Bayes\nnet)\n2. Review of probabilistic reasoning, Bayes theorem\n3. Bayesian reasoning Apply\na. Bayesian inference\nAI-KRR 4. Random variables and probability distributions Apply KA 2\na. Axioms of probability\nb. Probabilistic inference\nc. Bayes’ Rule (derivation)\nd. Bayesian inference (more complex examples)\n5. Independence\n6. Conditional Independence\n7. Markov chains and Markov models\n8. Utility and decision making\nAI-ML 1. Definition and examples of a broad variety of machine CS 4\nlearning tasks\na. Supervised learning\ni. Classification\nii. Regression\nb. Reinforcement learning\nc. Unsupervised learning\ni. Clustering\n2. Fundamental ideas:\na. No free lunch theorem: no one learner can\nsolve all problems; representational design\ndecisions have consequences\nb. sources of error and undecidability in machine\nlearning\n3. A simple statistical-based supervised learning such as Apply,\nlinear regression or decision trees Develop,\na. Focus on how they work without going into Evaluate\nmathematical or optimization details; enough\nto understand and use existing\nimplementations correctly.\n363\n4. The overfitting problem / controlling solution\ncomplexity (regularization, pruning – intuition only)\na. The bias (underfitting) – variance (overfitting)\ntradeoff\n5. Working with Data\na. Data preprocessing\ni. Importance and pitfalls of\npreprocessing choices\nb. Handling missing values (imputing, flag-as-\nmissing)\ni. Implications of imputing vs flag-as-\nmissing\nc. Encoding categorical variables, encoding real-\nvalued data\nd. Normalization/standardization\ne. Emphasis on real data, not textbook examples\n6. Representations\na. Hypothesis spaces and complexity\nb. Simple basis feature expansion, such as\nsquaring univariate features\nc. Learned feature representations\n7. Machine learning evaluation\na. Separation of train, validation, and test sets\nb. Performance metrics for classifiers\nc. Estimation of test performance on held-out\ndata\nd. Tuning the parameters of a machine learning\nmodel with a validation set\ne. Importance of understanding what a model is\ndoing, where its pitfalls/shortcomings are, and\nthe implications of its decisions\n8. Basic neural networks\na. Fundamentals of understanding how neural\nnetworks work and their training process,\nwithout details of the calculations\nb. Basic introduction to generative neural\nnetworks (large language models, etc.)\n9. Ethics for Machine Learning Explain,\na. Focus on real data, real scenarios, and case Evaluate\nstudies\nb. Dataset/algorithmic/evaluation bias and\nunintended consequences\n364\nAI-ML 10. Formulation of simple machine learning as an Apply, KA 6\noptimization problem, such as least squares linear Develop,\nregression or logistic regression Evaluate\na. Objective function\nb. Gradient descent\nc. Regularization to avoid overfitting\n(mathematical formulation)\n11. Ensembles of models\na. Simple weighted majority combination\n12. Deep learning\na. Deep feed-forward networks (intuition only, no\nmathematics)\nb. Convolutional neural networks (intuition only,\nno mathematics)\nc. Visualization of learned feature\nrepresentations from deep nets\nd. Other architectures (generative NN, recurrent\nNN, transformers, etc.)\n13. Performance evaluation\na. Other metrics for classification (e.g., error,\nprecision, recall)\nb. Performance metrics for regressors\nc. Confusion matrix\nd. Cross-validation\ni. Parameter tuning (grid/random search,\nvia cross-validation)\n14. Overview of reinforcement learning methods\n15. Two or more applications of machine learning\nalgorithms\na. e.g., medicine and health, economics, vision,\nnatural language, robotics, game play\n16. Ethics for Machine Learning Explain,\na. Continued focus on real data, real scenarios, Evaluate\nand case studies\nb. Privacy\nc. Fairness\nd. Intellectual property\ne. Explainability\nAI-SEP 1. At least one application of AI to a specific problem Explain, CS 3\nand field, such as medicine, health, sustainability, Evaluate\nsocial media, economics, education, robotics, etc. (at\nleast one for the CS Core)\n365\na. Formulating and evaluating a specific\napplication as an AI problem\ni. How to deal with underspecified or ill-\nposed problems\nb. Data availability/scarcity and cleanliness\ni. Basic data cleaning and preprocessing\nii. Data set bias\nc. Algorithmic bias\nd. Evaluation bias\ne. Assessment of societal implications of the\napplication\n2. Deployed deep generative models\na. High-level overview of deep image generative\nmodels (e.g., as of 2023, DALL-E, Midjourney,\nStable Diffusion), their uses, and their\nshortcomings/pitfalls.\nb. High-level overview of large language models\n(e.g., as of 2023, ChatGPT, Bard), their uses,\nand their shortcomings/pitfalls.\n3. Overview of societal impact of AI\na. Ethics\nb. Fairness\nc. Trust/explainability\nd. Privacy and usage of training data\ne. Human autonomy and\noversight/regulations/legal requirements\nf. Sustainability\nAI-SEP 4. One or more additional applications of AI to a broad Explain, KA 3\nset of problems and diverse fields, such as medicine, Evaluate\nhealth, sustainability, social media, economics,\neducation, robotics, etc. (choose a different area from\nthat chosen for the CS Core).\na. Formulating and evaluating a specific\napplication as an AI problem\ni. How to deal with underspecified or ill-\nposed problems\nb. Data availability/scarcity and cleanliness\ni. Basic data cleaning and preprocessing\nii. Data set bias\nc. Algorithmic bias\nd. Evaluation bias\n366\ne. Assessment of societal implications of the\napplication\n5. Additional depth on deployed deep generative models\na. Introduction to how deep image generative\nmodels work, (e.g., as of 2023, DALL-E,\nMidjourney, Stable Diffusion) including\ndiscussion of attention\nb. Introduction to how large language models\nwork, (e.g., as of 2023, ChatGPT, Bard)\nincluding discussion of attention\nc. Idea of foundational models, how to use them,\nand the benefits/issues with training them from\nbig data\n6. Analysis and discussion of the societal impact of AI\na. Ethics\nb. Fairness\nc. Trust/explainability\nd. Privacy and usage of training data\ne. Human autonomy and\noversight/regulations/legal requirements\nf. Sustainability\nGIT: Graphics and Interactive Techniques\nKU Topic Skill Core Hours\nLevel\nGIT- 1. Uses and potential risks Explain CS 4\nFundamenta 2. Graphic output\nls 3. Human vision system\n4. Standard image formats\n5. Digitization of analog data\n6. Color Models\n7. Tradeoffs between storing image data and\nrecomputing image data\n8. Spatialization\n9. Animation\n10. Applied computer graphics Develop KA 3\n11. Display characteristics\n1. Data visualization and information visualization Explain KA 6\n367\nGIT- 2. Visualization of:\nVisualization a. 2D/3D scalar fields\nb. Vector fields and flow data\nc. Time-varying data\nd. High-dimensional data\ne. Non-spatial data\n3. Visualization techniques (e.g., color mapping,\nisosurfaces, dimension reduction, parallel\ncoordinates, multi-variate, tree/graph-structured, text)\n4. Direct volume data rendering (e.g., ray-casting,\ntransfer functions, segmentation)\n5. Common data formats (e.g., HDF, netCDF, geotiff,\nGeoJSON, shape files, raw binary, CSV, ASCII to\nparse)\n6. Common visualization software and libraries (e.g., R,\nProcessing, D3.js, GIS, Matlab, IDL, Python)\n7. Perceptual and cognitive foundations that drive visual\nabstractions\n8. Visualization design\n9. Evaluation of visualization methods and applications\n10. Visualization bias\n11. Applications of visualization\nGIT- 1. Object and scene modeling Explain KA 6\nRendering 2. Camera and projection modeling\n3. Light models and radiometry\n4. Rendering\nGIT- 1. Basic geometric operations Explain KA 6\nModeling 2. Surface representation/model\n3. Volumetric representation/model\n4. Procedural representation/model\n5. Multi-resolution modeling\n6. Reconstruction\nGIT- 1. Solutions and approximations to the rendering Explain KA 6\nShading equation\n2. Time (motion blur), lens position (focus), and\ncontinuous frequency (color) and their impact on\nrendering\n3. Shadow mapping\n4. Occlusion culling\n5. Bidirectional Scattering Distribution function (BSDF)\ntheory and microfacets\n368\n6. Subsurface scattering\n7. Area light sources\n8. Hierarchical depth buffering\n9. Image-based rendering\n10. Non-photorealistic rendering\n11. GPU architecture\n12. Human visual systems including adaptation to light,\nsensitivity to noise, and flicker fusion\nGIT- 1. Principles of Animation Explain KA 6\nAnimation 2. Types of animation\n3. Key-frame animation\n4. Forward and inverse kinematics\n5. Skinning algorithms\n6. Motion capture\nGIT- 1. Collision detection and response Explain KA 6\nSimulation 2. Procedural animation using noise\n3. Particle systems\n4. Grid-based fluids\n5. Heightfields\n6. Rule-based systems (e.g., L-systems, space-\ncolonizing systems, Game of Life)\nGIT- 1. Immersion levels (i.e., Virtual Reality (VR), Explain KA 6\nImmersion Augmented Reality (AR), and Mixed Reality (MR))\n2. The definition and distinction of immersion and\npresence\n3. 360 Video\n4. Stereoscopic display\n5. Viewer tracking\n6. Time-critical rendering to achieve optimal motion to\nphoton (MTP) latency\na. Branching movies\n7. Distributed VR, collaboration over computer network\n8. Presence and factors that impact level of immersion\n9. 3D interaction\n10. Applications in medicine, simulation, training, and\nvisualization\n11. Safety in immersive applications\nGIT- 1. Event Driven Programming Apply KA 4\nInteraction 2. Graphical User Interface (Single Channel)\n3. Accessibility\n369\nGIT-Image 1. Morphological operations Explain KA 6\n2. Color histograms\n3. Image enhancement\n4. Image restoration\n5. Image coding\n6. Connections to deep learning\nGIT- 1. Interaction with the physical world Explain KA 6\nPhysical 2. Connection to physical artifacts\n3. Internet of Things\nGIT-SEP 1. Accessibility Evaluate CS 1\n2. Ethics/privacy\n3. Intellectual Property law as it relates to computer KA 3\ngraphics and interactive techniques\n4. DEIA, current and past contributors to the field\nHCI: Human-Computer Interaction\nKU Topic Skill Core Hours\nLevel\nHCI-User 1. User-centered design and evaluation methods Explain, CS 2\na. “You are not the users” Evaluate,\nb. user needs-finding Develop\nc. formative studies\nd. interviews\ne. surveys\nf. usability tests\nHCI-User 2. User-centered design and evaluation methods Explain, KA 5\na. personas/persona spectrum Evaluate,\nb. user stories/storytelling and techniques for Develop\ngathering stories\nc. empathy maps\nd. needs assessment (techniques for uncovering\nneeds and gathering requirements – e.g.,\ninterviews, surveys, ethnographic and contextual\nenquiry)\ne. journey maps\nf. evaluating the design\ng. interfacing with stakeholders, as a team\n370\nh. risks associated with physical, distributed, hybrid\nand virtual teams\n3. Physical and cognitive characteristics of the user\na. physical capabilities that inform interaction design\n(e.g., color perception, ergonomics)\nb. cognitive models that inform interaction design\n(e.g., attention, perception and recognition,\nmovement, memory)\nc. topics in social/behavioral psychology (e.g.,\ncognitive biases, change blindness)\n4. Designing for diverse user populations\na. how differences (e.g., in race, ability, age,\ngender, culture, experience, and education)\nimpact user experiences and needs\nb. internationalization, other cultures, and cross-\ncultural design\nc. designing for users from other cultures\nd. cross-cultural design\ne. challenges to effective design evaluation (e.g.,\nsampling, generalization; disability and disabled\nexperiences)\nf. universal design\n5. Collaboration and communication\na. understanding the user in a multi-user context\nb. synchronous group communication (e.g., chat\nrooms, conferencing, online games)\nc. asynchronous group communication (e.g., email,\nforums, social networks)\nd. social media, social computing, and social\nnetwork analysis\ne. online collaboration\nf. social coordination and online communities\ng. avatars, characters, and virtual worlds\nHCI- 1. Design impact Explain, CS 2\nAccountabili a. Sustainability Apply,\nty b. Inclusivity Evaluate\nc. Safety, security, and privacy\nd. Harm and disparate impact\n2. Ethics in design methods and solutions Develop\na. the role of artificial intelligence\nb. responsibilities for considering stakeholder\nimpact and human factors\nc. the role of design to meet user needs\n371\n3. Requirements in design\na. ownership responsibility\nb. legal frameworks and compliance requirements\nc. consideration beyond immediate user needs\nincluding via iterative reconstruction of problem\nanalysis and “digital well-being” features\nHCI- 4. Value-sensitive design Explain, KA 2\nAccountabili a. identify stakeholders Apply,\nty b. determine and include diverse stakeholder values Evaluate\nand value systems\n5. Persuasion through design Develop\na. assessing persuasive content of a design\nb. persuasion as a design goal\nHCI- 1. Background Explain, CS 2\nAccessibility a. societal and legal support for and obligations to Apply,\npeople with disabilities Evaluate\nb. accessible design benefits everyone\n2. Techniques Develop\na. accessibility standards (e.g., Web Content\nAccessibility Guidelines)\n3. Technologies\na. features and products that enable\naccessibility and support inclusive\ndevelopment by designers and engineers\n4. Inclusive Design Frameworks (IDFs)\na. recognizing differences\n5. Universal design\nHCI- 6. Background Explain, KA 2\nAccessibility a. Demographics and populations Apply,\nb. International perspectives Evaluate\nc. Attitudes towards people with disabilities\n7. Techniques Develop\na. UX (user experience) design and research\nb. software engineering practices that enable\ninclusion and accessibility.\n8. Technologies\na. examples of accessibility-enabling features,\nsuch as conformance to screen readers\n9. Inclusive Design Frameworks\na. creating inclusive processes, such as\nparticipatory design; designing for larger impact\n372\nb. designing for larger impact\nHCI- 1. Methods for evaluation with users Explain, CS 1\nEvaluation a. formative (e.g., needs-finding and exploratory Apply,\nanalysis) and summative assessment (e.g., Evaluate,\nfunctionality and usability testing) Develop\nb. elements to evaluate (e.g., utility, efficiency,\nlearnability, user satisfaction, affective elements\nsuch as pleasure and engagement)\nc. understanding ethical approval requirements\nbefore engaging in user research\nHCI- 2. Methods for evaluation with users Explain, KA 2\nEvaluation a. qualitative methods (qualitative coding and Apply,\nthematic analysis) Evaluate,\nb. quantitative methods (statistical tests) Develop\nc. mixed methods (e.g., observation, think-aloud,\ninterview, survey, experiment)\nd. presentation requirements (e.g., reports,\npersonas)\ne. user-centered testing\nf. heuristic evaluation\ng. challenges and shortcomings to effective\nevaluation (e.g., sampling, generalization)\n3. Study planning\na. how to set study goals\nb. hypothesis design\nc. approvals from Institutional Research Boards and\nethics committees\nd. how to pre-register a study\ne. within-subjects vs between-subjects design\n4. Implications and impacts of design with respect to\na. the environment\nb. material\nc. society\nd. security\ne. privacy\nf. ethics\ng. broader impacts\nHCI-Design 1. Prototyping techniques and tools Explain, CS 1\na. low-fidelity prototyping Apply,\nb. rapid prototyping Evaluate,\nc. throw-away prototyping Develop\n373\nd. granularity of prototyping\n2. Design patterns\na. iterative design\nb. universal design\nc. interaction design (e.g., data-driven design,\nevent-driven design\n3. Design constraints\na. platforms\nb. devices\nc. resources\nd. balance among usability, security and privacy\nHCI-Design 4. Design patterns and guidelines Explain, KA 5\na. software architecture patterns Apply,\nb. cross-platform design Evaluate\nc. synchronization\n5. Design processes Develop\na. participatory design\nb. co-design\nc. double-diamond\nd. convergence and divergence\n6. Interaction techniques\na. input and output vectors (e.g., gesture, pose,\ntouch, voice, force)\nb. graphical user interfaces\nc. controllers\nd. haptics\ne. hardware design\nf. error handling\n7. Visual UI design\na. color\nb. layout\nc. gestalt principles\nHCI-SEP 1. Universal and user-centered design Explain, CS Shared\n2. Accountability Apply, with\n3. Accessibility and inclusive design Evaluate, SEP\n4. Evaluating the design Develop\n5. System design\nHCI-SEP 6. Participatory and inclusive design processes Explain, KA Shared\nApply, with\nEvaluate, SEP\nDevelop\n374\nSPD: Specialized Platform Development\nKU Topic Skill Core Hours\nLevel\nSPD-Common 1. Overview of development platforms (i.e., web, Apply CS 3\nmobile, game, robotics, embedded, and interactive)\na. Input/sensors/control devices/haptic\ndevices\nb. Resource constraints\ni. Computational\nii. Data storage\niii. Memory\niv. Communication\nc. Requirements – security, uptime availability,\nfault tolerance\nd. Output/actuators/haptic devices\n2. Programming via platform-specific Application\nProgramming Interface (API) vs traditional\napplication construction\n3. Overview of platform Languages (e.g., Python,\nSwift, Lua, Kotlin)\n4. Programming under platform constraints and\nrequirements (e.g., available development tools,\ndevelopment, security considerations)\n5. Techniques for learning and mastering a platform-\nspecific programming language\nSPD-Web 1. Web programming languages (e.g., HTML5, Apply KA 5\nJavaScript, PHP, CSS)\n2. Web platforms, frameworks, or meta-frameworks\na. Cloud services\nb. API, Web Components\n3. Software as a Service (SaaS).\n4. Web standards such as document object model,\naccessibility\n5. Security and Privacy Considerations\nSPD-Mobile 1. Development with Apply KA 3\na. Mobile programming languages\nb. Mobile programming environments\n375\n2. Mobile platform constraints\na. User interface design\nb. Security\n3. Access\na. Accessing data through API\nb. Designing API endpoints for mobile apps –\npitfalls and design considerations\nc. Network and the web interfaces\nSPD-Robot 1. Types of robotic platforms and devices Apply KA 4\n2. Sensors, embedded computation, and effectors\n(actuators)\n3. Robot-specific languages and libraries\n4. Robotic software architecture (e.g., using the Robot\nOperating System (ROS))\n5. Robotic platform constraints and design\nconsiderations\n6. Interconnections with physical or simulated\nsystems\n7. Robotic Algorithms\n8. Forward kinematics\na. Inverse kinematics\nb. Dynamics\nc. Navigation and path planning\nd. Grasping and manipulation\n9. Safety and interaction considerations\nSPD- 1. Introduction to the unique characteristics of Apply KA 4\nEmbedded embedded systems\na. Real-time vs soft real-time and non-real-\ntime systems\nb. Resource constraints, such as memory\nprofiles and deadlines\nc. API for custom architectures\nd. GPU technology.\ne. Field Programmable Gate Arrays (FPGA).\nf. Cross-platform systems\n2. Embedded Systems\na. Microcontrollers\nb. Interrupts and feedback\nc. Interrupt handlers in high-level languages\nd. Hard and soft interrupts and trap-exits\ne. Interacting with hardware, actuators, and\nsensors\n376\nf. Energy efficiency\ng. Loosely timed coding and synchronization\nh. Software adapters\n3. Embedded programming\n4. Hard real-time systems vs soft real-time systems\na. Timeliness\nb. Time synchronization/scheduling\nc. Prioritization\nd. Latency\ne. Compute jitter\n5. Real-time resource management.\n6. Memory management:\na. Mapping programming construct (variable)\nto a memory location\nb. Shared memory\nc. Manual memory management\nd. Garbage collection\ne. Safety considerations and safety analysis.\n7. Sensors and actuators\n8. Analysis and verification\n9. Application design\nSPD-Game 1. Historical and contemporary platforms for games Apply KA 4\na. Evolution of Game Platforms (e.g., Brown\nBox to Metaverse and beyond)\nImprovement in Computing Architectures\n(CPU and GPU); Platform Convergence\nand Mobility)\nb. Typical Game Platforms (e.g., Personal\nComputer; Home Console; Handheld\nConsole; Arcade Machine; Interactive\nTelevision; Mobile Phone; Tablet;\nIntegrated Head-Mounted Display;\nImmersive Installations and Simulators;\nInternet of Things enabled Devices; CAVE\nSystems; Web Browsers; Cloud-based\nStreaming Systems)\nc. Characteristics and Constraints of Different\nGame Platforms (e.g., Features (local\nstorage, internetworking, peripherals); Run-\ntime performance (GPU/CPU frequency,\nnumber of cores); Chipsets (physics\nprocessing units, vector co-processors);\n377\nExpansion Bandwidth (PCIe); Network\nthroughput (Ethernet); Memory types and\ncapacities (DDR/GDDR); Maximum stack\ndepth; Power consumption; Thermal\ndesign; Endian)\nd. Typical Sensors, Controllers, and Actuators\n(e.g., distinctive control system designs –\nperipherals (mouse, keypad, joystick),\ngame controllers, wearables, interactive\nsurfaces; electronics and bespoke\nhardware; computer vision, inside-out\ntracking, and outside-in tracking; IoT-\nenabled electronics and I/O\ne. eSports Ecosystems (e.g., evolution of\ngameplay across platforms; games and\neSports; game events such as LAN/arcade\ntournaments and international events such\nas the Olympic eSports Series; streamed\nmedia and spectatorship; multimedia\ntechnologies and broadcast management;\nprofessional play; data and machine\nlearning for coaching and training)\n2. Real-time Simulation and Rendering Systems\na. CPU and GPU architectures: (e.g., Flynn’s\ntaxonomy; parallelization; instruction sets;\nstandard components—graphics compute\narray, graphics memory controller, video\ngraphics array basic input/output system;\nbus interface; power management unit;\nvideo processing unit; display interface)\nb. Pipelines for physical simulations and\ngraphical rendering (e.g., tile-based,\nimmediate-mode)\nc. Common Contexts for Algorithms, Data\nStructures, and Mathematical Functions\n(e.g., game loops; spatial partitioning,\nviewport culling, and level of detail; collision\ndetection and resolution; physical\nsimulation; behavior for intelligent agents;\nprocedural content generation)\nd. Media representations (e.g., I/O, and\ncomputation techniques for virtual worlds:\naudio; music; sprites; models and textures;\n378\ntext; dialogue; multimedia (e.g., olfaction,\ntactile)\n3. Game Development Tools and Techniques:\na. Programming Languages (e.g., C++; C#;\nLua; Python; JavaScript).\nb. Shader Languages (e.g., HLSL, GLSL;\nShaderGraph)\nc. Graphics Libraries and APIs (e.g., DirectX;\nSDL; OpenGL; Metal; Vulkan; WebGL)\nd. Common Development Tools and\nEnvironments (e.g., IDEs; Debuggers;\nProfilers; Version Control Systems including\nthose handling binary assets; Development\nKits and Production/Consumer Kits;\nEmulators)\n4. Game Engines\na. Open Game Engines (e.g., Unreal; Unity;\nGodot; CryEngine; Phyre; Source 2;\nPygame and Ren’Py; Phaser; Twine;\nSpringRTS)\nb. Techniques (e.g., Ideation, Prototyping,\nIterative Design and Implementation,\nCompiling Executable Builds, Development\nOperations and Quality Assurance – Play\nTesting and Technical Testing, Profiling;\nOptimization, Porting; Internationalization\nand Localization, Networking)\n5. Game Design\na. Vocabulary (e.g., game definitions;\nmechanics-dynamics-aesthetics model;\nindustry terminology; experience design;\nmodels of experience and emotion)\nb. Design Thinking and User-Centered\nExperience Design (e.g., methods of\ndesigning games; iteration, incrementing,\nand the double-diamond; phases of pre-\nand post-production; quality assurance,\nincluding alpha and beta testing;\nstakeholder and customer involvement;\ncommunity management)\nc. Genres (e.g., adventure; walking simulator;\nfirst-person shooter; real-time strategy;\n379\nmultiplayer online battle arena (MOBA);\nrole-playing game (rpg))\nd. Audiences and Player Taxonomies (e.g.,\npeople who play games; diversity and\nbroadening participation; pleasures, player\ntypes, and preferences; Bartle, yee).\ne. Proliferation of digital game technologies to\ndomains beyond entertainment (e.g.,\nEducation and Training; Serious Games;\nVirtual Production; eSports; Gamification;\nImmersive Experience Design; Creative\nIndustry Practice; Artistic Practice;\nProcedural Rhetoric)\nCrosscutting Core Topics\nThe core topics in Society, Ethics, and the Profession (SEP) and Mathematical and Statistical\nFoundations (MSF) may be covered across the curriculum or in dedicated courses and benefit all the\ncompetency areas.\nKnowledge Area Knowledge Units CS Core KA Core\nSEP Society, Ethics, and the Profession 11 18 14\nMSF Mathematical and Statistical Foundations 5 55 145\nTotal 73 159\nSEP: Society, Ethics, and the Profession\nKU Topic Skill Core Hours\nLevel\nSEP-Context 1. Social implications (e.g., political and cultural Evaluate CS 3\nideologies) in a hyper-networked world where the\ncapabilities and impact of social media, artificial\nintelligence and computing in general are rapidly\nevolving\n2. Impact of computing applications (e.g., social Evaluate\nmedia, artificial intelligence applications) on\n380\nindividual well-being, and safety of all kinds (e.g.,\nphysical, emotional, economic)\n3. Consequences of involving computing Evaluate\ntechnologies, particularly artificial intelligence,\nbiometric technologies, and algorithmic decision-\nmaking systems, in civic life (e.g., facial\nrecognition technology, biometric tags, resource\ndistribution algorithms, policing software) and how\nhuman agency and oversight is crucial\n4. How deficits in diversity and accessibility in Evaluate\ncomputing affect society and what steps can be\ntaken to improve equity in computing\nSEP-Context 5. Growth and control of the internet, data, Explain KA 2\ncomputing, and artificial intelligence\n6. Often referred to as the digital divide, differences Evaluate\nin access to digital technology resources and its\nresulting ramifications for gender, class, ethnicity,\ngeography, and/or developing countries, including\nconsideration of responsibility to those who might\nbe less wealthy, under threat, or who would\nstruggle to have their voices heard.\n7. Accessibility issues, including legal requirements Explain\nsuch as Web Content Accessibility Guidelines\n(www.w3.org/TR/WCAG21)\n8. Context-aware computing Explain\nSEP-Ethical- 1. Avoiding fallacies and misrepresentation in Apply CS 2\nAnalysis argumentation\n2. Ethical theories and decision-making Apply\n(philosophical and social frameworks)\n3. Recognition of the role culture plays in our Evaluate\nunderstanding, adoption, design, and use of\ncomputing technology\n4. Why ethics is important in computing, and how\nethics is similar to, and different from, laws and Explain\nsocial norms\nSEP-Ethical- 5. Professional checklists Develop KA 1\nAnalysis 6. Evaluation rubrics Develop\n7. Stakeholder analysis Develop\n8. Standpoint theory Apply\n9. Introduction to ethical frameworks (e.g., Explain\nconsequentialism such as utilitarianism, non-\n381\nconsequentialism such as duty, rights, or justice,\nagent-centered such as virtue or feminism,\ncontractarianism, ethics of care) and their use for\nanalyzing an ethical dilemma\nSEP- 1. Community values and the laws by which we live Evaluate CS 2\nProfessional- 2. The nature of being a professional including care, Apply\nEthics attention, discipline, fiduciary responsibility, and\nmentoring\n3. Keeping up to date as a computing professional in Evaluate\nterms of familiarity, tools, skills, legal and\nprofessional frameworks as well as the ability and\nresponsibility to self-assess and progress in the\ncomputing field\n4. Professional certification, codes of ethics, conduct, Evaluate\nand practice, such as the ACM, IEEE, AAAI, and\nother international societies\n5. Accountability, responsibility, and liability (e.g., Apply\nsoftware correctness, reliability and safety,\nwarranty, negligence, strict liability, ethical\napproaches to security vulnerability disclosures)\nincluding whether a product/service should be\nbuilt, not just doing so because it is technically\npossible.\n6. Introduction to theories describing the human Explain\ncreation and use of technology including\ninstrumentalism, sociology of technological\nsystems, disability justice, neutrality thesis,\npragmatism, and decolonial models, including\ndeveloping and using technology to right wrongs\nand do good\n7. Strategies for recognizing and reporting designs, Apply\nsystems, software, and professional conduct (or\ntheir outcomes) that may violate law or\nprofessional codes of ethics\nSEP- 8. The role of the computing professional and Explain KA 2\nProfessional- professional societies in public policy\nEthics 9. Maintaining awareness of consequences Apply\n10. Ethical dissent and whistleblowing Explain\n11. The relationship between regional culture and Evaluate\nethical dilemmas\n12. Dealing with harassment and discrimination Explain\n13. Forms of professional credentialing Explain\n382\n14. Ergonomics and healthy computing environments Explain\n15. Time-to-market and cost considerations versus Explain\nquality professional standards\nSEP-IP 1. Intellectual property rights Explain CS 1\n2. Intangible digital intellectual property (IDIP) Explain\n3. Legal foundations for intellectual property Evaluate\nprotection\n4. Common software licenses (e.g., MIT, GPL and its Evaluate\nvariants, Apache, Mozilla, Creative Commons)\n5. Plagiarism and authorship Explain\nSEP-IP 6. Philosophical foundations of intellectual property Explain KA 1\n7. Forms of intellectual property (e.g., copyrights, Explain\npatents, trade secrets, trademarks) and the rights\nthey protect\n8. Limitations on copyright protections, including fair Explain\nuse and the first sale doctrine\n9. Intellectual property laws and treaties that impact Explain\nthe enforcement of copyrights\n10. Software piracy and technical methods for Explain\nenforcing intellectual property rights, such as\ndigital rights management and closed source\nsoftware as a trade secret\n11. Moral and legal foundations of the open-source Explain\nmovement\n12. Systems that use others’ data (e.g., large Explain\nlanguage models)\nSEP-Privacy 1. Privacy implications of widespread data collection Explain CS 2\nincluding but not limited to transactional\ndatabases, data warehouses, surveillance\nsystems, cloud computing, and artificial\nintelligence\n2. Conceptions of anonymity, pseudonymity, and Evaluate\nidentity\n3. Technology-based solutions for privacy protection Evaluate\n(e.g., end-to-end encryption and differential\nprivacy)\n4. Civil liberties, privacy rights, and cultural Explain\ndifferences\nSEP-Privacy 5. Philosophical and legal conceptions of the nature Explain KA 1\nof privacy including the right to privacy\n383\n6. Legal foundations of privacy protection in relevant Explain\njurisdictions (e.g., GDPR in the EU)\n7. Privacy legislation in areas of practice (e.g., Evaluate\nHIPAA in the US, AI Act in the EU)\n8. Basic Principles of human-subjects research and Explain\nprinciples beyond what the law requires (e.g.,\nBelmont Report, UN Universal Declaration on\nHuman Rights and how this relates to technology)\n9. Freedom of expression and its limitations Evaluate\n10. User-generated content, content moderation, and Explain\nliability\nSEP- 1. Oral, written, and electronic team and group Apply CS 2\nCommunicatio communication\nn 2. Technical communication materials (e.g., source Develop\ncode and documentation, tutorials, reference\nmaterials, API documentation)\n3. Communicating with different stakeholders such Apply\nas customers, leadership, or the public\n4. Team collaboration (including tools) and conflict Apply\nresolution\n5. Accessibility and inclusivity requirements for Apply\naddressing professional audiences\n6. Cultural competence in communication including Develop\nconsidering the impact of difference in natural\nlanguage\nSEP- 7. Tradeoffs in competing factors that affect Evaluate KA 1\nCommunicatio communication channels and choices\nn 8. Communicating to solve problems or make Apply\nrecommendations in the workplace, such as\nraising ethical concerns or addressing accessibility\nissues\nSEP- 1. Environmental, social, and cultural impacts of Evaluate CS 1\nSustainability implementation decisions (e.g., sustainability\ngoals, algorithmic bias/outcomes, economic\nviability, and resource consumption)\n2. Local/regional/global social and environmental Evaluate\nimpacts of computing systems and their use (e.g.,\ncarbon footprints, resource usage, e-waste) in\nhardware (e.g., e-waste, data centers, rare\nelement and resource utilization, recycling) and\nsoftware (e.g., cloud-based services, blockchain,\n384\nAI model training and use), not neglecting the\nimpact of everyday use such as hardware (cheap\nhardware replaced frequently) and software (web-\nbrowsing, email, and other services with\nhidden/remote computational demands)\n3. Guidelines for sustainable design standards Develop\nSEP- 4. Systemic effects of complex computing Evaluate KA 1\nSustainability technologies and phenomena (e.g., generative AI,\ndata centers, social media, offshoring, remote\nwork)\n5. Pervasive computing – information processing that Evaluate\nhas been integrated into everyday objects and\nactivities, such as smart energy systems, social\nnetworking, and feedback systems to promote\nsustainable behavior, transportation,\nenvironmental monitoring, citizen science and\nactivism\n6. How the sustainability of software systems is Explain\ninterdependent with social systems, including the\nknowledge and skills of its users, organizational\nprocesses and policies, and its societal context\n(e.g., market forces, government policies)\nSEP-History 1. The history of computing: hardware, software, and Explain CS 1\nhuman/organizational\n2. The role of history in the present including within Evaluate\ndifferent social contexts, and the relevance of this\nhistory on the future\nSEP-History 3. Age I (Pre-digital) – Ancient analog computing Explain KA 1\n(Stonehenge, Antikythera mechanism, Salisbury\nCathedral clock, etc.), human-calculated number\ntables, Euclid, Lovelace, Babbage, Gödel, Church,\nTuring, pre-electronic (electro-mechanical and\nmechanical) hardware\n4. Age II (Early modern computing) – ENIAC, Explain\nUNIVAC, Bombes (Bletchley Park and\ncodebreakers), computer companies (e.g., IBM),\nmainframes, etc.\n5. Age III (PC era) – PCs, modern computer Explain\nhardware and software, Moore’s Law\n6. Age IV (Internet) – Networking, internet Explain\narchitecture, browsers and their evolution,\n385\nstandards, born-on-the-internet companies, and\nservices (e.g., Google, Amazon, Microsoft, etc.),\ndistributed computing\n7. Age V (Mobile & Cloud) – Mobile computing and Explain\nsmartphones, cloud computing and models thereof\n(e.g., SaaS), remote servers, security and privacy,\nsocial media\n8. Age VI (AI) – Decision making systems, Explain\nrecommender systems, generative AI and other\nmachine learning driven tools and technologies\nSEP- 1. Economic models – regulated and unregulated, Explain KA 1\nEconomies monopolies, network effects, and open market;\nknowledge and attention economies\n2. Pricing and deployment strategies – planned Explain\nobsolescence, subscriptions, freemium, software\nlicensing, open-source, free software, adware\n3. Impacts of differences in access to computing Evaluate\nresources, and the effect of skilled labor supply\nand demand on the quality of computing products\n4. Automation, AI, and their effects on job markets, Explain\ndevelopers, and users\n5. Ethical concerns surrounding the attention Evaluate\neconomy and other economies of computing (e.g.,\ninformed consent, data collection, use of verbose\nlegalese in user agreements)\nSEP-Security 1. Computer crimes, legal redress for computer Explain CS 2\ncriminals and impact on victims and society\n2. Social engineering, computing-enabled fraud,\nidentity theft and recovery from these Explain\n3. Cyber terrorism, criminal hacking, and hacktivism\n4. Malware, viruses, worms Explain\n5. Attacks on critical infrastructure such as electrical Explain\ngrids and pipelines Explain\n6. Non-technical fundamentals of security (e.g.,\nhuman engineering, policy, confidentiality) Explain\nSEP-Security 7. Benefits and challenges of existing and proposed Evaluate KA 1\ncomputer crime laws\n8. Security policies and the challenges of change and Explain\ncompliance\n9. Responsibility for security throughout the Explain\ncomputing life cycle\n386\n10. International and local laws and how they intersect Explain\nSEP-DEIA 1. How identity impacts and is impacted by Explain CS 2\ncomputing technologies and environments\n(academic and professional)\n2. The benefits of diverse development teams and Explain\nthe impacts of teams that are not diverse\n3. Inclusive language and charged terminology, and Apply\nwhy their use matters\n4. Inclusive behaviors and why they matter Explain\n5. Designing and developing technology with Explain\naccessibility in mind\n6. How computing professionals can influence and Explain\nimpact diversity, equity, inclusion, and\naccessibility, including but not only through the\nsoftware they create\nSEP-DEIA 7. Experts and their practices that reflect the Evaluate KA 2\nidentities of the classroom and the world through\npractical DEIA principles\n8. Historic marginalization due to systemic social Explain\nmechanisms, technological supremacy and global\ninfrastructure challenges to diversity, equity,\ninclusion, and accessibility\n9. Cross-cultural differences in, and needs for, Explain\ndiversity, equity, inclusion, and accessibility\nMSF: Mathematical and Statistical Foundations\nKU Topic Skill Core Hours\nLevel\nMSF-Discrete 1. Sets, relations, functions, cardinality Apply, CS/KA 29-40\n2. Recursive mathematical definitions Develop\n3. Proof techniques (induction, proof by contradiction) ,\n4. Permutations, combinations, counting, pigeonhole Explain\nprinciple\n5. Modular arithmetic\n6. Logic: truth tables, connectives (operators),\ninference rules, formulas, normal forms, simple\npredicate logic\n7. Graphs: basic definitions\n8. Order notation\n387\nMSF- 1. Basic notions: sample spaces, events, probability, CS- CS/KA 11-40\nProbability conditional probability, Bayes’ rule Core:\n2. Discrete random variables and distributions Apply\n3. Continuous random variables and distributions\n4. Expectation, variance, law of large numbers, KA-\ncentral limit theorem Core:\n5. Conditional distributions and expectation Apply,\n6. Applications to computing, the difference between Develop\nprobability and statistics (as subjects) ,\nExplain\nMSF-Statistics 1. Basic definitions and concepts: populations, Develop CS 10\nsamples, measures of central tendency, variance\n2. Univariate data: point estimation, confidence\nintervals\nMSF-Statistics 3. Multivariate data – estimation, correlation, Apply, KA 30\nregression Explain\n4. Data transformation – dimension reduction,\nsmoothing\n5. Statistical models and algorithms\n6. Hypothesis testing\nMSF-Linear 1. Vectors – definitions, vector operations, geometric Develop CS 5\ninterpretation, angles; Matrices – definition, matrix\noperations, meaning of Ax=b\nMSF-Linear 2. Matrices, matrix-vector equation, geometric Apply, KA 35\ninterpretation, geometric transformations with Explain\nmatrices\n3. Solving equations, row-reduction\n4. Linear independence, span, basis\n5. Orthogonality, projection, least-squares, orthogonal\nbases\n6. Linear combinations of polynomials, Bezier curves\n7. Eigenvectors and eigenvalues\n8. Applications to computer science – PCA, SVD,\npage-rank, graphics\nMSF-Calculus 1. Sequences, series, limits Apply, KA 40\n2. Single-variable derivatives – definition, Develop\ncomputation rules (chain rule, etc.), derivatives of\nimportant functions, applications\n3. Single-variable integration – definition, computation\nrules, integrals of important functions, fundamental\ntheorem of calculus, definite vs indefinite,\napplications (including in probability)\n4. Parametric and polar representations\n388\n5. Taylor series\n6. Multivariate calculus – partial derivatives, gradient,\nchain-rule, vector valued functions,\n7. Optimization – convexity, global vs local minima,\ngradient descent, constrained optimization, and\nLagrange multipliers\n8. ODEs – definition, Euler method, applications to\nsimulation, Monte Carlo integration\n9. CS applications – gradient descent for machine\nlearning, forward and inverse kinematics,\napplications of calculus to probability\n389\n390\nCurricular Packaging\nA few curricular packaging options of various sizes are presented here. These can be adapted to local\nstrengths and needs to create a customized computer science curriculum. In each case, an effort\nshould be made to include all the CS Core topics in required courses in the curriculum. The more KA\nCore topics covered, the greater the breadth of the curriculum. The more hours dedicated to KA Core\ntopics, the greater the depth of the curriculum. Non-core topics add to the richness of the curriculum. In\neach curricular model, a capstone course is included to emphasize the importance of an integrative\nhands-on experience. It may also serve as the course where CS Core topics not covered elsewhere in\nthe curriculum can be incorporated.\n8 Course Model\nThis is a minimal course configuration that covers all the CS Core topics. However, it does not leave\nmuch room for exploration:\n1. CS I (AL-2, FPL-1, SDF-34, SEP-3)\n2. CS II (AL-18, FPL-4, MSF-4, SDF-9, SEC-1, SEP-3)\n3. Mathematical and Statistical Foundations (MSF-40)\n4. Algorithms (AL-12, MSF-11, PDC-2, SEP-3)\n5. Introduction to Computing Systems (SF-18, OS-8, AR-9, NC-7, SEP-2)\n6. Programming Language Concepts (FPL-16, PDC-7, SEP-2)\n7. Introduction to Computing Applications (SEC-5, AI-12, GIT-4, DM-10, SEP-3)\n8. Capstone (SE-6, HCI-8, SPD-3, SEP-2)\n10 Course Model\n1. CS I (SDF, SEP)\n2. CS II (SDF, FPL-4, AL-12, SEP)\n3. Mathematical and Statistical Foundations (MSF)\n4. Data Structures and Algorithms (AL-20, AI, MSF, SEP)\n5. Introduction to Computing Systems (SF, OS, AR, NC)\n6. Programming Languages (FPL-17, AL, PDC, SEP)\n7. Software Engineering (SE, HCI, GIT, PDC, SPD, DM, SEP)\n8. One Systems elective:\na. Operating Systems (OS, PDC)\nb. Computer Architecture (AR)\nc. Parallel and Distributed Computing (PDC)\nd. Networking (NC, SEC, SEP)\ne. Databases (DM, SEP)\n9. One elective from Applications:\na. Artificial Intelligence (AI, MSF, SPD, SEP)\nb. Graphics (GIT, HCI, MSF, SEP)\n391\nc. Application Security (SEC, SEP)\nd. Human-Centered Design (HCI, GIT, SEP)\n10. Capstone (SE, SEP)\n12 Course Model\n1. CS I (SDF, SEP)\n2. CS II (SDF, AL-12, DM, SEP)\n3. Mathematical and Statistical Foundations (MSF)\n4. Algorithms (AL-20, AI, MSF, SEC, SEP)\n5. Introduction to Computing Systems (SF, OS, AR, NC)\n6. Programming Languages (FPL, AL, PDC, SEP)\n7. Software Engineering (SE, HCI, GIT, PDC, SPD, DM, SEP)\n8. Two from Systems electives:\na. Operating Systems (OS, PDC)\nb. Computer Architecture (AR)\nc. Parallel and Distributed Computing (PDC)\nd. Networking (NC, SEC, SEP)\ne. Databases (DM, SEP)\n9. Two electives from Applications:\na. Artificial Intelligence (AI, MSF, SPD, SEP)\nb. Graphics (GIT, HCI, MSF, SEP)\nc. Application Security (SEC, SEP)\nd. Human-Centered Design (HCI, GIT, SEP)\n10. Capstone (SE, SEP)\n16 Course Model\nThree different models are presented here, each with its own benefits.\nModel 1:\n1. CS I (SDF, SEP)\n2. CS II (SDF, AL-12, DM, SEP)\n3. Mathematical and Statistical Foundations (MSF)\n4. Algorithms (AL-20, SEP)\n5. Introduction to Computing Systems (SF, SEP)\n6. Programming Languages (FPL, AL, PDC, SEP)\n7. Theory of Computation (AL-32, SEP)\n8. Software Engineering (SE, HCI, GIT, PDC, SPD, DM, SEP)\n9. Operating Systems (OS, PDC, SEP)\n10. Computer Architecture (AR, SEP)\n11. Parallel and Distributed Computing (PDC, SEP)\n392\n12. Networking (NC, SEP)\n13. Pick one of:\na. Introduction to Artificial Intelligence (AI, MSF, SEP)\nb. Machine Learning (AI, MSF, SEP)\nc. Robotics (AI, SPD, SEP)\n14. Pick one of:\na. Graphics (GIT, MSF, SEP)\nb. Human-Centered Design (GIT, SEP)\nc. Animation (GIT, SEP)\nd. Virtual Reality (GIT, SEP)\n15. Security (SEC, SEP)\n16. Capstone (SE, SEP)\nModel 2:\n1. CS I (SDF, SEP)\n2. CS II (SDF, AL, DM, SEP)\n3. Mathematical and Statistical Foundations (MSF, AI, DM)\n4. Algorithms (AL, MSF, SEP)\n5. Introduction to Computing Systems (SF, SEP)\n6. Programming Languages (FPL, AL, PDC, SEP)\n7. Theory of Computation (AL, SEP)\n8. Software Engineering (SE, HCI, GIT, PDC, SPD, DM, SEP)\n9. Operating Systems (OS, PDC, SEP)\n10. Two electives from:\na. Computer Architecture (AR, SEP)\nb. Parallel and Distributed Computing (PDC, SEP)\nc. Networking (NC, SEP)\nd. Network Security (NC, SEC, SEP)\ne. Security (SEC, SEP)\n11. Pick three of:\na. Introduction to Artificial Intelligence (AI, MSF, SEP)\nb. Machine Learning (AI, MSF, SEP)\nc. Deep Learning (AI, MSF, SEP)\nd. Robotics (AI, SPD, SEP)\ne. Data Science (AI, DM, GIT, MSF)\nf. Graphics (GIT, MSF, SEP)\ng. Human-Computer interaction (HCI, SEP)\nh. Human-Centered Design (GIT, HCI, SEP)\ni. Animation (GIT, SEP)\nj. Virtual Reality (GIT, SEP)\nk. Physical Computing (GIT, SPD, SEP)\n12. Society, Ethics, and the Profession (SEP)\n13. Capstone (SE, SEP)\n393\nModel 3:\n1. CS I (SDF, SEP)\n2. CS II (SDF, AL, DM, SEP)\n3. Mathematical and Statistical Foundations (MSF)\n4. Algorithms (AL, AI, MSF, SEC, SEP)\n5. Introduction to Computing Systems (SF, OS, AR, NC)\n6. Programming Languages (FPL, AL, PDC, SEP)\n7. Software Engineering (SE, HCI, GIT, PDC, SPD, DM, SEP)\n8. Two from Systems electives:\na. Operating Systems (OS, PDC)\nb. Computer Architecture (AR)\nc. Parallel and Distributed Computing (PDC)\nd. Networking (NC, SEC, SEP)\ne. Databases (DM, SEP)\n9. Two electives from Applications:\na. Artificial Intelligence (AI, MSF, SPD, SEP)\nb. Graphics (GIT, HCI, MSF, SEP)\nc. Application Security (SEC, SEP)\nd. Human-Centered Design (HCI, GIT, SEP)\n10. Three open CS electives\n11. Society, Ethics, and the Profession (SEP) course\n12. Capstone (SE, SEP)\n394\nCompetency Framework Examples\nSample Tasks\nSample tasks have been listed here for various combinations of component, activity and constraint for\nthe three representative competency areas: software, systems and applications. Many, but not all the\ntasks are atomic. The tasks are not restricted to those that require CS or KA Core topics only.\nSoftware Competency Area\nComponent – Tasks with constraint(s) italicized\nActivity\nProgram – Design ● Design efficient data structures for a problem\n● Design test cases to determine if a program is functionally correct\n● Design an API for a service\nProgram – Develop ● Write a program that meets a given specification\n● Automate testing of new code under development\n● Develop a program that leverages libraries and APIs\n● Work in a team effectively to solve a problem\nProgram – Document ● Document a program\n● Consistently format source code.\nProgram – Evaluate ● Evaluate an existing application (open source or proprietary) as a\nwhole or partial solution for meeting a defined requirement\nProgram – Maintain ● Refactor a program.\n● Perform code review to evaluate the quality of code\nProgram – Humanize ● Ensure fair and equitable access in a program\n● Document the accountability, responsibility, and liability an\nindividual/company assumes when releasing a given\nservice/software/product\n● Incorporate legal and ethical privacy requirements into a given\nservice/software/product’s development cycle\n● Convey the benefits of diverse development teams and user\nbases on the services/software/products the company provides,\nas well as the impacts that a lack of diversity can have on them\nProgram – Improve ● Debug a program\nProgram – Research ● Compute the running time of a program\n● Formally prove the correctness of code\nAlgorithm – Design ● Design an efficient algorithm for a problem\nAlgorithm – ● Explain how an algorithm satisfies a set of requirements\nDocument\nAlgorithm – Evaluate ● Evaluate the efficiency of an algorithm\n395\nAlgorithm – Maintain ● Redesign an algorithm to improve a non-functional requirement\nAlgorithm – ● Justify that an algorithm provides fair and equitable access to\nHumanize data\nAlgorithm – Research ● Prove the correctness of an algorithm\n● Compute the run time efficiency of an algorithm\nLanguage/Paradigm ● Select an appropriate language/paradigm for an application\n– Design\nLanguage/Paradigm ● Justify the choice of a language/paradigm for a program\n– Document ● Write a white paper to describe how a program is translated into\nmachine code and executed\n● White a white paper explaining how a program executes in an\nefficient manner with respect to memory and CPU utilization\nLanguage/Paradigm ● Evaluate the appropriateness of a language/paradigm for an\n– Evaluate application\n● Explain the benefits and challenges of converting an application\ninto parallel/distributed versions\n● Write a white paper explaining how a program effectively utilizes\nlanguage features to make it safe and secure\nSystems Competency Area\nComponent – Tasks with constraint(s) italicized\nActivity\nProcessor – Design ● Revise a specification to enable parallel processing without\nviolating other essential properties or features\nProcessor – Develop ● Develop a version of CPU-based application to run on a hardware\naccelerator (GPU, TPU, NPU)\n● Implement a parallel/distributed version of a known algorithm\nProcessor – Evaluate ● Evaluate the performance-watt of a machine learning model\ndeployed on an embedded device\nProcessor – Improve ● Identify and repair a performance problem due to sequential\nbottlenecks\nStorage – Evaluate ● Assess the performance implications of cache memories in an\napplication\n● Apply knowledge of operating systems to assess page faults in\nCPU-GPU memory management and their performance impact on\nan accelerated application\nI/O – Design ● Design software modules for sensor hardware integration\nI/O – Develop ● Develop a sensing-actuator robotics arm for an automated\nmanufacturing cell\n396\n● Develop a benchmarking software tool to assess the performance\ngain in removing I/O bottlenecks in code\nCommunication – ● Design a networking protocol.\nDesign ● Design software that enables safe communication between\nprocesses\nCommunication – ● Develop a networked application\nDevelop ● Deploy and securely operate a network of wireless sensors.\n● Develop software that enables safe communication between\nprocesses\nCommunication – ● Evaluate the performance of a network, in specific latency,\nEvaluate throughput, congestion, and various service levels\nCommunication – ● Defend a network from an ongoing distributed denial-of-service\nMaintain attack\nCommunication – ● Write a white paper to explain social, ethical, and professional\nHumanize issues governing the design and deployment of a networked\nsystem\nCommunication – ● Identify failures in a datacenter network\nImprove ● Identify and repair a performance problem due to communication\nor data latency\nArchitecture – ● Deploy a system in a cloud environment\nDevelop ● Deploy an application component on a virtualized container\nArchitecture – ● Find the performance bottleneck of a given system architecture\nEvaluate\nData – Design ● Design how a new application’s data will be stored\nData – Develop ● Create a database for a new application\nData – Maintain ● Get data back online after a disruption (e.g., power outage)\nData – Humanize ● Produce a white paper assessing the social and ethical\nimplications of collecting and storing the data from a new (or\nexisting) application\n● Assess the legal and ethical implications of collecting and using\ncustomer/user data\nData – Improve ● Improve a database application’s performance (speed)\n● Modify a concurrent system to use a more scalable, reliable or\navailable data store\nApplications Competency Area\nComponent – Tasks with constraint(s) italicized\nActivity\nInput – Design ● Design an intuitive user interface for an application\nInput – Develop ● Implement the user interface of an application\nInput – Humanize ● Write a paper on the accessibility of a user interface\n397\nComputation – ● Specify the operators and partial-order planning graph to solve a\nDesign logistics problem, showing all ordering constraints\nComputation – ● Implement an agent to play a two-player complete information\nDevelop board game\n● Write a program that uses Bayes rule to predict the probability of\ndisease given the conditional probability table and a set of\nobservations\n● Train a neural network to play a video game (e.g., Mario, Atari)\nComputation – ● Compare the performance of three supervised learning models on\nEvaluate a dataset\n● Explain some of the pitfalls of deep generative models for image\nor text and how this can affect their use in an application\nComputation – ● Write an essay on the effects of data set bias and how to mitigate\nHumanize them\nPlatform – Design ● Determine whether to develop an app as a native app or as a cross-\nplatform app\nPlatform – Develop ● Create a mobile app that provides a consistent user experience\nacross various devices, screen sizes, and operating systems\n● Develop a secure web interface for a business application\nPlatform – Evaluate ● Evaluate the usability and accessibility of an immersive system\nPlatform – Improve ● Optimize a dynamic web site for evolving business needs\nSample Competency Specifications\nThe following are some sample competency specifications for tasks that require various knowledge\nareas and skills. They have been listed under the three competency areas, that is, Software, Systems,\nand Applications.\nSoftware Competency Area\n● Task Software1: Develop test cases to determine if a program is functionally correct.\n● Competency statement: Develop test cases and test a given program.\n● Required knowledge:\n○ SDF-Practices\n● Required skills: Develop\n● Desirable professional dispositions: Meticulous, Persistent, Responsible\n398\nThis is a compound task: the component is a\nset of test cases for a program; the activities\nare design, develop, and document; and the\nconstraint is verifying the correctness of\nimplementation of the program.\n● Task Software2: Perform code review for a teammate.\n● Competency statement: Communicate clearly and collaboratively to provide\nfeedback to a teammate about a piece of code.\n● Required knowledge:\n○ SDF-Practices\n○ SE-Teamwork\n○ SE-Validation\n● Required skills: Apply\n● Desirable professional dispositions: Collaborative, Communicative, Meticulous\n● Task Software3: Work on a team effectively.\n● Competency statement: Focus on long-term team dynamics and communicate\neffectively.\n● Required knowledge:\n○ SE-Teamwork\n● Required skills: Apply\n● Desirable professional dispositions: Collaborative, Communicative, Proactive,\nResponsive\n● Task Software4: Make an informed decision regarding which programming\nlanguage/paradigm to select and use for a specific application.\n● Competency statement: Apply knowledge of multiple programming paradigms,\nincluding their strengths and weaknesses relative to the application to be developed,\nand select an appropriate paradigm and programming language.\n● Required knowledge:\n○ FPL-OOP\n○ FPL-Functional\n○ FPL-Logic\n○ FPL-Event-Driven\n○ FPL-Types\n○ FPL-Translation\n○ FPL-Pragmatics\n399\n○ SPD-Embedded\n○ FPL- Constructs\n● Required skills: Explain, Evaluate\n● Desirable professional dispositions: Inventive\n● Task Software5: Effectively use a programming language’s type system to develop\nsafe and secure software.\n● Competency statement: Apply knowledge of static type rules for a language to\nensure an application is safe, secure, and correct.\n● Required knowledge:\n○ FPL-Types\n● Required skills: Develop\nDesirable professional dispositions: Inventive, Meticulous\nSystems Competency Area\n● Task Systems1: Develop a version of a CPU-based application to run on a hardware\naccelerator (GPU, TPU, NPU).\n● Competency statement: Apply knowledge from systems design to accelerate an\napplication code and evaluate the code speed-up.\n● Required knowledge:\n○ AR-Heterogeneity\n○ PDC-Programs\n○ SF-Design\n● Required skills: Evaluate, Develop\n● Desirable professional dispositions: Meticulous, Inventive\n● Task Systems2: Produce a white paper assessing the social and ethical implications\nof collecting and storing data from a new (or existing) application.\n● Competency statement: Identify the stakeholders and evaluate the potential long-\nterm consequences of the collection and retention of data objects. Consider both\npotential harm from unintended data use and from data breaches.\n● Required knowledge:\n○ SEP-Context\n○ SEP-Ethical-Analysis\n○ SEP-Privacy\n○ SEP-Professional-Ethics\n○ SEP-Security\n○ SEP- DEIA\n○ DM-Data\n○ SEC-Foundations\n● Required skills: Evaluate, Explain\n400\n● Desirable professional dispositions: Meticulous, Responsible, Proactive\nThis is a compound task: the component is\ndata; the activities are evaluate and\nhumanize; the constraint is the design of the\nsolution vis-à-vis social and ethical\nimplications.\n● Task Systems3: Secure data from unauthorized access.\n● Competency statement: Create database views to ensure data access is\nappropriately limited.\n● Required knowledge:\n○ DM-Data\n○ DM-Relational\n○ DM-Processing\n○ SEP-Security\n○ SEP-Professional-Ethics\n○ SEP-Privacy\n○ SEC-Foundations\n● Required skills: Develop\n● Desirable professional dispositions: Meticulous, Proactive\n● Task Systems4: Create a database for a new application.\n● Competency statement: Design the data storage needs (data modeling), assess the\nsocial and ethical implications for collecting and storing the data, determine how to\nstore a new application’s data (RDBMS vs NoSQL), and create the database,\nincluding appropriate indices.\n● Required knowledge:\n○ DM-Data\n○ DM-Core\n○ DM-Modeling\n○ DM-Relational\n○ DM-NoSQL\n○ DM-Internals\n○ SEP-Context\n○ SEP-Ethical-Analysis\n○ SEP-Privacy\n401\n○ SEP-Professional-Ethics\n○ SEP-Security\n○ SEP- DEIA\n○ SEC-Foundations\n● Required skills: Develop\n● Desirable professional dispositions: Inventive, Meticulous, Responsible\n● Task Systems5: Evaluate the performance of a network.\n● Competency statement: Evaluate the latency, throughput, congestion, and various\nservice levels of a network.\n● Required knowledge:\n○ NC-Applications\n○ NC-Routing\n● Required skills: Evaluate\n● Desirable professional dispositions: Meticulous, Proactive\n● Task Systems6: Deploy an application component on an operating system/\nruntime/virtualized operating system/container.\n● Competency statement: Identify and mitigate potential problems with deployment;\nautomate setup of deployment environment; set up monitoring of component\nexecution.\n● Required knowledge:\n○ OS-Purpose\n○ OS-Principles\n○ OS-Concurrency\n○ OS-Scheduling\n○ OS-Process\n○ OS-Memory\n○ OS-Protection\n○ AR-Assembly\n○ FPL-Scripting\n● Required skills: Apply\n● Desirable professional dispositions: Meticulous, Persistent, Proactive\n● Task Systems7: Improve the performance of a sequential application or component\nby introducing parallelism.\n● Competency statement: Evaluate how and when parallelism can improve (or not\nimprove) performance well enough to identify opportunities, as well as implement them\nand measure the results.\n● Required knowledge:\n○ PDC-Evaluation\n402\n○ FPL-Parallel\n● Required skills: Evaluate, Develop\n● Desirable professional dispositions: Meticulous, Persistent, Proactive\n● Task Systems8: Find the performance bottleneck of a given system.\n● Competency statement: Given a system and its target deployment environment, find\nits performance bottleneck (e.g., memory, CPU, networking) through analytical\nderivation or experimental study.\n● Required knowledge:\n○ SF-Performance\n○ SF-Evaluation\n○ SF-Design\n○ SF-Overview\n● Required skills: Apply, Evaluate, Develop\n● Desirable professional dispositions: Meticulous, Persistent\nApplications Competency Area\n● Task Applications1: Implement an agent to make strategic decisions in a two-player\nadversarial game with uncertain actions (e.g., a board game, strategic stock purchasing).\n● Competency statement: Use minimax with alpha-beta pruning, and possible chance nodes\n(expectiminimax), and heuristic move evaluation (at a particular depth) to solve a two-player\nzero-sum game.\n● Required knowledge:\n○ AI-Search\n○ AI-KRR\n● Required skills: Apply, Develop\n● Desirable professional dispositions: Inventive, Persistent\nThis is a compound task: the component is\ncomputation, i.e., an algorithm designed for the\nspecific problem of two-player game; the\nactivities are design and develop; the\nconstraints are imposed by the problem –\nadversarial game with uncertain actions.\n403\n● Task Applications2: Analyze tabular data (e.g., customer purchases) to identify trends and\npredict variables of interest.\n● Competency statement: Use machine learning libraries, data preprocessing, training\ninfrastructures, and evaluation methodologies to create a basic supervised learning pipeline.\n● Required knowledge:\n○ AI-ML\n○ AI-SEP\n● Required skills: Apply, Develop\n● Desirable professional dispositions: Meticulous, Persistent, Responsible\n● Task Applications3: Critique a deployed machine learning model in terms of potential bias\nand correct the issues.\n● Competency statement: Understand, recognize, and evaluate issues of data set bias in AI,\nthe types of bias, and algorithmic strategies for mitigation.\n● Required knowledge:\n○ AI-ML\n○ AI-SEP\n● Required skills: Explain\n● Desirable professional dispositions: Responsible\n● Task Applications4: Visualize a region’s temperature record.\n● Competency statement: Given weather data for a region, design and implement an\nanimation depicting temperature changes over time.\n● Required knowledge:\n○ GIT-Fundamentals\n○ GIT-Rendering\n○ GIT-Visualization\n○ HCI-Design\n○ HCI-User\n● Required skills: Apply, Evaluate, Develop\n● Desirable professional dispositions: Inventive, Persistent\n● Task Applications5: Evaluate and provide recommendations to improve a user-facing\nsystem.\n● Competency statement: Apply knowledge of usability, accessibility, and inclusivity to\nevaluate a user-facing system.\n● Required knowledge:\n○ HCI-User\n○ HCI-Accessibility\n○ HCI-Evaluation\n○ HCI-Design\n404\n○ HCI-SEP\n● Required skills: Evaluate\n● Desirable professional dispositions: Meticulous, Responsible\n● Task Applications6: Determine the aspects of an implementation that require revision\nto support internationalization.\n● Competency statement: Evaluate a system to identify culturally-relevant or language-\nrelevant text, symbols, and patterns that may vary by locale.\n● Required knowledge:\n○ HCI-User\n○ HCI-Accountability\n○ HCI-Accessibility\n○ HCI-Evaluation\n● Required skills: Evaluate\n● Desirable professional dispositions: Meticulous, Proactive, Responsible\n● Task Applications7: Document the professional implications of a\nservice/software/product for the company that produced it.\n● Competency statement: Gather information regarding accountability,\nresponsibility and liability assumed by a company when releasing a\nservice/software/product and present it in a coherent and actionable manner.\n● Required knowledge:\n○ SEP-Professional-Ethics\n○ SEP-IP\n○ SEP-Privacy\n○ SEP-Communication\n○ SEP-DEIA\n● Required skills: Explain\n● Desirable professional dispositions: Meticulous, Proactive, Responsible\n● Task Applications8: Determine whether to develop an app as a native app or as a\ncross-platform app.\n● Competency statement: Understand performance and scalability issues, and\nevaluate different approaches and tools by carefully considering factors such as app\nrequirements, target audience, time-to-market, and costs.\n● Required knowledge:\n○ SE-Tools\n○ SPD-Common\n○ SPD-Mobile\n● Required skills: Explain\n● Desirable professional dispositions: Inventive, Meticulous, Responsible\n405\n● Task Applications9: Build and optimize a secure web page for evolving business\nneeds using a variety of appropriate programming languages.\n● Competency statement: Evaluate potential security hazards and apply optimization\ntechniques.\n● Required knowledge:\n○ AR-Performance-Energy\n○ NC-Security\n○ OS-Protection\n○ SF-Security\n○ SE-Design\n○ SE-Tools\n○ SPD-Common\n○ SPD-Mobile\n○ SEP-Privacy\n● Required skills: Develop\n● Desirable professional dispositions: Adaptable, Meticulous, Proactive, Responsible\n406\nPedagogy and\nPractices\n1. Pedagogical Considerations\n2. Curricular Practices in Computer Science\n3. Generative AI and the Curriculum\n407\n408\nPedagogical Considerations\nIntroduction\nWhat are some current trends in the teaching and learning of computer science? What are the\ncontroversies of the day in terms of the pedagogy of computer science education? In this section, a top\nfew trends, controversies, and challenges have been listed for each knowledge area as well as the\ncurriculum as a whole. These issues are expected to influence the future evolution of computer science\ncurricula.\nCurriculum-Wide Considerations\nThe adoption of CS2023’s recommendations presents numerous challenges at both the macro and the\nmicro level. Some of the macro considerations include the following.\n● Active learning is an important component of any computer science course – doing helps learn\ncomputer science. Courses that use interactive electronic resources (e.g., eBooks, python\nnotebooks) are a significant improvement over the traditional lecture-based courses that do not\ninvolve any active learning component – they provide ample opportunities to learn by solving\nproblems. In this regard, it is important to emphasize that ideally, active learning should cover the\nentire gamut of skill levels – not just apply, but also evaluate and develop.\n● The success of generative AI systems is causing faculty to reconsider their approach to\nassessment. Student grades are increasingly being based on in-class, closed-book assessments.\nCare should be taken not to lose sight of the objective of assessment when using expedient\nassessment techniques.\n● The landscape of computer science textbooks is in flux. The number of traditional publishing\nhouses is shrinking, the cost of their offerings is increasing, and the vast majority of these resources\nare primarily only in English – though generative AI systems are making important inroads in\nproviding accurate translations. Digital rentals, while cheaper, usually disappear at term’s end and\nare unavailable as future references. Open Educational Resources (OER) present a cost-effective\nalternative, but often lack formal review. Compounding this are students who, for financial and\ngenerational reasons, forgo acquiring the selected text(s) in favor of self-selected YouTube videos.\n● Broadening participation in computing is an ongoing concern in many contexts. Adopters of CS2023\nshould remain cognizant of how their curricular and pedagogical choices affect this important issue.\n● Studying abroad is a quintessential high impact learning experience. One potential impediment to\nits wide-spread adoption is curriculum design. This can include long prerequisite chains and dense\ncurricula. Care should be taken to leave room for, if not encouraged, penalty-free study abroad.\n409\nConsiderations by Knowledge Area\nArtificial Intelligence (AI)\n● A balance must be struck between 1) the need to study fundamental issues of search and other\napproaches that are still in widespread use and 2) the desire to focus on cutting-edge AI and\nmachine learning methods.\n● Given AI’s current and future potential for societal impact, educators should ensure that all students\nare well-versed in the ethical and societal considerations and implications of applying AI methods.\n● Since AI is rapidly evolving as a field, it is challenging to create a curriculum that will remain current\nfor long. Consequently, the onus is on the instructors to keep up to date with current methods and\nuse their judgment in determining what to teach in order to keep their courses current.\nAlgorithmic Foundations (AL)\n● Should computer science graduates be able to explain, at some level, algorithmic approaches\nmaking headlines in the popular press, such as Blockchain, SHA-246, and Quantum Computing\nalgorithms? Topics focused on these, and other algorithms, received less than 50% support in the\ncommunity survey of Algorithmic Foundations area. Consequently, they were not listed as CS Core\ntopics. However, if computer science graduates are expected to explain these algorithms to non-\ntechnical members of the society, they should be exposed to these topics somewhere in the\ncurriculum.\n● Students are unlikely to implement a lot of historic algorithms in industry such as Bubble sort. A\nquestion that merits case-by-case consideration is whether these algorithms should be covered in\nthe curriculum and, if so, the level of skill at which they should be covered.\nArchitecture and Organization (AR)\n● Software tools for open hardware have lowered the cost and complexity of understanding the\ndesign of new processors. The community-driven RISC-V open instruction set architecture\n“democratizes” the design and evaluation of processors and presents a cutting-edge opportunity in\nthis regard.\n● Quantum Computing does not yet have a fully standardized interface between software and\nhardware. What should be the minimum set of Quantum Computing topics a computer science\ngraduate should be able to explain?\nData Management (DM)\n● For the most part, students write code that either reads/writes to a file or is interactive. Yet, in\nindustry, most data are obtained programmatically from a database. This is a source of mismatch\nbetween academic preparation and industry expectation.\n● Even though most databases are relational, NoSQL databases are enjoying a significant degree of\npopularity. Balancing the coverage of relational vs NoSQL databases is a concern for curricula.\n410\nFoundations of Programming Languages (FPL)\n● Shell scripting is a skill that students should master to automate laborious tasks. It is also a helpful\ntool to coordinate the work of multiple applications. An interesting curricular exercise is determining\nhow and when to teach it as a paradigm.\n● There is an increasing need to develop large, complex software systems that have the potential for\ncatastrophic failure (e.g., software driving medical devices such as robotic surgery). Such software\nneeds to have its behavior validated and potentially formally proved correct. As a result, formal\nmethods may be more important in the future. This would require greater mathematical skills and\nability in graduates.\nMathematical and Statistical Foundations (MSF)\nFaculty and students alike have strong opinions about how much and what mathematics should be\nincluded in the CS curriculum. Generally, faculty, who themselves have strong theoretical training, are\ntypically concerned about poor student preparation and motivation to learn mathematics, while students\ncomplain about not seeing applications and wonder what any of the mathematics has to do with the\nsoftware jobs they seek. Even amongst faculty, there is recurring debate on whether calculus should be\nrequired of computer science students, especially in light of the impact calculus failure rates have on\nbroadening participation. Yet, at the same time, the discipline has itself undergone a significant\nmathematical change – machine learning, robotics, data science, and quantum computing all demand a\ndifferent kind of mathematics than is typically covered in a standard discrete structures course. The\ncombination of changing mathematical demands and inadequate student preparation or motivation, in\nan environment of enrollment-driven strain on resources, has become a key challenge for CS\ndepartments. Some recommendations that have been presented for the treatment of mathematics in\ncomputer science programs follow.\n● Requiring PreCalculus as a prerequisite for discrete mathematics will ensure that students enter\ncomputer science with some degree of comfort with symbolic mathematics and functions.\n● Studies show that students are motivated when they see applications of mathematics. It is\nrecommended that minor programming assignments and demonstrations of applications of\nmathematics be included in computer science courses.\n● Institutions should adopt preparatory options to ensure sufficient background without lowering\nstandards in mathematics. Theory courses can be moved further back in the curriculum to\naccommodate first-year preparation. Where possible, institutions can offer online self-paced tutoring\nsystems alongside regular coursework.\n● What is clear, when looking forward to the next decade, is that exciting high-growth areas of\ncomputer science will require a strong background in linear algebra, probability, and statistics\n(preferably calculus-based). And as much of this material as possible should be included in the\nstandard curriculum.\n● Educators and institutions are often under pressure to help every student succeed, many of whom\nstruggle with mathematics. While pathways, including computer science-adjacent degrees or tracks,\nare sometimes created to steer students around mathematics requirements towards software-\nfocused careers, educators should be equally direct in explaining the importance of sufficient\nmathematical preparation for graduate school and for the very topical areas that excite students.\n411\nThe better approach is to invest in remediation courses to sufficiently prepare as many students as\npossible.\nNetworking and Communication (NC)\n● To what extent should students learn the very low-level details associated with networking or should\nhigher levels of abstraction be the norm in teaching?\n● Cutting-edge technologies promise to significantly affect networking. Generative AI might benefit\nthe generation of networked configurations, security assessments, and capacity planning. Quantum\ncomputing may significantly affect the teaching and practice of networking. And the same goes for\nemerging communication technologies like 5G.\nOperating Systems (OS)\n● How do we teach operating systems as a cohesive set of functions when OS functions are\nincreasingly embedded in architectures or distributed within software development frameworks?\n● Educators should continue to emphasize the importance of operating systems knowledge in\ndistributed, parallel, and secure applications.\n● Is there value in having students recreate operating system functions as a pedagogical approach or\nshould the focus be on a student’s ability to reason about the performance of off-the-shelf library\nmodules that compose applications?\nParallel and Distributed Computing (PDC)\n● Should parallel and distributed programming be infused across a curriculum?\nSoftware Development Fundamentals (SDF)\n● Students will still need to be able to produce code. How they go about doing so may change rapidly\nand dramatically with improvements in the capabilities of generative AI. Students should also be\nable to read, critique, and verify the correctness of code — abilities that students will need if\ngenerative AI is used to write code.\n● Assessment practices in introductory programming courses will need to be adapted to take into\naccount the availability of generative AI. How remains to be seen. It is foreseeable that currently\npopular assessment approaches such as drill-and-practice, many-small-problems, and written\nExplain in Plain English (EiPE) assessments, will need to change or be utilized differently. A focus\non what today would be considered ‘alternative’ means of assessment may rise in prominence—for\ninstance, oral examination, code modification, and other difficult-to-accomplish (with generative AI)\nassessment schemes.\n● High-level approaches to teaching and learning introductory programming may need to be\ndramatically rethought. Approaches similar to studio models of learning from the fine arts where\nstudents design, show, explain, and critique work made in the studio are a way to engage students\nwith topics that let them express their own ideas and vision while learning about fundamental topics.\n412\n● The order in which Software Development Fundamentals (SDF) topics are discussed may need to\nbe reconsidered. For instance, starting with syntax and creating increasingly complex programs\nfrom scratch may be replaced by concepts-first approaches where modularity is considered from\nthe beginning, and syntax and other more basic constructs such as conditionals and repetition are\nlearned during the process.\n● New skills such as prompting (prompt engineering) and the use of other generative AI tool\nrequirements/features may in the near future be considered to be basic programming skills. How\nthe industry adopts generative AI may be a leading driver in such arenas.\nSoftware Engineering (SE)\n● Are undergraduate programs in computing that rely on a single team project beneficial? Teamwork\nis ubiquitous in industry, but no teams are formed entirely out of people with similar backgrounds\nwho have no prior experience working on a team. The heterogeneous background and experience\nlevel of real teams is fundamentally different from the comparative homogeneity of students in a\nclass.\n● Do students have sufficient opportunity to practice with open-ended problems, where the choice of\ntools and approach are critical? In a software engineering context, most work involves evaluating\ntradeoffs – between space and time, between speed-of-implementation and runtime optimization,\nbetween Do-it-Yourself (DIY) and Commercial-off-the-shelf (COTS) or Open-Source Software\n(OSS) approaches. Are students given enough opportunities to practice the critical decision-making\nskills necessary to succeed in a professional environment?\n● Software developed in a team setting (software engineering rather than programming) is more likely\nto have an impact on society for good or ill. At the same time, teamwork means no single person\nmay be responsible for the impact of the software—the larger the project, the greater the potential\nimpact, but the less responsible any team member feels about the impact. How do we instill among\nstudents a proper sense of responsibility for the whole solution regardless of the size of one’s\ncontribution to it?\n● Formal methods for software validation will pay off (substantially) later in students’ careers, but it is\na perfect-but-infrequent solution. The current approach to validation focuses on attempts to get\nhigh-fidelity evidence (unit tests) over proofs and other formal methods, which is more immediately\nuseful but fails to expose students to interesting long-term ideas. Given the finite resources\nprovided for software engineering education, educators must strike the right balance between these\ntwo approaches.\nSecurity (SEC)\n● An ongoing pedagogical consideration is inculcating a security mindset among students, so that\nsecurity is a goal from the start and not an afterthought.\nSociety, Ethics, and the Profession (SEP)\n● Is an introduction to ethical thinking and an awareness of social issues and their emerging\nprofessional responsibilities sufficient for our graduates to act ethically and responsibly? If not, does\nthat put the burden on instructors to not only lead discussion about the pressing questions of the\n413\nday but also weigh in on those matters? How should that be done? Will we just be imparting our\nown biases upon our students? Should this be avoided? If so, how?\n● CS curricula regularly require prerequisite courses in mathematics. Should there be parallel\nprerequisite requirements in moral philosophy to prepare students for future course work in\nperforming ethical analysis?\n● How could we weave SEP throughout the curriculum in practice? Is this realistic? How much\ncoordination would it take? How less optimal is it to have a standalone ethics course only? Is there\nanother model in between these two extremes (neglecting the extreme of not having any\ncoordinated or targeted SEP content in our courses)?\n● Educators naturally possess real or perceived authority when it comes to technical issues. Many\neducators believe they lack this authority when it comes to SEP topics. How can CS instructors be\nempowered to effectively incorporate SEP topics into their courses?\n● How can we effectively impart the core values of diversity, equity, inclusion, and accessibility? How\nis this best done in a computer science context? How can we effectively impart the core values and\nskills of being a computing professional into our students’ education? Are engineered “toy” projects\na suitable context for these? Are study abroad opportunities/work-placements/internships better?\nAre they worth the cost? Should we put more focus on efforts to have more programs/degrees\ncontain study abroad opportunities/placements/internships?\n● Should software developers be licensed like engineers, architects, and medical practitioners? This\nis an older debate but given the impact of software systems (akin to safe bridges, buildings, etc.),\nmaybe it is time to revisit this question.\n● What would a set of current SEP case studies look like and how could they be employed\neffectively?\n● How can collateral learning be leveraged to improve the learning and appreciation of societal,\nethical, and professional topics?\nSpecialized Platform Development (SPD)\n● Computing is no longer limited to traditional desktop applications. Students need to learn how to\ndevelop software solutions for various platforms, including web, mobile, IoT devices, and emerging\nplatforms like virtual reality (VR) and augmented reality (AR). A well-rounded curriculum should\nprovide opportunities for learning on multiple platforms.\n● With the increasing demand for cross-platform apps, educators should teach students how to\ndevelop applications that work seamlessly across different operating systems and devices using\ntechnologies such as React Native, Flutter, or Progressive Web Apps (PWAs).\n● Cloud platforms and services, such as AWS, Azure, and Google Cloud, have become integral to\nmodern platform development. Students need to learn how to deploy, scale, and manage\napplications in the cloud.\nSystems Fundamentals (SF)\n● How deeply should instructors elaborate on the design principles of computer systems in\nundergraduate courses?\n414\n● What role should generative AI play in system-related knowledge areas, not only systems\nfundamentals, but also architecture and organization, network and communication, operating\nsystems, and parallel and distributed computing?\n● Should instructors link knowledge units from systems-related knowledge areas with those from\napplications-related knowledge areas? And if so, how?\n415\n416\nCurricular Practices in Computer Science\nIntroduction\nPrior curricular guidelines enumerated issues in the design and delivery of computer science\ncurriculum. Given the increased importance of these issues, in CS2023, peer-reviewed, well-\nresearched, in-depth articles were solicited from recognized experts on how computer science\neducators could address these issues in their teaching practices. These articles complement the\nCS2023 curricular guidelines. Whereas curricular guidelines list what should be covered in the\ncurriculum, these articles describe how and why they could best be covered, including challenges, state\nof the art practices, etc.\nThe articles may be categorized as covering the following.\n● Social aspects, including teaching about accessibility, computer science for social good,\nresponsible computing, and ethics in the global souths.\n● Pedagogical considerations, including CS + X, the role of formal methods in computer science,\nquantum computing education, and the impact of generative AI on programming instruction.\n● Educational practices, in varied settings such as liberal arts institutions, community colleges, and\npolytechnic institutes.\nThe articles provide a “lay of the land,” a snapshot of the current state of the art of computer science\neducation. They are not meant to advocate specific approaches or viewpoints, but rather help computer\nscience educators weigh their options and make informed decisions about the appropriate option for\ntheir degree program.\nThe computer science education community was invited to provide feedback and suggestions on the\nfirst drafts of most of these articles. Several of the articles have been or are in the process of being\npublished in peer-reviewed conferences and journals. In this section, self-contained summaries of most\nof the articles have been included. The full articles themselves will be accessible at the csed.acm.org\nwebsite.\nIn addition, to globalize computer science education, articles were also invited on educational practices\nin various parts of the world. (See ACM Inroads, Special Issue, 15, 1 (March 2024)). It is hoped that\nthese articles will foster mutual understanding and exchange of ideas, engender transnational\ncollaboration and student exchange, and serve to integrate computer science education at the global\nlevel through shared understanding of its challenges and opportunities.\nSocial Aspects\nAccessibility is about making computing systems accessible to people with disabilities and designing\ntechnical solutions for accessibility problems faced by people with disabilities. The article “Teaching\n417\nabout Accessibility in Computer Science Education” explains the practical, intellectual, and social\nreasons for integrating accessibility into the computer science curriculum.\nThe article “Computing for Social Good in Education” highlights how computing education can be\nused to improve society and address societal needs while also providing authentic computing\nenvironments in education. The authors discuss approaches, challenges, and benefits of incorporating\ncomputing for social good into computer science curriculum.\nGiven the pervasive use of computing in society, educators would be remiss not to teach their students\nabout the principles of responsible computing. How they should go about doing so is explored in the\narticle “Multiple Approaches for Teaching Responsible Computing.” It uses research in the social\nsciences and humanities to transform responsible computing into an integrated consideration of values\nthroughout the lifecycle of computing products.\nIn a globalized world, applications of computing transcend national borders. In this context, making\nethics at home in global computer science education is about helping students relate to values within\nand beyond their own contexts. The article “Making Ethics at Home in Global CS Education:\nProvoking Stories from the Souths” presents storytelling as a mechanism that educators can use to\nengage students with “ethos building.”\nPedagogical Considerations\n“CS + X: Approaches, Challenges, and Opportunities in Developing Interdisciplinary Computing\nCurricula” states how interdisciplinary majors that apply computational methods in natural sciences,\nsocial sciences, humanities, and the arts can broaden participation in computing and reach a larger\ngroup of students.\n“The Role of Formal Methods in Computer Science Education” makes the case for incorporating\nformal methods in computer science education. It lists the multiple ways in which formal methods can\nbe incorporated into the undergraduate computer science curriculum and buttresses its advocacy of\nformal methods with testimonials from the industry.\n“Quantum Computing Education: A Curricular Perspective” presents the current state of art in\nquantum computing and uses the results of a pedagogic experiment to illustrate that quantum\ncomputing education is within reach of even school children. It presents three curricular approaches for\nincorporating quantum computing in undergraduate computer science curriculum.\n“Generative AI in Introductory Programming” explores how generative AI tools based on Large\nLanguage Models (LLMs) such as ChatGPT might affect programming education including how these\ntools can be used to assess student work, provide feedback, and to act as always-available virtual\nteaching assistants in introductory programming courses.\nOne issue with the study of databases/data management is that the number of possible topics far\nexceeds the bandwidth of a single undergraduate computer science course. “The 2022 Undergraduate\n418\nDatabase Course in Computer Science: What to Teach?” presents multiple viewpoints on what a\nsingle undergraduate course in Databases/Data Management should cover.\nEducational Practices\nNo curricular guidelines are complete by themselves. They must be adapted to local strengths,\nconstraints, and needs. In this regard, “Computer science Curriculum Guidelines: A New Liberal\nArts Perspective” provides a process to adapt CS2023 to the needs of liberal arts colleges that\nconstrain the size of the computer science coursework in order to expose students to a broad range of\nliberal arts subjects.\nCommunity and polytechnic colleges across the world offer specialized programs that help students\nfocus on specific educational pathways. They award academic degrees that enable students to transfer\nto four-year colleges and are attuned to the needs of the local workforce. “Computer Science\nEducation in Community Colleges” presents the context and perspective of community college\ncomputer science education.\n419\nTeaching about Accessibility in Computer Science Education\nRichard E. Ladner, University of Washington, Seattle, WA, USA\nStephanie Ludi, University of North Texas, Denton, TX, USA\nRobert J. Domanski, Hunter College (CUNY), New York, NY, USA\nAccessibility, in the context of computer science, is about making computing products accessible to\npeople with disabilities. This means designing hardware and software products that can be used\neffectively by people who have difficulty reading a computer screen, hearing computer prompts, or\ncontrolling the keyboard, mouse, or touchscreen. Thus, accessibility topics should be woven into any\ncourse about human-facing applications or websites, such as app and web design/development,\nsoftware engineering, and human-computer interaction. In addition, accessibility is about creating\ntechnical solutions to accessibility problems that people with disabilities encounter in everyday living.\nThese technical solutions may include the use of artificial intelligence, computer vision, natural\nlanguage processing, or other CS topics. Thus, accessibility topics can be included in technical\ncourses, particularly those that incorporate projects where students attempt to solve accessibility\nproblems using techniques taught in the course. There are practical, intellectual, and social reasons to\nintegrate accessibility into computer science curriculum. From a practical standpoint, employers\nincreasingly include accessibility knowledge in job descriptions because they want their products and\nservices to be accessible to more customers and for legal compliance. From an intellectual standpoint,\ntechnical solutions to many accessibility problems often require creativity and a multi-disciplinary\napproach that includes understanding user needs integrated with technical knowledge. From a social\nstandpoint, accessibility is an important topic in addressing inclusivity and an attractive topic for those\nstudents who enter the field to do social good, leading to a broader mix of students in terms of gender,\nrace, ethnicity, and ability.\nHelpful Resources:\n[1] Catherine Caldwell-Harris, & Chloe Jordan. 2014. Systemizing and special interests: Characterizing\nthe continuum from neurotypical to autism spectrum disorder. Learning and Individual Differences.\nVolume 29, Issue 2014, 98-105. https://doi.org/10.1016/j.lindif.2013.10.005.\n[2] CAIR: RIT Center for Accessibility and Inclusion Research; http://cair.rit.edu/projects.html.\naccessed September 7, 2022.\n[3] Robert F. Cohen, Alexander V. Fairley, David Gerry, and Gustavo R. Lima. 2005. Accessibility in\nintroductory computer science. In Proceedings of the 36th SIGCSE technical symposium on Computer\nscience education (SIGCSE '05). Association for Computing Machinery, New York, NY, USA, 17–21.\nhttps://doi.org/10.1145/1047344.1047367.\n[4] Robert F. Dugan Jr (2011) A survey of computer science capstone course literature, Computer\nScience Education, 21:3, 201-267,\nhttps://www.tandfonline.com/doi/abs/10.1080/08993408.2011.606118. Accessed March 2024.\n420\n[5] Kristen Shinohara, Saba Kawas, Amy J. Ko, and Richard E. Ladner. 2018. Who Teaches\nAccessibility? A Survey of U.S. Computing Faculty. In Proceedings of the 49th ACM Technical\nSymposium on Computer Science Education (SIGCSE '18). Association for Computing Machinery,\nNew York, NY, USA, 197–202. https://doi.org/10.1145/3159450.3159484.\n[6] Stephanie Ludi, Matt Huenerfauth, Vicki Hanson, Nidhi Rajendra Palan, and Paula Conn. 2018.\nTeaching Inclusive Thinking to Undergraduate Students in Computing Programs. In Proceedings of the\n49th ACM Technical Symposium on Computer Science Education (SIGCSE '18). Association for\nComputing Machinery, New York, NY, USA, 717–722. DOI: https://doi.org/10.1145/3159450.3159512.\n[7] Alannah Oleson, Amy J. Ko, Richard Ladner (Eds.) (2023). Teaching Accessible Computing. Self-\nPublished. https://bookish.press/tac. Accessed November 28, 2023.\n[8] PEAT; https://www.peatworks.org/. Accessed January 5, 2023.\n[9] Teach Access website, http://www.teachaccess.org. Accessed September 10, 2022.\n[10] Kendra Walther and Richard E. Ladner. 2021. Broadening participation by teaching accessibility.\nCommunications of the ACM 64, 10 (October 2021), 19–21. https://doi.org/10.1145/3481356.\n[11] WCAG https://www.w3.org/WAI/standards-guidelines/wcag/ Accessed November 6, 2022.\n[12] Jacob O. Wobbrock, Shaun K. Kane, Krzysztof Z. Gajos, Susumu Harada, and Jon Froehlich.\n2011. Ability-Based Design: Concept, Principles and Examples. ACM Transactions on Accessible\nComputing 3, 3, Article 9 (April 2011), 27 pages. https://dl.acm.org/doi/10.1145/1952383.1952384.\n421\nComputing for Social Good in Education\nHeidi J. C. Ellis, Western New England University, Springfield, MA, USA\nGregory W. Hislop, Drexel University, Philadelphia, PA, USA\nMikey Goldweber, Denison University, Granville, OH, USA\nSam Rebelsky, Grinnell College, Grinnell, IA, USA\nJanice L Pearce, Berea College, Berea, KY, USA\nPatti Ordonez, University of Maryland Baltimore County, Baltimore, MD, USA\nMarcelo Pias, Universidade Federal do Rio Grande, Rio Grande, Brazil\nNeil Gordon, University of Hull, Hull, UK\nComputing for Social Good (CSG) encompasses the potential of computing to have a positive impact\non individuals, communities, and society, both locally and globally. Incorporating CSG into education\n(CSG-Ed) is especially relevant as computing has more and more impact across all areas of society\nand daily life. Educators can address CSG-Ed through a variety of means [2]. A simple way to start is\nby modifying a single assignment within a single course by updating the domain of the assignment to\nbe one with social impact. The use of this domain can then be expanded across several assignments\nwithin the same course or across several courses. The domain could also provide the opportunity for\ncollaborations across related departments. Indeed, some countries, such as England, integrate CSG\nthroughout the curriculum starting before higher education studies [6].\nAnother way that educators may support CSG-Ed is the adoption or creation of a classroom project that\nsolves a social problem either for a campus organization or from the larger community [1]. This\napproach allows students to see the impact of their work within their own community. On a larger scale,\nparticipation in established projects with national or global scope allows students to understand the\nbreadth of influence that computing can have. Such efforts align well with institutions that have a\nservice-learning requirement [4]. In addition, hackathons, code-days, clubs, and other extracurricular\nactivities allow students to understand the social impact of computing outside of the classroom.\nThere are several challenges to integrating computing for social good into higher education [3]. One\nchallenge is that instructors may not be inclined to incorporate new topics fearing that it could disrupt\nthe curriculum or require course rework. Instructor time is a second barrier where it may take time to\nunderstand CSG domains and create new assignments. The interdisciplinary nature of many CSG\ntopics may also require collaborating with other departments, disciplines, or community partners\nresulting in additional course preparation time. CSG-Ed assignments may result in the discussion of\nsocial issues within the classroom that could require instructors to prepare to discuss these issues with\nstudents. In addition, there appears to be a shortage of coverage of CSG in textbooks.\nWhile barriers to CSG-Ed adoption exist, this focus of computing education provides multiple\nopportunities. CSG-Ed provides the possibility for students to connect with real-world problems to\nunderstand the complexity of computing while also apprehending the social impact of computing [5].\nStudents can be motivated by engaging in solving local problems that directly impact themselves or\ntheir community. They can also gain a better understanding of global citizenship and responsibility by\nparticipating in social projects that have a global scale.\n422\nThere are several areas of future investigation including creation of a repository of CSG-Ed materials,\naddressing project-related challenges, exploring open source in CSG-Ed, and approaches for creating\nand growing an inclusive community to support CSG-Ed.\nReferences\n[1] Grant Braught, Steven Huss-Lederman, Stoney Jackson, Wes Turner, and Karl R. Wurst. 2023.\nEngagement Models in Education-Oriented H/FOSS Projects. In Proceedings of the 54th ACM\nTechnical Symposium on Computer Science Education V. (SIGCSE 2023). Association for Computing\nMachinery, New York, NY, USA, 409–415. https://doi.org/10.1145/3545945.3569835\n[2] Michael Goldweber, John Barr, Tony Clear, Renzo Davoli, Samuel Mann, Elizabeth Patitsas, and\nScott Portnoff. 2012. A framework for enhancing the social good in computing education: a values\napproach. In Proceedings of the final reports on Innovation and technology in computer science\neducation 2012 working groups (ITiCSE-WGR '12). Association for Computing Machinery, New York,\nNY, USA, 16–38. https://doi.org/10.1145/2426636.2426639.\n[3] Mikey Goldweber, Lisa Kaczmarczyk, and Richard Blumenthal. Computing for the social good in\neducation. ACM Inroads, 10, 4 (Dec 2019): 24–29.\n[4] Janice L. Pearce. Requiring outreach from a CS0-level robotics course. J. Comput. Sci. Coll. 26, 5\n(May 2011), 205–212.\n[5] Lori Postner, Darci Burdge, Stoney Jackson, Heidi Ellis, George W. Hislop, and Sean Goggins.\nUsing humanitarian free and open source software (HFOSS) to introduce computing for the social\ngood. SIGCAS Comput. Soc. 45, 2 (June 2015), 35. https://doi.org/10.1145/2809957.2809967.\n[6] Computer Science GCSE Subject Content.\nhttps://assets.publishing.service.gov.uk/media/5a7e3cb440f0b62305b81b02/Computer_Science_GCSE\n_-_subject_content_-_final.pdf. Accessed 26 Nov. 2023.\n423\nMultiple Approaches for Teaching Responsible Computing\nStacy A. Doore, Colby College, Waterville, ME, USA\nAtri Rudra, University at Buffalo, Buffalo, NY, USA\nMichelle Trim, University of Massachusetts, Amherst, MA, USA\nJoycelyn Streator, Prairie View A&M University, Prairie View, TX, USA & the Mozilla Foundation\nRichard Blumenthal, Regis University, Colorado, CO, USA\nBobby Schnabel, University of Colorado, Boulder, CO, USA\nTeaching applied ethics in computer science (and computing in general) has shifted from a perspective\nof teaching about professional codes of conduct and an emphasis on risk management towards a\nbroader understanding of the impacts of computing on humanity and the environment. This shift has\nproduced a diversity of approaches for integrating responsible computing instruction into core computer\nscience knowledge areas and for an expansion of dedicated courses focused on computing ethics.\nThere is an increased recognition that students need intentional and consistent opportunities\nthroughout their computer science education to develop the critical thinking, analytical reasoning, and\ncultural competency skills to understand their roles and professional duties in the responsible design,\nimplementation, and management of complex computing systems. Therefore, computing education\nprograms are re-evaluating the ways in which students learn to identify and assess the impact of\ncomputing on individuals, communities, and societies along with other critical professional skills such as\neffective communication, workplace conduct, and regulatory responsibilities. One of the primary shifts\nin the new approach comes from interdisciplinary collaborations, combining computing, social sciences\nand humanities researchers who work together to help students identify potential biases, blind spots,\nimpacts, and harms in applications or systems and examine underlying assumptions and competing\nvalues driving design decisions.\nThere are examples of how topics within the CS2023 Society, Ethics, and the Profession (SEP)\nknowledge area can be implemented and assessed with numerous links to current module repositories\n[1-6], lessons [7-11], and resources [12-21] to embed responsible computing teaching across the CS\ncurriculum. There are specific recommendations and resources that will help address current barriers\nfor moving forward with the integration of responsible computing practices in the classroom [22]. These\ninclude ways of being open and confident in honoring all students’ prior knowledge and lived\nexperiences in sometimes difficult conversations [23-24] and overcoming student apathy or resistance\nto embedding responsible computing content [25-26]. These strategies require a willingness to work\nwithin an interdisciplinary community to incorporate social science and humanities domain expertise\nwithin these classroom interactions [27-29]. There are also recommendations on how to bring\nundergraduate students into curriculum planning as many of the earliest responsible computing\nteaching models were co-developed with undergraduate CS students [30-32]. Finally, there are\nrecommendations about distinguishing between often conflated concepts, associated with responsible\ncomputing such as social justice [33-35], trust and safety [36-38], and value-sensitive design and co-\ndesign [39-40]. The understanding and use of these principles and practices in the classroom\ncommunicate the importance of stakeholder groups and impacted community inclusion from the\nbeginning of the technology development lifecycle and affirms the agentive role of that community in\ndevelopment decisions. We hope this contribution will assist instructors as they develop their learning\n424\nobjectives, activities, and assessments while adding to the growing body of knowledge on the best\npractices for weaving responsible computing principles and content throughout the evolving\nACM/IEEE/AAAI computing curricula.\nReferences\n[1] ACM Engage CSEdu Ethics Repository. https://www.engage-csedu.org/ethics-and-\ncomputing/repository. Accessed Feb 28, 2024.\n[2] Embedded EthiCS @ Harvard University - Modules Repository.\nhttps://embeddedethics.seas.harvard.edu/. Accessed Feb 28, 2024.\n[3] Computing Ethics Narratives and Modules Repository at Bowdoin College and Colby College.\nhttps://computingnarratives.com. Accessed Feb 28, 2024.\n[4] Embedded Ethics in Computer Science at Stanford University - Modules Repository.\nhttps://embeddedethics.stanford.edu/. Accessed Feb 28, 2024.\n[5] Embedded EthiCS Modules Repository at University of Toronto.\nhttps://www.cs.toronto.edu/embedded-ethics/modules/index.html. Accessed Feb 28, 2024.\n[6] Responsible Computer Science Repository at Bemidji State University.\nhttps://www.bemidjistate.edu/academics/departments/mathematics-computer-science/rcs/. Accessed\nFeb 28, 2024.\n[7] Integrating Social Responsibility into Core CS. https://evanpeck.github.io/projects/responsibleCS.\nAccessed Feb 28, 2024.\n[8] Internet Rules Lab University of Colorado Boulder. https://www.internetruleslab.com/responsible-\ncomputing. Accessed Feb 28, 2024.\n[9] Responsible Computer Science at Washington University at St. Louis.\nhttps://www.cse.wustl.edu/~cytron/RCS/. Accessed Feb 28, 2024.\n[10] University of Miami Dade Responsible Computing Role Playing Lesson. https://news.mdc.edu/role-\nplaying-scenario-developed-at-entec/. Accessed Feb 28, 2024.\n[11] Georgia Tech Responsible Computing Science.\nhttps://sites.gatech.edu/responsiblecomputerscience/. Accessed Feb 28, 2024.\n[12] Mozilla Responsible Computing Playbook. https://foundation.mozilla.org/en/responsible-computing-\nchallenge-playbook/. Accessed Feb 28, 2024.\n[13] Teaching Responsible Computing at University of Buffalo.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-\n425\nplaybook/https://c4sg.cse.buffalo.edu/projects/Teaching%20Responsible%20Computing.html.\nAccessed Feb 28, 2024.\n[14] Human Context and Ethics at UC Berkeley. https://foundation.mozilla.org/en/responsible-\ncomputing-challenge-playbook/ https://data.berkeley.edu/academics/human-contexts-and-ethics.\nAccessed Feb 28, 2024.\n[15] Social & Ethical Responsibilities of Computing at MIT.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-playbook/\nhttps://computing.mit.edu/cross-cutting/social-and-ethical-responsibilities-of-computing. Accessed Feb\n28, 2024.\n[16] Socially Responsible Computing @ Brown University. https://foundation.mozilla.org/en/responsible-\ncomputing-challenge-playbook/ http://ethics.cs.brown.edu/. Accessed Feb 28, 2024.\n[17] Embedded Ethics Program at Georgetown University.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-playbook/\nhttps://ethicslab.georgetown.edu/embedded-ethics. Accessed Feb 28, 2024.\n[18] Ethical Computer Science at Allegheny College. Accessed Feb 28, 2024.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-playbook/\nhttps://csethics.allegheny.edu/.\n[19] Ethics 4 EU - Educational Resources. https://foundation.mozilla.org/en/responsible-computing-\nchallenge-playbook/ https://ascnet.ie/ethics4eu-website/welcome-to-the-bricks/. Accessed Feb 28,\n2024.\n[20] Human Context and Ethics at UC Berkeley. https://foundation.mozilla.org/en/responsible-\ncomputing-challenge-playbook/ https://data.berkeley.edu/academics/human-contexts-and-ethics.\nAccessed Feb 28, 2024.\n[21] Markkula Center for Applied Ethics at Santa Clara University- Technology Ethics.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-\nplaybook/ https://www.scu.edu/ethics/focus-areas/technology-ethics/. Accessed Feb 28, 2024.\n[22] Colleen Greer & Marty J. Wolf. 2020. Overcoming barriers to including ethics and social\nresponsibility in computing courses. In Societal Challenges in the Smart Society, 131-144. Universidad\nde La Rioja.\n[23] Rodrigo Ferreira & Moshe Y. Vardi. 2021. Deep tech ethics: An approach to teaching social justice\nin computer science. In Proceedings of the 52nd ACM Technical Symposium on Computer Science\nEducation, 1041-1047.\n426\n[24] Michelle Trim & Paige Gulley. 2023. Imagining, generating, and creating: Communication as\nfeminist pedagogical method for teaching computing ethics. In Proceedings of the 41st ACM\nInternational Conference on Design of Communication, 206-209.\n[25] Nina Zuber, Jan Gogoll, Severin Kacianka, Alexander Pretschner, & Julian Nida-Rümelin.\nEmpowered and embedded: ethics and agile processes. Humanities and Social Sciences\nCommunications. 9, 1 (2022): 1-13.\n[26] Shamika Klassen & Casey Fiesler. Run Wild a Little with Your Imagination: Ethical Speculation in\nComputing Education with Black Mirror.\" In Proceedings of the 53rd ACM Technical Symposium on\nComputer Science Education. 1, (2022): 836-842.\n[27] Barbara J. Grosz, David Gray Grant, Kate Vredenburgh, Jeff Behrends, Lily Hu, Alison Simmons, &\nJim Waldo. 2019. Embedded EthiCS: Integrating ethics across CS education. Communications of the\nACM, 62, 8 (2019): 54–61.\n[28] National Academies of Sciences, Engineering, and Medicine. 2022. Fostering Responsible\nComputing Research: Foundations and Practices.\n[29] Trystan S. Goetze. 2023. Integrating ethics into computer science education: Multi-, inter-, and\ntransdisciplinary approaches. In Proceedings of the 54th ACM Technical Symposium on Computer\nScience Education, 1, (2023): 645-651.\n[30] Beleicia B. Bullock, Fernando L. Nascimento, & Stacy A. Doore. Computing ethics narratives:\nTeaching computing ethics and the impact of predictive algorithms. In Proceedings of the 52nd ACM\nTechnical Symposium on Computer Science Education, 2021: 1020-1026.\n[31] Nora McDonald, Adegboyega Akinsiku, Jonathan Hunter-Cevera, Maria Sanchez, Kerrie Kephart,\nMark Berczynski, and Helena M. Mentis. Responsible computing: A longitudinal study of a peer-led\nethics learning framework. ACM Transactions on Computing Education (TOCE) 22,4 (2022): 1-21.\n[32] Alexandra Gillespie. 2023. Designing an ethical tech developer. Communications of the ACM, 66, 3\n(2023): 38-40.\n[33] Ruha Benjamin. Race after technology, Social Theory Re-Wired, 405-415. Routledge (2023).\n[34] Rachel Charlotte Smith, Heike Winschiers-Theophilus, Daria Loi, Rogério Abreu de Paula, Asnath\nPaula Kambunga, Marly Muudeni Samuel, & Tariq Zaman. Decolonizing design practices: towards\npluriversality. In Extended abstracts of the 2021 CHI conference on human factors in computing\nsystems. 1-5.\n[35] Sasha Costanza-Chock. Design Justice: Community-led Practices to Build the Worlds We Need.\nThe MIT Press, 2020.\n427\n[36] Ben Shneiderman. Bridging the gap between ethics and practice: guidelines for reliable, safe, and\ntrustworthy human-centered AI systems. ACM Transactions on Interactive Intelligent Systems (TiiS)\n10,4 (2020): 1-31.\n[37] Cansu Canca. 2020. Operationalizing AI ethics principles. Communications of the ACM, 63, 12\n(2020): 18-21.\n[38] International Organization for Standardization. Information Technology–Artificial Intelligence –\nManagement Systems (ISO/IEC Standard 42001-2023). https://www.iso.org/standard/81230.html\nAccessed Feb 28, 2024.\n[39] John M. Carroll. Encountering others: Reciprocal openings in participatory design and user-\ncentered design. Human-computer Interaction 11,3 (1996), 285-290.\nhttps://foundation.mozilla.org/en/responsible-computing-challenge-playbook/. Accessed Feb 28, 2024.\n[40] David G. Hendry, Batya Friedman, & Stephanie Ballard. Value sensitive design as a formative\nframework. Ethics and Information Technology 23, 23 (2021): 1-6.\n428\nMaking ethics at home in Global CS Education: Provoking stories from the\nSouths\nMarisol Wong-Villacres, Escuela Superior Politecnica del Litoral, Guayaquil, Ecuador\nCat Kutay, Charles Darwin University, Northern Territory, Australia\nShaimaa Lazem, City of Scientific Research and Technological applications, Alexandria, Egypt\nNova Ahmed, North South University, Dhaka, Bangladesh\nCristina Abad, Escuela Superior Politecnica del Litoral, Guayaquil, Ecuador\nCesar Collazos, Universidad del Cauca, Popayan, Colombia\nShady Elbassuoni, American University of Beirut, Beirut, Lebanon\nFarzana Islam, North South University, Dhaka, Bangladesh\nDeepa Singh, University of Delhi, New Delhi, India,\nTasmiah Tahsin Mayeesha, North South University, Dhaka, Bangladesh\nMartin Mabeifam Ujakpa, Ghana Communication Technology University, Accra, Ghana\nTariq Zaman, University of Technology, Sibu, Malaysia\nNicola J. Bidwell, Charles Darwin University and University of Melbourne, Australia, International\nUniversity of Management, Namibia\nWe, a group of thirteen educators in computing programs and researchers in universities, retell the\nstories of 46 university educators and practitioners in Latin America, South-Asia, Africa, the Middle\nEast, and Australian First Nations who participated in surveys and interviews with us [1]. We use the\nplural of Global Souths to indicate the multiple and overlapping geographic and conceptual spaces that\nare negatively impacted by contemporary capitalist globalization and the US–European norms and\nvalues exported in computing products, processes, and education. The stories illustrate frictions\nbetween local practices, values, and impacts of technologies and the static, anticipatory approaches to\nethics that computer science (CS) curricula often promote through codes of ethics. The stories show\ndiverse perspectives on privacy and institutional approaches to confidentiality; compliance with\nregulations to attain various goals and difficulties when regulations are absent or ambiguously relate to\npractices; discrimination based on their gender or technical ability and minoritized positions; and, finally,\nthat relational, rather than transactional, approaches to ethics may better suit local ethical challenges.\nCS codes of ethics can assist educators by listing factors for consideration and mitigating situations\nwhen regulations, laws or policies are not fully developed. Yet the gap between codes of ethics and\nlocal realities can also cause harm. Further prevalent codes of ethics are instruments of power that\nenable actors in the Global North to determine what legitimate CS practice comprises and the position\nof the Global Souths relative to this. Thus, we advocate for ethical guidance that speaks to and comes\n“from within” people’s messy realities in the Global Souths not only because connecting ethics to\nstudents’ and educators’ values, knowledge, and experiences is vital for learning but also to assert\ngreater recognition and respect for localized ethical judgements.\nMaking ethics at home in global CS education is about fostering students’ ethical sensibilities and\norienting them to engage reflexively with different values and positionalities within and beyond their own\ncontexts. Ethical considerations are always updating as new technologies, new socio-technical\nsituations and new sensitivities emerge and, thus, we suggest that educators use storytelling about\n429\nongoing, real-world events to engage students with “ethos building.” [2] In the epilogue that extends this\npiece [3], we share two stories that arose when researching and presenting this article to show how\nethics is embedded in every action and how as educators we must continuously refine our sensitivity to\nthe varied ways our lives are implicated in technical and socio-technical systems, from local to global\nscales, and develop confidence to discuss their implications with our students.\nOur modest study significantly extends existing research [1] on how CS educators account for the\ndiverse ways ethical dilemmas and approaches to ethics are situated in cultural, philosophical, and\ngovernance systems, religions, and languages [1].\nReferences\n[1] Janet Hughes, Ethan Plaut, Feng Wang, Elizabeth von Briesen, Cheryl Brown, Gerry Cross, Viraj\nKumar, and Paul Myers. Global and local agendas of computing ethics education. In Proceedings of the\nConference on Innovation and Technology in Computer Science Education, 2020; (ACM, New York,\nNY, 2020) 239-245.\n[2] Christopher Frauenberger and Peter Purgathofer. 2019. Responsible thinking educating future\ntechnologists. In Proceedings of CHI Conference on Human Factors in Computing Systems (CHI’19).\n[3] Wong-Villacres, M., Kutay, C., Lazem, S., Ahmed, N., Abad, C., Collazos, C., ... & Bidwell, N. J.\nMaking ethics at home in Global CS Education: Provoking stories from the Souths. ACM Journal on\nComputing and Sustainable Societies. (2023).\n430\nCS + X: Approaches, Challenges, and Opportunities in Developing\nInterdisciplinary Computing Curricula\nValerie Barr, Bard College, Annandale-on-Hudson, NY, USA\nCarla E. Brodley, Northeastern University, Boston, MA, USA\nElsa L. Gunter, UIUC, Urbana-Champaign, IL, USA\nMark Guzdial, University of Michigan, Ann Arbor, MI, USA\nRan Libeskind-Hadas, Claremont McKenna College, Claremont, CA, USA\nBill Manaris, College of Charleston, Charleston, SC, USA\nInterdisciplinary computing curricula and majors (often called CS+X) interweave foundational\ncomputing concepts with those of specific disciplines in the natural sciences, social sciences,\nhumanities, and the arts. Well-designed CS+X programs have substantially increased diversity and\ninclusion in computing. They address a rapidly growing need for a computationally sophisticated\nworkforce across many domains that are critical to society. Virtually every discipline has significant\nchallenges and opportunities that require computational methods. Increasingly, many researchers and\npractitioners in those fields are using computational methods, yet undergraduates in those fields often\nget little or no computational training deeper than using existing software tools.\nInterdisciplinary computing can be implemented in individual courses (e.g., a course that combines both\nthe art and computing concepts for visualization); as a major+minor; or as its own major, where\nstudents take some courses from computing, a similar number from another discipline, and one or more\nintegrative courses.\nInterdisciplinary courses and majors have several additional benefits. There is ample evidence that\nsuch innovative programs significantly broaden participation in computing. For example,\ninterdisciplinary programs can substantially improve gender diversity and, generally, engage diverse\npopulations of students who are unlikely to pursue a within-discipline computing degree [1,2,3,4]. The\ngender diversity likely depends in part on the X in CS+X. For example, at some institutions with CS+X\nprograms where X is related to the arts, the CS+X major has approximately equal numbers of women\nand men, which is more than twice the national statistic for CS programs (22% women).\nA second benefit of interdisciplinary computing majors is the ability to reach a larger set of students –\nbecause of enrollment pressures and course caps in computer science departments, non-majors are\noften unable to access the computing courses that they seek. CS+X majors can help computing\ndepartments (and universities) better manage enrollments. A CS+X major typically will require fewer\ncomputing classes than a within-discipline CS major, reducing enrollment pressure on higher-level\nelectives that are often harder to staff.\nReferences\n[1] William Bares, Bill Manaris, and Renée McCauley. Gender equity in computer science through\nComputing in the Arts – A six-year longitudinal study. Computer Science Education Journal 28, 3\n(September 2018), 191–210. https://doi.org/10.1080/08993408.2018.1519322.\n431\n[2] William H. Bares, Bill Manaris, Renée McCauley, and Christine Moore. Achieving gender balance\nthrough creative expression. In Proceedings of the 50th ACM Technical Symposium on Computer\nScience Education (Minneapolis, MN, USA) (SIGCSE 2019). Association for Computing Machinery,\nNew York, NY, USA, 293-299. https://doi.org/10.1145/3287324.3287435\n[3] Carla E. Brodley, Benjamin J. Hescott, Jessica Biron, Ali Ressing, Melissa Peiken, Sarah Maravetz,\nand Alan Mislove. Broadening participation in computing via ubiquitous combined majors (CS+X). In\nProceedings of the 53rd ACM Technical Symposium on Computer Science Education V. 1 (Providence,\nRI, USA) (SIGCSE 2022). Association for Computing Machinery, New York, NY, USA, 544–550.\nhttps://doi.org/10.1145/3478431.3499352\n[4] Zachary Dodds, Malia Morgan, Lindsay Popowski, Henry Coxe, Caroline Coxe, Kewei Zhou, Eliot\nBush, and Ran Libeskind-Hadas. A Biology-based CS1: Results and reflections, ten years in. In\nProceedings of the 52nd ACM Technical Symposium on Computer Science Education (SIGCSE 2021).\nAssociation for Computing Machinery, New York, NY, USA, 796-801.\n432\nThe Role of Formal Methods in Computer Science Education\nMaurice H. ter Beek, CNR–ISTI, Pisa, Italy\nManfred Broy, Technische Universität München, München, Germany\nBrijesh Dongol, University of Surrey, Guilford, UK\nEmil Sekerinski, McMaster University, Hamilton, Canada\nFormal Methods (FM) are available in various forms, spanning from lightweight static analysis to\ninteractive theorem proving. These methods provide a systematic demonstration to students of the\napplication of formal foundations in Computer Science within engineering tasks. The core skill of\nabstraction, fundamental to computer science, is effectively addressed through FM [1]. Even students\nspecializing in 'Formal Methods Thinking'—the application of ideas from FM in informal, lightweight,\npractical, and accessible ways—experience notable improvement in their programming skills [2].\nExposure to these ideas also positions students well for further study on why techniques work, how\nthey can be automated, and the development of new approaches.\nFM can contribute significantly to teaching programming to novices, complementing informal reasoning\nand testing methods. They elucidate algorithmic problem-solving, design patterns, model-driven\nengineering, software architecture, software product lines, requirements engineering, and security,\nthereby supporting various fields within computer science [3]. Formalisms provide a concise and\nprecise means of expressing underlying design principles, equipping programmers with tools to\naddress related problems.\nIn industry, FM find widespread application, from eliciting requirements and early design to deployment,\nconfiguration, and runtime monitoring [4]. A recent survey [5] involving 130 FM experts, including three\nTuring Award winners, all four FME Fellowship Award winners, and 16 CAV Award winners, indicates\nthat the most suitable place for FM in a teaching curriculum is in bachelor courses at the university\nlevel, as reported by 79.2% of respondents. Furthermore, 71.5% of respondents identify the lack of\nproper training in FM among engineers as the key limiting factor for a broader adoption of FM by the\nindustry.\nThe survey highlights the uneven nature of FM education across universities, with many experts\nadvocating for the standardization of university curricula. A recent white paper [6] supports this view,\nproposing the inclusion of a compulsory FM course in Computer Science and Software Engineering\ncurricula. This recommendation is based on the observation that there is a shortage of Computer\nScience graduates qualified to apply Formal Methods in industry.\nThe challenge is twofold: (1) the lack of definitive educational sources that support FM-based courses\nin Computer Science; and (2) the training of academic staff to teach FM. Help is, however, becoming\navailable (https://fmeurope.org/teaching/), and the future is bright, as more and more educators\ncontribute to the effort of creating and sharing teaching resources.\n433\nReferences\n[1] Manfred Broy, Achim D. Brucker, Alessandro Fantechi, Mario Gleirscher, Klaus Havelund, Cliff\nJones, Markus Kuppe, Alexandra Mendes, André Platzer, Jan Oliver Ringert, and Allison Sullivan.\nDoes Every Computer Scientist Need to Know Formal Methods? Submitted to Form. Asp. Comput.\n(2023).\n[2] Brijesh Dongol, Catherine Dubois, Stefan Hallerstede, Eric Hehner, Daniel Jackson, Carroll Morgan,\nPeter Müller, Leila Ribeiro, Alexandra Silva, Graeme Smith, and Erik de Vink. On Formal Methods\nThinking in Computer Science Education. Submitted to Form. Asp. Comput. (2023).\n[3] Emil Sekerinski, Marsha Chechik, João F. Ferreira, John Hatcliff, Michael Hicks, and Kevin Lano..\nShould We Teach Formal Methods or Algorithmic Problem Solving, Design Patterns, Model-Driven\nEngineering, Software Architecture, Software Product Lines, Requirements Engineering, and Security?\nIn preparation 2023.\n[4] Maurice H. ter Beek, Rod Chapman, Rance Cleaveland, Hubert Garavel, Rong Gu, Ivo ter Horst,\nJeroen J. A. Keiren, Thierry Lecomte, Michael Leuschel, Kristin Y. Rozier, Augusto Sampaio, Cristina\nSeceleanu, Martyn Thomas, Tim A. C. Willemse, and Lijun Zhang. 2023. Formal Methods in Industry.\nSubmitted to Form. Asp. Comput. (2023).\n[5] Hubert Garavel, Maurice H. ter Beek, and Jaco van de Pol. 2020. The 2020 Expert Survey on\nFormal Methods. In Proceedings of the 25th International Conference on Formal Methods for Industrial\nCritical Systems (FMICS’20) (LNCS, Vol. 12327), Maurice H. ter Beek and Dejan Ničković (Eds.).\nSpringer, Germany, 3–69. https://doi.org/10.1007/978-3-030-58298-2_1\n[6] Antonio Cerone, Markus Roggenbach, James Davenport, Casey Denner, Marie Farrell, Magne\nHaveraaen, Faron Moller, Philipp Körner, Sebastian Krings, Peter Csaba Ölveczky, Bernd-Holger\nSchlingloff, Nikolay Shilov, and Rustam Zhumagambetov. 2021. Rooting Formal Methods Within Higher\nEducation Curricula for Computer Science and Software Engineering – A White Paper. In Revised\nSelected Papers of the 1st International Workshop on Formal Methods – Fun for Everybody\n(FMFun’19) (CCIS, Vol. 1301), Antonio Cerone and Markus Roggenbach (Eds.). Springer, Germany,\n1–26. https://doi.org/10.1007/978-3-030-71374-4_1\n434\nQuantum Computing Education: A Curricular Perspective\nDan-Adrian German, Indiana University, Bloomington, IN, USA\nMarcelo Pias, Federal University of Rio Grande, Rio Grande, RS, Brazil\nQiao Xiang, Xiamen University, Xiamen, Fujian, China\nAt the end of 2023 we are still in the NISQ era [4,5]. The term (Noisy Intermediate-Scale Quantum) was\nintroduced by John Preskill at Q2B in December 2017. Atom Computing first reached 1,000 qubits in\n2013 [9], soon thereafter followed by IBM [10]. The milestone marks just how far the industry has come:\nonly 6 years ago, typically, under 10 qubits were available for developers on the IBM Quantum\nExperience. Long-time quantum pioneer D-Wave remains an outlier in that it has a 5,000-qubit system\n(Advantage) but it is an analog, not a gate-based system; it is an open question whether gate-based\napproaches are necessary to get the full power of fault-tolerant quantum computing and D-Wave has\nrecently started developing gate-based technology. On the other hand, adiabatic quantum computing\n(AQC) and quantum annealing (QA) remain legitimate (and promising) avenues of research in quantum\ncomputation. Also, this year, a Harvard-led team developed the first-ever quantum circuit with logical\nquantum bits [1]. Arrays of “noisy” physical Rydberg qubits were used to create quantum circuits with\n48 error-correcting logical qubits, the largest number to date, a crucial step towards realizing fault-\ntolerant quantum computing. Meanwhile, PsiQuantum continues to pursue unabated the 1,000,000\n(physical) qubits mark [7,8]. The competition between the various qubit implementation modalities\nintensified: superconducting qubits, trapped atoms/ions, spin qubits (Intel has a 12-qubit chip) and\nphotonics are currently in the lead. Debates [6] now abound about the potential (or impending) demise\nof the NISQ era. The industry remains engaged in a sustained effort of both short-term (upskilling and\nreskilling workers, and HS teachers) and long-term workforce development. This past summer,\nresearchers at Quantinuum and Oxford University [2,11] established the foundations and methodology\nfor an ongoing educational experiment to investigate the question: ‘From what age can students learn\nquantum theory if taught using a diagrammatic approach?' The math-free framework in [3] was used to\nteach the pictorial method to UK schoolchildren, who then beat the average exam scores of Oxford\nUniversity’s postgraduate physics students. The experiment involved 54 schoolchildren, aged 15-17,\nrandomly selected from around 1,000 applicants, from 36 UK schools (mostly state schools).\nTeenagers spent two hours a week in online classes and after eight weeks were given a test using\nquestions taken from past Oxford postgraduate quantum exams: more than 80% of the pupils passed\nand around half earned a distinction. Interest in incorporating quantum architecture topics in the\ntraditional CS curriculum remains high for the next 10-year horizon. A growing consensus is that the CS\nundergraduate must have a proper appreciation for the quantum mechanical nature of our world. The\nmain prerequisite to such a knowledge unit remains a certain intellectual versatility, manifested in the\nwillingness to be exposed to information from more than one domain/discipline. In quantum computing,\nlabs will be quintessential and will rely on (1) computer-assisted mathematics (e.g., Wolfram Alpha,\nNumPy, Qiskit, Matplotlib, etc.) as well as CAD/CAM and advanced software emulation (Qiskit Metal),\n(2) access to actual quantum computers via various cloud platforms (Amazon Braket, IBM Q, Xanadu\nBorealis, etc.) and (3) occasionally access to a physics lab, fab or foundry. A genuinely interdisciplinary\nprogram can only be built if faculty have wide general support towards such a goal. Three curricular\napproaches have emerged: one is entirely without math but leading into math and lasts about eight\nweeks. The second is a full semester, 14-week long, and entirely based on linear algebra. The last one\n435\nis two semesters long and includes weekly, messy but critical, quantum hardware labs supporting a\nquantum engineering degree. Incorporating material about all qubit modalities in the curriculum will\nensure the material will remain relevant over a reasonably long period of time, if it includes such topics\nas the design and implementation of qubits (e.g., via Qiskit Metal) and error mitigation and (classical)\ncontrol.\nReferences\n[1] D. Bluvstein, S. J. Evered, A. A. Geim, et al. Logical quantum processor based on reconfigurable\natom arrays. In Nature. https://doi.org/10.1038/s41586-023-06927-3 (6 Dec. 2023).\n[2] Bob Coecke. https://medium.com/quantinuum/everyone-can-learn-quantum-now-even-at-a-cutting-\nedge-level-and-we-have-the-test-scores-to-prove-49e7fdc5c509 (21 Dec. 2023). Accessed March\n2024.\n[3] Bob Coecke and Stefano Gogioso. Quantum in Pictures: A New Way to Understand the Quantum\nWorld. Cambridge Quantum, 1st edition (3 Feb. 2023).\n[4] John Preskill. Quantum Computing in the NISQ era and beyond. Quantum 2, 79 (2018).\nhttps://quantum-journal.org/papers/q-2018-08-06-79/. Accessed March 2024; Preprint:\nhttps://arxiv.org/abs/1801.00862. Accessed March 2024.\n[5] John Preskill. Quantum technology in the short term and long term: the search for applications.\nhttps://www.youtube.com/watch?v=TSzpz8N7Xw4 (Q2B 2018 Keynote Address). Accessed March\n2024.\n[6] John Preskill. Crossing the Quantum Chasm: From NISQ to Fault Tolerance. Q2B 2023 (6 Dec\n2023) http://theory.caltech.edu/~preskill/talks/Preskill-Q2B-2023 (slides, video not yet available).\n[7] Terry Rudolph. What is the logical gate speed of a photonic quantum computer? (June 21, 2023,\nvia John Preskill’s Twitter account and the Quantum Frontiers blog at the Institute for Quantum\nInformation and Matter at Caltech) https://quantumfrontiers.com/2023/06/21/what-is-the-logical-gate-\nspeed-of-a-photonic-quantum-computer/. Accessed March 2024.\n[8] John Russell. PsiQuantum’s Path to 1 Million Qubits.(21 April 2022, in hpcwire.com)\nhttps://www.hpcwire.com/2022/04/21/psiquantums-path-to-1-million-qubits-by-the-middle-of-the-\ndecade/.\n[9] John Russell. Atom Computing Wins the Race to 1000 Qubits. (24 Oct. 2023 in hpcwire.com)\nhttps://www.hpcwire.com/2023/10/24/atom-computing-wins-the-race-to-1000-qubits/ Accessed March\n2024.\n436\n[10] The Quantum Mechanic. IBM and UC Berkeley Usher in New Era of Quantum Computing with\n1,121 Qubit Machine. Hello IBM Condor. (4 Dec. 2023) https://quantumzeitgeist.com/ibm-and-uc-\nberkeley-usher-in-new-era-of-quantum-computing-with-1121-qubit-machine-hello-ibm-condor/.\nAccessed March 2024.\n[11] Aleks Kissinger. Research unveils new picture-based approach to teaching physics. (20 Dec.\n2023) https://www.cs.ox.ac.uk/news/2280-full.html. Accessed March 2024.\n437\nGenerative AI in Introductory Programming\nBrett A. Becker, University College Dublin, Dublin, Ireland\nMichelle Craig, University of Toronto, Toronto, Canada\nPaul Denny, The University of Auckland, Auckland, New Zealand\nHieke Keuning, Utrecht University, Utrecht, The Netherlands\nNatalie Kiesler, DIPF Leibniz Institute for Research and Information in Education, Frankfurt, Germany\nJuho Leinonen, Aalto University, Aalto, Finland\nAndrew Luxton-Reilly, The University of Auckland, Auckland, New Zealand\nLauri Malmi, Aalto University, Aalto, Finland\nJames Prather, Abilene Christian University, Abilene, TX, USA\nKeith Quille, TU Dublin, Dublin, Ireland\nGenerative AI tools based on Large Language Models (LLMs) such as OpenAI's ChatGPT, and IDEs\npowered by them such as GitHub Copilot, have demonstrated impressive performance in myriad types\nof programming tasks including impressive performance on CS1 and CS2 problems. They can often\nproduce syntactically and logically correct code from natural language prompts that rival the\nperformance of high-performing introductory programming students—an ability that has already been\nshown to extend beyond introductory programming [2]. However, their impact in the classroom goes\nbeyond producing code. For example, they could help level the playing field between students with and\nwithout prior experience. Generative AI tools have been shown to be proficient in not only explaining\nprogramming error messages but in repairing broken code [6], and pair programming might evolve from\ntwo students working together into “me and my AI.” On the other hand they could have negative effects.\nStudents could become over-reliant on them, and they may open up new divides due to different\nbackgrounds, experience levels and access issues [9]. Generative AI has been successful in\ngenerating novel exercises and examples including providing correct solutions and functioning test\ncases [11]. Instructional materials are already being produced including a textbook that uses\nGenerative AI from the first day of CS1 [8] that has already been used [4]. Given their ability to provide\ncode explanations [7] they have the potential to assess student work, provide feedback, and to act as\nalways-available virtual teaching assistants, easing the burden not only on the educator but on their\nhuman assistants and the broader educational systems where learning takes place [9]. Generative AI\ncould even affect student intakes given its prominence in the media and the effect that such forces can\nhave on who chooses to—and who chooses not to—study computing.\nGiven that Generative AI has the potential to reshape introductory programming, it is possible that it will\nimpact the entire computing curriculum, affecting what is taught, when it is taught, how it is taught, and\nto whom it is taught. However, the dust is far from settled on these matters with some educators\nembracing Generative AI and others very fearful that the challenges could outweigh the opportunities\n[5]. The computing education community needs to understand more about how students interact with\nGenerative AI [10] and provide tooling and strategies to effectively achieve that interaction [3]. Indeed,\nduring the transformation from pre- to post-Generative AI introductory programming, several issues\nneed to be mitigated including but certainly not limited to those of ethics, bias, academic integrity, and\nbroadening participation in computing [1]. Further study is warranted to explore the long-term effects of\n438\nGenerative AI on pedagogy, curriculum, student demographics, and the broader educational\necosystem.\nReferences\n[1] Brett A. Becker, Paul Denny, James Finnie-Ansley, et al. Programming Is Hard - Or at Least It Used\nto Be: Educational Opportunities and Challenges of AI Code Generation. In Proceedings of the 54th\nACM Technical Symposium on Computer Science Education V. 1, 2023. (Toronto, ON, Canada)\n(SIGCSE 2023). Association for Computing Machinery, New York, NY, USA, 500–506.\nhttps://doi.org/10.1145/3545945.3569759.\n[2] Paul Denny, James Prather, Brett A Becker, James Finnie-Ansley, Arto Hellas, Juho Leinonen,\nAndrew Luxton-Reilly, Brent N Reeves, Eddie Antonio Santos, and Sami Sarsa. 2024. Computing\nEducation in the Era of Generative AI. Commun. ACM 67, 2 (Feb. 2024).\nhttps://doi.org/10.1145/3624720. Preprint available: https://arxiv.org/abs/2306.02608. Accessed March\n2024).\n[3] Paul Denny, Juho Leinonen, James Prather, Andrew Luxton-Reilly, Thezyrie Amarouche, Brett\nBecker, and Brent Reeves. 2024. Prompt Problems: A New Programming Exercise for the Generative\nAI Era. In Proceedings of the 55th SIGCSE Technical Symposium on Computer Science Education\n(Portland, OR USA) (SIGCSE ’24). Association for Computing Machinery, New York, NY, USA.\nhttps://doi.org/10.1145/3626252.3630909. Preprint available: https://arxiv.org/abs/2311.05943.\nAccessed March 2024).\n[4] Katie E. Ismael, Ioana Patringenaru, and Kimberley Clementi. In This Era of AI, Will Everyone Be a\nProgrammer? UC San Diego Today (Dec 2023). https://today.ucsd.edu/story/in-this-era-of-ai-will-\neveryone-be-a-programmer. Accessed March 2024.\n[5] Sam Lau and Philip Guo. 2023. From \"Ban It Till We Understand It\" to \"Resistance is Futile\": How\nUniversity Programming Instructors Plan to Adapt as More Students Use AI Code Generation and\nExplanation Tools Such as ChatGPT and GitHub Copilot. In Proceedings of the 2023 ACM Conference\non International Computing Education Research - Volume 1 (Chicago, IL, USA) (ICER ’23). Association\nfor Computing Machinery, New York, NY, USA, 106–121. https://doi.org/10.1145/3568813.3600138.\n[6] Juho Leinonen, Arto Hellas, Sami Sarsa, et al. Using Large Language Models to Enhance\nProgramming Error Messages. In Proceedings of the 54th ACM Technical Symposium on Computer\nScience Education V. 1 (Toronto, ON, Canada) (SIGCSE 2023). Association for Computing Machinery,\nNew York, NY, USA, 563–569. https://doi.org/10.1145/3545945.3569770.\n[7] Stephen MacNeil, Andrew Tran, Dan Mogil, Seth Bernstein, Erin Ross, and Ziheng Huang.\nGenerating Diverse Code Explanations using the GPT-3 Large Language Model. In Proceedings of the\n2022 ACM Conference on International Computing Education Research - Volume 2 (ICER '22), Vol. 2.\nAssociation for Computing Machinery, New York, NY, USA, 37–39.\nhttps://doi.org/10.1145/3501709.3544280.\n439\n[8] Leo Porter and Daniel Zingaro. 2023. Learn AI-Assisted Python Programming with GitHub Copilot\nand ChatGPT. Manning, Shelter Island, NY, USA. https://www.manning.com/books/learn-ai-assisted-\npython-programming. Accessed March 2024.\n[9] James Prather, Paul Denny, Juho Leinonen, Brett A. Becker, Ibrahim Albluwi, Michelle Craig, Hieke\nKeuning, Natalie Kiesler, Tobias Kohn, Andrew Luxton-Reilly, Stephen MacNeil, Andrew Petersen,\nRaymond Pettit, Brent N. Reeves, and Jaromir Savelka. The Robots Are Here: Navigating the\nGenerative AI Revolution in Computing Education. In Proceedings of the 2023 Working Group Reports\non Innovation and Technology in Computer Science Education (Turku, Finland) (ITiCSE-WGR ’23).\nAssociation for Computing Machinery, New York, NY, USA, 108–159.\nhttps://doi.org/10.1145/3623762.3633499.\n[10] James Prather, Brent N. Reeves, Paul Denny, Brett A. Becker, Juho Leinonen, Andrew Luxton-\nReilly, Garrett Powell, James Finnie-Ansley, and Eddie Antonio Santos. 2023. “It’s Weird That It Knows\nWhat I Want”: Usability and Interactions with Copilot for Novice Programmers. ACM Trans. Comput.-\nHum. Interact. 31, 1, Article 4 (Nov 2023), 31 pages. https://doi.org/10.1145/3617367.\n[11] Sami Sarsa, Paul Denny, Arto Hellas, and Juho Leinonen. Automatic Generation of Programming\nExercises and Code Explanations Using Large Language Models. In Proceedings of the 2022 ACM\nConference on International Computing Education Research - Volume 1 (Lugano and\nVirtual Event, Switzerland) (ICER ’22). Association for Computing Machinery, New York, NY, USA, 27–\n43. https://doi.org/10.1145/3501385.3543957.\n440\nThe 2022 Undergraduate Database Course in Computer Science: What to\nTeach?\nMikey Goldweber, Denison University, Granville, OH, USA\nMin Wei, Microsoft, Seatle, WA, USA\nSherif Aly, The American University in Cairo, Cairo, Egypt\nRajendra K. Raj, Rochester Institute of Technology, Rochester, NY, USA\nMohamed Mokbel, University of Minnesota, St. Paul, MN, USA\nOne issue with the study of databases, though maybe it should be labeled data management, or maybe\neven more precisely, the study of persistent data, is that the number of possible topics far exceeds the\nbandwidth of a single undergraduate CS course. Yes, there are several institutions with two course\nsequences. However, most undergraduate curricula, based on CS2013 [2] recommendations or ABET\n[1] criteria, have at most one database course, or just an elective. So, the question arises as to what to\ninclude and what to exclude.\nContributing to this phenomenon are the emergence of new topics (e.g., NoSQL, distributed and cloud-\nbased databases) and the current renewed (and hopefully continuing) emphasis on both security and\nprivacy, as well as societal and ethical issues associated with persistent data.\nAnother complicating factor is the institutional context. Every institution's curricular viewpoint sits\nsomewhere on the spectrum between computer science as a pure science and computer science as a\nprofession. Institutions are now preparing graduates for careers as Data Engineers, Data Infrastructure\nEngineers, and Data Scientists, in addition to Computer Scientists.\nThere are four primary perspectives with which to approach databases.\n1. Database designers/modelers: those who model the data from an enterprise and organize it\naccording to the principles of a given data model.\n2. Database users: (SQL?) query writers.\n3. Database administrators: those involved with tuning database performance through the building of\nindex structures and the setting of various parameters.\n4. Database engine developers: those who write the code for database engines.\nFour different viewpoints for what an undergraduate CS course in Databases/Data Management should\ncover are described in [3].\nReferences\n[1] ABET (2022). ABET Computing Accreditation Commission: Criteria for Accrediting Computing\nPrograms. https://www.abet.org/accreditation/accreditation-criteria/criteria-for-accrediting-computing-\nprograms-2022-2023/. Accessed March 2024.\n441\n[2] ACM (2013). Computer Science Curricula 2013: Curriculum Guidelines for Undergraduate Degree\nPrograms in Computer Science, Association for Computing Machinery and IEEE Computer\nSociety. https://doi.org/10.1145/2534860.\n[3] Mikey Goldweber, Min Wei, Sherif Aly, Rajendra K. Raj, and Mohamed Mokbel. The 2022\nundergraduate database course in computer science: what to teach? ACM Inroads 13, 3 (September\n2022), 16–21. https://doi.org/10.1145/3549545.\n442\nComputer Science Curriculum Guidelines: A New Liberal Arts Perspective\nJakob Barnard; University of Jamestown; Jamestown, MD, USA\nValerie Barr; Bard College; Annandale-on-Hudson, NY, USA\nGrant Braught; Dickinson College; Carlisle, PA, USA\nJanet Davis; Whitman College; Walla Walla, WA, USA\nAmanda Holland-Minkley; Washington & Jefferson College; Washington, PA, USA\nDavid Reed; Creighton University; Omaha, NE, USA\nKarl Schmitt; Trinity Christian College; Palos Heights, IL, USA\nAndrea Tartaro; Furman University; Greenville, SC, USA\nJames Teresco; Siena College; Loudonville, NY, USA\nACM/IEEE curriculum guidelines for computer science, such as CS2023, provide well-researched and\ndetailed guidance regarding the content and skills that make up an undergraduate computer science\n(CS) program. Liberal arts CS programs often struggle to apply these guidelines within their institutional\nand departmental contexts [6]. Historically, this has been addressed through the development of model\nCS curricula tailored for the liberal arts context [1,2,3,4,7]. We take a different position: that no single\nmodel curriculum can apply across the wide range of liberal arts institutions. Instead, we argue that\nliberal arts CS educators need best practices for using guidelines such as CS2023 to inform curriculum\ndesign. These practices must acknowledge the opportunities and priorities of a liberal arts philosophy\nas well as institutional and program missions, priorities, and identities [5].\nThe history, context, and data about liberal arts CS curriculum design support the position that the\nliberal arts computing community is best supported by a process for working with curricular guidelines\nrather than a curriculum model or set of exemplars [5]. Previous work with ACM/IEEE curriculum\nguidelines over the decades has trended towards acknowledging that liberal arts CS curricula may take\na variety of forms and away from presenting a unified “liberal arts” model [6]. A review of liberal arts CS\nprograms demonstrates how institutional context, including institutional mission and structural factors,\nshape their curricula [5]. Survey data indicates that liberal arts programs have distinct identities or\nmissions, and this directly impacts curriculum and course design decisions. Programs prioritize flexible\npathways through their programs coupled with careful limits on required courses and lengths of\nprerequisite chains [6]. This can drive innovative course design where content from Knowledge Areas is\nblended rather than compartmentalized into distinct courses [7,8]. The CS curriculum is viewed as part\nof the larger institutional curriculum and the audience for CS courses is broader than just students in\nthe major, at both the introductory level and beyond.\nTo support the unique needs of CS liberal arts programs, we propose a process that guides programs\nto work with CS2023 through the lens of institutional and program missions and identities, goals,\npriorities, and situational factors. The Process Workbook we have developed comprises six major\nsteps:\n1. articulate institutional and program mission and identity;\n2. develop curricular design principles driven by program mission and identity, structural factors,\nand attention to diversity, equity, and inclusion;\n443\n3. identify aspirational learning outcomes in response to design principles and mission and\nidentity;\n4. engage with CS2023 to select curriculum and course content based on design principles to\nachieve learning outcomes and support mission and identity;\n5. evaluate the current program, with attention to current strengths, unmet goals, and opportunities\nfor improvement;\n6. design, implement, and assess changes to the curriculum.\nAn initial version of the Process Workbook, based on our research and feedback from workshops [9,\ne.g., 10,11] and pilot usage within individual departments, is available as a supplement to this article\n[12]. The authors will continue this iterative design process and release additional updates as we gather\nmore feedback. Future work includes development of a repository of examples of how programs have\nmade use of the Workbook to review and redesign their curricula in the light of CS2023.\nReferences\n[1] Kim B. Bruce, Robert D. Cupper, and Robert L. Scot Drysdale. A History of the Liberal Arts\nComputer Science Consortium and Its Model Curricula. ACM Trans. Comput. Educ. 10,1, Article 3\n(March 2010), 12 pages. https://doi.org/10.1145/1731041.1731044.\n[2] Liberal Arts Computer Science Consortium. A 2007 Model Curriculum for a Liberal Arts Degree in\nComputer Science. J. Educ. Resour. Comput. 7,2 (June 2007), 2-es.\nhttps://doi.org/10.1145/1240200.1240202.\n[3] Henry M. Walker and G. Michael Schneider. A Revised Model Curriculum for a Liberal Arts Degree\nin Computer Science. Commun. ACM 39,12 (Dec. 1996), 85–95.\nhttps://doi.org/10.1145/240483.240502.\n[4] Norman E. Gibbs and Allen B. Tucker. A Model Curriculum for a Liberal Arts Degree in Computer\nScience. Commun. ACM 29, 3 (March 1986), 202-210. https://doi.org/10.1145/5666.5667.\n[5] Amanda Holland-Minkley, Jakob Barnard, Valerie Barr, Grant Braught, Janet Davis, David Reed,\nKarl Schmitt, Andrea Tartaro, and James D. Teresco. Computer Science Curriculum Guidelines: A New\nLiberal Arts Perspective. In Proceedings of the 54th ACM Technical Symposium on Computer Science\nEducation V. 1 (SIGCSE 2023). Association for Computing Machinery, New York, NY, USA, 617-623.\nhttps://doi.org/10.1145/3545945.3569793.\n[6] James D. Teresco, Andrea Tartaro, Amanda Holland-Minkley, Grant Braught, Jakob Barnard, and\nDouglas Baldwin. CS Curricular Innovations with a Liberal Arts Philosophy. In Proceedings of the 53rd\nACM Technical Symposium on Computer Science Education V. 1 (Providence, RI, USA) (SIGCSE\n2022). Association for Computing Machinery, New York, NY, USA, 537-543.\nhttps://doi.org/10.1145/3478431.3499329.\n[7] Henry M. Walker and Samuel A. Rebelsky. Using CS2013 for a Department’s Curriculum Review: A\nCase Study. J. Comput. Sci. Coll. 29,5 (May 2014), 138-144.\n444\n[8] David Reed. Spiraling CS2013 Knowledge Units across a Small CS Curriculum. J. Comput. Sci.\nColl. 32,5 (May 2017), 125-131.\n[9] Amanda Holland-Minkley, Andrea Tartaro, and Jakob Barnard. Innovations and Opportunities in\nLiberal Arts Computing Education, https://computing-in-the-liberal-arts.github.io/SIGCSE2023-Affiliated-\nEvent/. URL. SIGCSE 2023 Affiliated Event by the SIGCSE Committee on Computing Education in\nLiberal Arts Colleges.\n[10] Jakob Barnard, Grant Braught, Janet Davis, Amanda Holland-Minkley, David Reed, Karl Schmitt,\nAndrea Tartaro, and James Teresco. Developing Identity-Focused Program-Level Learning Outcomes\nfor Liberal Arts Computing Programs. J. Comput. Sci. Coll. 39,4 (October 2023), 97-98.\n[11] Jakob Barnard, Grant Braught, Janet Davis, Amanda Holland-Minkley, David Reed, Karl Schmitt,\nAndrea Tartaro, and James Teresco. Reflective Curriculum Review for Liberal Arts Computing\nPrograms. J. Comput. Sci. Coll. 38, 3 (November 2022), 178–179.\n[12] SIGCSE Committee on Computing Education in Liberal Arts Colleges. 2023. CS2023 Activity: The\nCurricular Practices Workbook. https://computing-in-the-liberal-arts.github.io/CS2023/. Accessed March\n2024.\n445\nComputer Science Education in Community Colleges\nElizabeth Hawthorne, Rider University, Lawrenceville, NJ, USA\nLori Postner, Nassau Community College, Garden City, NY, USA\nChristian Servin, El Paso Community College, El Paso, TX, USA\nCara Tang, Portland Community College, Portland, OR, USA\nCindy Tucker, Bluegrass Community and Technical College, Lexington, KY, USA\nCommunity and Technical Colleges serve as two-year educational institutions, providing diverse\nacademic degrees like associate's degrees in academic and applied sciences, certificates of\ncompletion, and remedial degrees. These colleges play a crucial role in fostering collaboration between\nstudents, workers, and institutions through educational and workforce initiatives. Over the past 50+\nyears, Community Colleges have served as a hub for various educational initiatives and partnerships\ninvolving K-12 schools, four-year colleges, and workforce/industry collaborations.\nThese colleges offer specialized programs that help students focus on specific educational pathways.\nAmong the programs available, computing-related courses are prominent, including Computer Science\ndegrees, particularly the Associate in Arts (AA) and Sciences (AS) degrees, known as academic\ntransfer degrees. These transfer degrees are designed to align with the ACM/IEEE curricular\nguidelines, primarily focusing on creating two-year programs that facilitate smooth transferability to four-\nyear colleges.\nFurthermore, the computing programs offered by Community Colleges are influenced by the specific\nneeds and aspirations of the regional workforce and industry. Advisory boards and committees play a\nsignificant role in shaping these programs by providing recommendations based on the demands of the\njob market. While the ACM Committee for Computing in Community Colleges (CCECC) and similar\nentities help address inquiries related to these transfer degrees, there is a desire to capture the\nchallenges, requirements, and recommendations from the Community College perspective in\ndeveloping general curricular guidelines.\nThis work presents the context and perspective of the community college education. It emphasizes the\nimportance of understanding the unique challenges faced by Community Colleges and their specific\nneeds while formulating curricular guidelines. Additionally, the work envisions considerations for the\nnext decade regarding curricular development and administrative efforts, considering the evolving\neducational landscape and industry demands. By doing so, the vision is to enhance the effectiveness\nand relevance of computing programs offered by Community Colleges and foster better alignment with\nthe needs of students and the job market.\nReferences\n[1] \"ABET Accredits 54 Additional Programs in 2021, Including First Associate Cybersecurity\nprograms.\" https://www.abet.org/abet-accredits-54-new-programs-in-2021-including-first-associate-\ncybersecurity-programs/. Accessed Feb 29, 2024.\n446\n[2] William F. Atchison, Samuel D. Conte, John W. Hamblen, Thomas E. Hull, Thomas A. Keenan,\nWilliam B. Kehl, Edward J. McCluskey, Silvio O. Navarro, Werner C. Rheinboldt, Earl J. Schweppe,\nWilliam Viavant, and David M. Young. \"Curriculum 68: Recommendations for Academic Programs in\nComputer Science: A Report of the ACM Curriculum Committee on Computer Science.\"\nCommunications of the ACM 11,3 (1968), 151-197. https://doi.org/10.1145/362929.362976.\n[3] Jill Denner, Paul Tymann, and Huihui Wang. \"Community College Pathways.\" In Proceedings of\nthe 2023 CISE EWF PI Meeting. Georgia Tech Conference Center.\n[4] Dennis Foley, Leslie Milan, and Karen Hamrick. 2020. \"The Increasing Role of Community\nColleges among Bachelor’s Degree Recipients: Findings from the 2019 National Survey of College\nGraduates.\" Technical Report NSF 21-309. National Center for Science and Engineering Statistics\n(NCSES), Alexandria, VA. https://ncses.nsf.gov/pubs/nsf21309/. Accessed March 2024.\n[5] ACM Committee for Computing Education in Community Colleges (CCECC). 2017. \"ACM\nComputer Science Curricular Guidance for Associate-Degree Transfer Programs with Infused\nCybersecurity.\" 2017. Association for Computing Machinery, New York, NY, USA.\n[6] The Community College Presidents Initiative in STEM. 2023. \"Community college presidents\ninitiative – STEM – achieving excellence in workforce education.\" https://www.ccpi-stem.org/. Accessed\nMarch 2024.\n[7] Robin G Isserles. \"The Costs of Completion: Student Success in Community College.\" JHU\nPress, 2021\n[8] Association for Computing Machinery (ACM) Joint Task Force on Computing Curricula and\nIEEE Computer Society. \"Computer Science Curricula 2013: Curriculum Guidelines for Undergraduate\nDegree Programs in Computer Science.\" ACM, New York, NY, USA, 2013.\n[9] A. Kahlon, D. Boisvert, L.A. Lyon, M. Williamson, and C. Calhoun. \"The Authentic Inclusion and\nRole of Community Colleges in National Efforts to Broaden Participation in Computing.\" In Proceedings\nof the 2018 ACM SIGCSE Technical Symposium on Computer Science Education (SIGCSE ’18). ACM,\nNew York. https://doi.org/10.1145/3159450.3159627.\n[10] Amruth N. Kumar and Rajendra K. Raj. \"Computer Science Curricula 2023 (CS2023):\nCommunity Engagement by the ACM/IEEE-CS/AAAI Joint Task Force.\" In Proceedings of the 54th\nACM Technical Symposium on Computer Science Education V. 2 (Toronto, ON, Canada) (SIGCSE\n2023). Association for Computing Machinery, New York, NY, USA, 1212-1213.\nhttps://doi.org/10.1145/3545947.3569591.\n[11] Joyce Currie Little, Richard H. Austing, Harice Seeds, John Maniotes, and Gerald L. Engel..\n\"Curriculum recommendations and guidelines for the community and junior college career program in\ncomputer programming: a working paper of the ACM committee on curriculum in computer sciences by\nthe subcommittee on community and junior college curriculum.\" ACM SIGCSE Bulletin - Special issue\non computer science curricula 9, 2 (1977), 1-16. https://doi.org/10.1145/988948.988951.\n447\n[12] B. Morrison and A. Settle. \"Celebrating SIGCSE’s 50th Anniversary!\" SIGCSE Bulletin 50,1\n(2018), 2-3.\n[13] American Association of Community Colleges. 2022. \"The Economic Value of America’s\nCommunity Colleges.\" https://www.aacc.nche.edu/2022/11/29/the-economic-value-of-americas-\ncommunity-colleges-report/. Accessed March 2024.\n[14] Christian Servín. \"Fuzzy Information Processing Computing Curricula: A Perspective from the\nFirst Two-Years in Computing Education.\" In Explainable AI and Other Applications of Fuzzy\nTechniques: Proceedings of the 2021 Annual Conference of the North American Fuzzy Information\nProcessing Society, NAFIPS 2021. Springer, 453-460.\n[15] Christian Servin, Elizabeth K. Hawthorne, Lori Postner, Cara Tang, and Cindy Tucker.\n\"Community Colleges Perspectives: From Challenges to Considerations in Curricula Development\n(SIGCSE 2023).\" Association for Computing Machinery, New York, NY, USA, 1244.\nhttps://doi.org/10.1145/3545947.3573335.\n[16] Christian Servin, Elizabeth K. Hawthorne, Lori Postner, Cara Tang, and Cindy S. Tucker.\n\"Mathematical Considerations in Two-Year Computing Degrees: The Evolution of Math in Curricular\nGuidelines.\" In The 24th Annual Conference on Information Technology Education (SIGITE ’23)\n(Marietta, GA, USA). ACM. https://doi.org/10.1145/3585059.3611441.\n[17] Cara Tang. 2017. \"Community College Corner Community colleges in the United States and\naround the world.\" ACM Inroads 8,1 (2017), 21-23.\n[18] Cara Tang. 2018. \"Community Colleges and SIGCSE: A Legacy Fueling the Future.\" ACM\nInroads 9,4 (2018), 49-52. https://doi.org/10.1145/3230699.\n[19] Cara Tang, Elizabeth K Hawthorne, Cindy S Tucker, Ernesto Cuadros-Vargas, Diana\nCukierman, and Ming Zhang. \"Global Perspectives on the Role of Two-Year/Technical/Junior Colleges\nin Computing Education.\" In Proceedings of the 2016 ACM Conference on Innovation and Technology\nin Computer Science Education. 204-205.\n[20] \"Celebrating 40++ years of service to computing education communities.\" [n.d.]. ACM CCECC.\nhttps://ccecc.acm.org/correlations/all. Accessed March 2024.\n[21] Stuart Zweben, Jodi L.Tims, Cindy Tucker, and Yan Timanovsky. \"ACM-NDC Study 2021–2022:\nTenth Annual Study of Non-Doctoral-Granting Departments in Computing.\" ACM Inroads 13,3 (2022),\n38-54. https://doi.org/10.1145/3544304.\n[22] Stuart Zweben and Cindy Tucker. \"How Well Did We Keep Students in Computing Programs,\nPre-COVID and COVID?\" ACM Inroads 13,4 (2022), 32-52. https://doi.org/10.1145/3571094.\n448\nGenerative AI and the Curriculum\nIntroduction\nGenerative AI technologies have begun to revolutionize the ways students learn. While it is too early to\nconfidently predict how they will change computer science education, it is instructive to consider some\nof the ramifications already apparent. In this section, a few specific implications of generative AI are\nexplored by competency and knowledge areas. The overall observations follow.\n● Educators can use generative AI to create course syllabi, design projects and assignments, and\nautomate grading.\n● Students can use generative AI for individualized tutoring, undergraduate research, enhanced\nproductivity, etc. The skill set expected of students is changing, but the foundational knowledge\nthey need to know is not.\n● Tasks that are intellectually challenging, yet mechanical in nature will be automated. So,\nstudents must learn to work at higher levels of abstraction.\n● Issues of society, ethics, and the profession are taking on much more importance and\nsignificance and must not only be actively addressed in the curriculum, but also periodically\nrevisited and revised.\nImplications by Competency Area - Software\nAlgorithmic Foundations (AL)\n● The immediate impact of generative AI on Algorithmic Foundations is expected to be less than what\nis found in other knowledge areas since AL topics are primarily focused on students understanding\nthe foundations of algorithmic computation. As an example, while generative AI may be prompted to\nproduce an algorithmic solution utilizing less memory or improved runtime performance, students\nare expected to be able to evaluate the results of generative AI from an AL perspective of time-\nspace tradeoff and complexity analysis.\nFoundations of Programming Languages (FPL)\n● The next paradigm in programming might be conversational programming that involves providing\nappropriate prompts to help generative AI produce and test desired programs. Generative AI is also\nlikely to be able to translate code from one programming language to another, and from one\nparadigm to another. Program correctness proofs and validating program behavior against a\nspecification may also be areas in which generative AI makes advances because of the\nintellectually challenging, yet mechanical, nature of the process.\nSoftware Development Fundamentals (SDF)\n● While generative AI can write simple programs, the responsibility to verify the correctness of the\nprograms still falls on the user. So, even for verification purposes only, computer science students\nstill need to learn how to write programs. In order to provide appropriate prompts to generative AI,\nstudents need to be able to design and plan larger programs. How students design and write\n449\nprograms will evolve as generative AI technologies improve. How computer science educators must\nadapt to teaching programming with the help of generative AI is currently an open question. It\nseems likely that reading programs will see a sharpened focus and the idea of learning to program\nby writing, and reliance on learning syntax, will change towards learning to program by prompting,\ncomprehending, verifying, editing, modifying, adapting, and testing code. It is also likely that other\naspects of the curriculum such as problem decomposition will see increased focus.\nSoftware Engineering (SE)\n● Generative AI is expected to have substantial impact on several aspects of the software process,\nincluding (but not limited to) development of new code, comprehension of complex logging and\ndebugging artifacts, static analysis, and code reviewing. The most understandable and visible\nchange is likely to be in the development of (rote) new code—assistance technologies like GitHub's\nCopilot and other advanced auto-complete mechanisms can meaningfully improve development\ntime, to a point. Effective use of such tools requires a deeper investment in design and code\ncomprehension, while potentially decreasing the need for hands-on programming time. Similar\nadvances in static analysis and code review are anticipated to have a meaningful impact on code\nquality and clarity, ideally also reducing the impact of implicit bias by increasing consistency and\nquality of comments and diagnostics.\nImplications by Competency Area - Systems\nArchitecture and Organization (AR)\n● The evolution needed in computer architecture to better support generative AI technologies may\nitself become a critical area of study in the future. Another might be the impact of using generative\nAI for hardware design.\nData Management (DM)\n● Generative AI systems appear to excel at accomplishing intellectually challenging, yet mechanical\ntasks. It seems evident that given the expression of a query in pseudocode (or relational\nalgebra/calculus), the translation of a description of the desired query result into SQL will become a\nroutine generative AI task. In one sense, generative AI allows database querying at a higher\n(natural language, pseudocode) level. However, regardless of the level at which students query a\ndatabase, they will still need the skills to validate the results returned by an (AI-generated) SQL\nquery.\nNetworking and Communication (NC)\n● Generative AI technologies may be increasingly used in computer science education of networking\nand communications. For example, it can generate code for new or existing networking protocols,\nsuggestions for improvement, generate network traffic data for experimentation purposes, and\ngenerate scenarios for which a network architecture needs to be designed. Furthermore, it can\nverify whether networking requirements are ambiguous or complete. It can be used to automatically\n450\ngenerate configuration scripts, perform security assessments of existing networked configurations\nsuch as identifying vulnerabilities, and suggesting countermeasures, and perform reliability\nassessments and capacity planning.\nOperating Systems (OS)\n● Generative AI will be helpful with deployment scripts and system optimization. In the short term,\ngenerative AI will not invalidate the need for students to understand the layer between applications\nand the architecture. With that said, AI eventually will provide insight into the expected performance\nor security implications of software that is developer- or AI-generated. Students will need to\ncontinue to innovate and reason at higher-levels of abstraction.\nSystems Fundamentals (SF)\n● Providing system support for generative AI applications is expected to turn into a robust area of\nresearch and education.\nSecurity (SEC)\n● Generative AI can be used both by an adversary to launch more sophisticated attacks or develop\nmore dangerous malware and by the defender to protect against such attacks. Other issues in the\nimpact of generative AI on security include interaction between an AI attacker and defender,\nsecurity risks of data and reverse engineering AI models, AI-based data aggregation / phishing, and\nsecurity of AI systems themselves. Students need to develop a nuanced understanding of the\npower and drawbacks of generative AI applied to security concerns.\nImplications by Competency Area - Applications\nArtificial Intelligence (AI)\n● The success of generative AI is already attracting more interest in Artificial Intelligence as a field,\nboth increasing the number of students interested in studying it and increasing its applicability to\nother subfields of computer science. Generative models provide opportunities to incorporate\nmultimodal analysis into larger pipelines and provide alternatives to techniques such as classical\nplanning (e.g., using an LLM to suggest next steps to solving a problem). However, they currently\nlack foundational guarantees of correctness, grounded perception, and explanation that are critical\nto many applications. Emerging techniques for combining subsymbolic and symbolic methods using\ngenerative models look promising for resolving these issues.\nGraphics and Interactive Techniques (GIT)\n● Intellectual property and ethical issues regarding the use of generative AI for 2D and 3D graphics,\nimages, video, and animation are important and evolving. These apply both to the media content\nand/or creative work used to train AI as well as the media created using generative AI.\n451\nHuman-Computer Interaction (HCI)\n● Generative AI will have a broad impact on the ways that people regard, and therefore interact, with\ncomputers and their output. Programs that employ generative AI can offer a simple interface that\nresponds to user prompts and rapidly produce acceptable output. Such products, however, require\nuser education to set reasonable expectations and acknowledge generative AI’s ability to err and to\nhallucinate. Users must also know how to engineer a prompt to achieve the desired effect. Ideally, a\nproduct that employs generative AI should have safeguards that evolve with their use and be\nadaptive for accuracy and sensitivity to the user's cultural norms. Finally, users should become\naware of issues surrounding intellectual property, transparency, and the extensive human labor\nrequired to train these models. The speed at which this technology continues to evolve requires\ncareful attention to both current and future potential pitfalls, failure modes, and human\nconsequences.\nSpecialized Platform Development (SPD)\n● From an educational standpoint, generative AI tools offer valuable assistance to both students and\ndevelopers. They enable the rapid creation of prototypes and the generation of code templates for\ncommon mobile app elements. Moreover, these tools produce code snippets for routine tasks,\nreducing the necessity for manual coding. This functionality is particularly advantageous for novices\nand those in the initial stages of learning mobile development. Generative AI Integrated\nDevelopment Environment (IDE) plugins also deliver real-time feedback and suggestions to\nstudents as they write code.\nFurthermore, generative AI enriches teaching by crafting interactive simulations and virtual\nenvironments tailored to mobile app development. These environments allow students to\nexperiment and hone their skills effectively. In the educational context, generative AI is crucial in\nraising awareness of security and ethical considerations within mobile app development.\nAdditionally, AI serves as an invaluable resource for developers by providing continuous updates on\nthe latest trends and technologies in specialized platform development, ensuring developers\nmaintain up-to-date skills and knowledge in this rapidly evolving field.\nImplications for Crosscutting Areas\nMathematical and Statistical Foundations (MSF)\n● Mathematics is learned best by “doing” with sustained practice in working through problems.\nAlthough generative AI tools may help in explaining, they are just as likely to present complete\nsolutions to students, robbing them of the learning gains that occur in struggling through problems.\nIn contrast, generative AI tools could be adapted to help instructors automate grading of proofs that\nwould alleviate what is now a laborious task. In the longer term, a balanced approach could offer\neducator support (automated grading) and student support through customized tutoring to address\nskill gaps either before starting a new course or while taking a course as long as the during-course\nusage is calibrated carefully. Perhaps the best option at the moment is to encourage rigorous on-\ngoing experimentation with generative AI so that the academic computing community can identify\nbest practices for the future.\n452\nSociety, Ethics, and the Profession (SEP)\n● The education computer science students receive needs to incorporate all dimensions and roles of\nthe computing profession: technical, philosophical, and ethical. Generative AI raises unique risks for\nSEP, for instance deepfakes and misinformation will become more pervasive and harder to identify.\nBeing technically capable of ethically questionable action and being technically able to identify and\nprevent such actions puts greater burden on SEP lessons to make students aware of these\nresponsibilities and ensure that as they enter the workforce as graduates, they work to keep society\non a just path.\nImplications for the Curriculum\n● It is clear that students must learn how to correctly use generative AI technologies for coursework.\nThe boundary between using generative AI as a resource and using it to plagiarize must be\nclarified. The limitations (e.g., hallucinations) of the technology must be discussed, as should the\ninherent biases that may have been baked into the technology by virtue of the data used to train\nthem.\n● Many new technologies have already redefined the boundary between tasks that can be\nmechanized and those that will need human participation. Generative AI is no different. Correctly\nidentifying the boundary will be the challenge for computer science educators going forward.\n● Generative AI may be used to facilitate undergraduate research – more innovative research by\nmore students at all levels of technical ability. Generative AI may be used by students for various\nresearch-related tasks: to fill the gaps in their understanding of prior research, build systems with\nwhich to test hypotheses, help interpret the results, etc.\n● Students may use generative AI to summarize assigned readings, help explain gaps in their\nunderstanding of course material, fill in gaps in the presentations of the classes they missed, and\ninteractively quiz themselves to assist in their studying.\n453\n454\nAcknowledgments\nOrganization\nThe following assisted the task force in its work:\n• ACM Staff:\no Yan Timanovsky, ACM Education & Professional Development Manager\no Lisa Kline, ACM Education and Professional Development Assistant\no John Otero, Site Selection\n• Jens Palsberg, University of California, Los Angeles, CA, USA, Chair of SIG Chairs\n• ACM Education Board\no Elizabeth Hawthorne, Rider University, Lawrenceville, NJ, USA\no Alison Derbenwick Miller, Consultant, formerly Oracle Inc.\no Christine Stephenson, Google Inc. (retired)\n• Bruce McMillin, IEEE Computer Society, Professional & Educational Activities Board –\nCurriculum and Accreditation Committee (CA), Chair\n• IEEE Computer Society Staff:\no Eric Berkowitz, Director of Membership, USA\no Michelle Phon, Certification and Professional Education, USA\nReviewers\nThe following reviewed various knowledge area drafts:\n• Ginger Alford, Southern Methodist University, Dallas, TX, USA\n• Jeannie Albrecht, Williams College, Williamstown, MA, USA\n• Mostafa Ammar, Georgia Institute of Technology, Atlanta, GA, USA\n• Tom Anderson, University of Washington, Seattle, WA, USA\n• Christopher Andrews, Middlebury College, Middlebury, VT, USA\n• Elisa Baniassad, The University of British Columbia, Vancouver, BC, Canada\n• Arvind Bansal, Kent State University, Kent, OH, USA\n• Phillip Barry, University of Minnesota, Minneapolis, MN, USA\n• Brett A. Becker, University College Dublin, Dublin, Ireland\n• Judith Bishop, Stellenbosch University, Stellenbosch, South Africa\n• Alan Blackwell, University of Cambridge, Cambridge, UK\n• Olivier Bonaventure, Université Catholique de Louvain, Louvain-la-Neuve, Belgium\n• Kim Bruce, Pomona College, Claremont, CA, USA\n• John Carroll, Penn State, University Park, PA, USA\n• Gennadiy Civil, Google Inc., New York, NY, USA\n• Thomas Clemen, Hamburg University of Applied Sciences, Hamburg, Germany\n• Jon Crowcroft, University of Cambridge, Cambridge, UK\n• Melissa Dark, Dark Enterprises, Inc., Lafayette, IN, USA\n• Arindam Das, Eastern Washington University, Cheney, WA, USA\n455\n• Karen C. Davis, Miami University, Oxford, OH, USA\n• Henry Duwe, Iowa State University, Ames, IA, USA\n• Roger D. Eastman, University of Maryland, College Park, MD, USA\n• Yasmine Elglaly, Western Washington University, Bellingham WA, USA\n• Trilce Estrada, University of New Mexico, Albuquerque, NM, USA\n• David Flanagan, Text book Author\n• Akshay Gadre, University of Washington, Seattle, WA, USA\n• Ed Gehringer, North Carolina State University, Raleigh, NC, USA\n• Sheikh Ghafoor, Tennessee Tech University, Cookville, TN, USA\n• Tirthankar Ghosh, University of New Haven, West Haven, CT, USA\n• Michael Goldwasser, Saint Louis University, St. Louis, MO, USA\n• Martin Goodfellow, University of Strathclyde, Glasgow, UK\n• Vikram Goyal, IIIT, Delhi, India\n• Dan Grossman, University of Washington, Seattle, WA, USA\n• Xinfei Guo, Shanghai Jiao Tong University, Shanghai, China\n• Anshul Gupta, IBM Research, Yorktown Heights, NY, USA\n• Sally Hamouda, Virginia Tech, Blacksburg, VA, USA\n• Matthew Hertz, University at Buffalo, Buffalo, NY, USA\n• Michael Hilton, Carnegie Mellon University, Pittsburgh, PA, USA\n• Bijendra Nath Jain, IIIT, Delhi, India\n• Kenneth Johnson, Auckland University of Technology, Auckland, New Zealand\n• Krishna Kant, Temple University, Philadelphia, PA, USA\n• Hakan Kantas, Halkbank, Istanbul, Turkiye\n• Amey Karkare, Indian Institute of Technology, Kanpur, India\n• Kamalakar Karlapalem, International Institute of Information Technology, Hyderabad, India\n• Theodore Kim, Yale University, New Haven, CT, USA\n• Michael S. Kirkpatrick, James Madison University, Harrisonburg, VA, USA\n• Tobias Kohn, Vienna University of Technology, Vienna, Austria\n• Eleandro Maschio Krynski, Universidade Tecnológica Federal do Paraná, Guarapuava, Paraná,\nBrazil\n• Ludek Kucera, Charles University, Prague, Czechia\n• Fernando Kuipers, Delft University of Technology, Delft, The Netherlands\n• Matthew Fowles Kulukundis, Google, Inc., New York, NY, USA\n• Zachary Kurmas, Grand Valley State University, Allendale, MI, USA\n• Rosa Lanzilotti, Università di Bari, Bari, Italy\n• Alexey Lastovetsky, University College Dublin, Dublin, Ireland\n• Gary T. Leavens, University of Central Florida, Orlando, FL, USA\n• Kent D. Lee, Luther College, Decorah, IA, USA\n• Bonnie Mackellar, St. John’s University, Queens, NY, USA\n• Mary Lou Maher, University of North Carolina, Charlotte, NC, USA\n• Alessio Malizia, Università di Pisa, Pisa, Italy\n• Sathiamoorthy Manoharan, University of Auckland, Auckland, New Zealand\n• Maristella Matera, Politecnico di Milano, Milano, Italy\n• Stephanos Matsumoto, Olin College of Engineering, Needham, MA, USA\n456\n• Paul McKenney, Facebook, Inc.\n• Mia Minnes, University of California San Diego, San Diego, CA, USA\n• Michael A. Murphy, Coastal Carolina University, Conway, SC, USA\n• Raghava Mutharaju, IIIT, Delhi, India\n• V. Lakshmi Narasimhan, Georgia Southern University, Statesboro, GA, USA\n• Marion Neumann, Washington University in St Louis, St. Louis, MO, USA\n• Cheng Soon Ong, Data61 | CSIRO and Australian National University, Canberra Australia\n• Peter Pacheco, University of San Francisco, San Francisco, CA, USA\n• Andrew Petersen, University of Toronto, Mississauga, Canada\n• Cynthia A Phillips, Sandia National Lab, Albuquerque, NM, USA\n• Benjamin C. Pierce, University of Pennsylvania, Philadelphia, PA, USA\n• Sushil K. Prasad, University of Texas, San Antonio, TX, USA\n• Rafael Prikladnicki, Pontificia Universidade Catolica do Rio Grande do Sul, Porto Alegre, Brazil\n• Keith Quille, Technological University Dublin, Dublin, Ireland\n• Catherine Ricardo, Iona University, New Rochelle, NY, USA\n• Luigi De Russis, Politecnico di Torino, Torino, Italy\n• Beatriz Sousa Santos, University of Aveiro, Aveiro, Portugal\n• Michael Shindler, University of California, Irvine, CA, USA\n• Ben Shneiderman, University of Maryland, College Park, MD, USA\n• Anna Spagnolli, Università di Padova, Padova, Italy\n• Davide Spano, Università di Cagliari, Cagliari, Italy\n• Andreas Stathopoulos, William & Mary, Williamsburg, VA, USA\n• Anthony Steed, University College London, London, UK\n• Michael Stein, Metro State University, Saint Paul, MN, USA\n• Alan Sussman, University of Maryland, College Park, MD, USA\n• Andrea Tartaro, Furman University, Greenville, SC, USA\n• Tim Teitelbaum, Cornell University, Ithaca, NY, USA\n• Joseph Temple, Coastal Carolina University, Conway, SC, USA\n• Ramachandran Vaidyanathan, Louisiana State University, Baton Rouge, LA, USA\n• Salim Virji, Google Inc., New York, NY, USA\n• Guiliana Vitiello, Università di Salerno, Salerno, Italy\n• Philip Wadler, The University of Edinburgh, Edinburgh, UK\n• Charles Weems, University of Massachusetts, Amherst, MA, USA\n• Xiaofeng Wang, Free University of Bozen-Bolzano, Bolzano, Italy\n• Miguel Young de la Sota, Google Inc., USA\n• Massimo Zancanaro, Università di Trento, Trento, Italy\n• Ming Zhang, Peking University, Beijing, China\nContributors\nThe following contributed to various aspects of the report or to the design of the instruments used to\ncollect data for the report:\n457\n• Tom Crick, Swansea University, Swansea, UK\n• Steven Gordon, Ohio State University, Columbus, OH, USA (retired)\n• Amanda Holland-Minkley, Washington & Jefferson College, Washington, PA, USA\n• Mihaela Sabin, University of New Hampshire, Manchester, NH, USA\n• Mehran Sahami, Stanford University, Stanford, CA, USA, ACM Co-Chair, CS 2013\n• Karl Schmitt, Trinity Christian College, Palos Heights, IL, USA\n• Andrea Tartaro, Furman University, Greenville, SC, USA\n• Osei Tweneboah, Ramapo College of New Jersey, Mahwah, NJ, USA\n• Patrick Van Metre, MITRE Corporation, McLean, VA, USA\nIn addition, numerous educators provided comments and suggestions through feedback forms posted\nfor individual knowledge areas as well as for Version Beta and Version Gamma of the curricular report.\nTwo hundred and twelve US educators and 215 international educators filled out the initial survey of\ntheir use of CS2013. Eight hundred and sixty-five industry practitioners filled out the initial survey of the\nimportance of various curricular components for success after graduation. One hundred and eighty-two\neducators volunteered and filled out 70 surveys of CS Core topics. One hundred and ten educators\nfilled out a survey of the characteristics of computer science graduates and 65 educators filled out a\nsurvey of institutional challenges for computer science programs. Their participation and input greatly\ncontributed to the quality of the report.\nPartial support was provided by the National Science Foundation under grant DUE-2231333.\n458"
    }
  }
]